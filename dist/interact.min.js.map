{"version":3,"sources":["src/header.js","index.js","interact.js","src/Eventable.js","src/InteractEvent.js","src/Interactable.js","src/Interaction.js","src/actions/drag.js","src/actions/drop.js","src/actions/gesture.js","src/actions/index.js","src/actions/resize.js","src/autoScroll.js","src/autoStart/InteractableMethods.js","src/autoStart/delay.js","src/autoStart/drag.js","src/autoStart/gesture.js","src/autoStart/index.js","src/autoStart/resize.js","src/defaultOptions.js","src/index.js","src/inertia.js","src/interact.js","src/interactablePreventDefault.js","src/legacyBrowsers.js","src/modifiers/index.js","src/modifiers/restrict.js","src/modifiers/restrictEdges.js","src/modifiers/restrictSize.js","src/modifiers/snap.js","src/modifiers/snapSize.js","src/pointerEvents/holdRepeat.js","src/pointerEvents/index.js","src/pointerEvents/interactableTargets.js","src/scope.js","src/utils/Signals.js","src/utils/arr.js","src/utils/browser.js","src/utils/domObjects.js","src/utils/domUtils.js","src/utils/events.js","src/utils/extend.js","src/utils/getOriginXY.js","src/utils/hypot.js","src/utils/index.js","src/utils/interactionFinder.js","src/utils/isType.js","src/utils/isWindow.js","src/utils/pointerExtend.js","src/utils/pointerUtils.js","src/utils/raf.js","src/utils/rect.js","src/utils/window.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","interact","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","init","./src/index","./src/utils/window","2","_classCallCheck","instance","Constructor","TypeError","fireUntilImmediateStopped","event","listeners","len","immediatePropagationStopped","_require","indexOf","extend","Eventable","options","prototype","fire","undefined","onEvent","type","propagationStopped","on","eventType","listener","push","off","eventList","index","splice","./utils/arr","./utils/extend.js","3","getOriginXY","defaults","signals","InteractEvent","interaction","action","phase","element","related","target","deltaSource","origin","starting","ending","coords","startCoords","curCoords","prevEvent","page","client","x","y","ctrlKey","altKey","shiftKey","metaKey","button","buttons","currentTarget","relatedTarget","interactable","t0","downTimes","signalArg","iEvent","pageX","pageY","clientX","clientY","x0","y0","clientX0","clientY0","timeStamp","dt","pointerDelta","duration","speed","velocityX","vx","velocityY","vy","swipe","getSwipe","angle","Math","atan2","PI","overlap","left","up","right","down","velocity","preventDefault","stopImmediatePropagation","stopPropagation","_ref","dx","dy","./defaultOptions","./utils/Signals","./utils/extend","./utils/getOriginXY","4","isType","events","actions","scope","getElementRect","nodeContains","_require2","contains","_require3","wheelEvent","interactables","Interactable","_context","context","document","_win","getWindow","trySelector","_doc","win","addDocument","set","setOnEvents","phases","onAction","isFunction","onstart","onmove","onend","oninertiastart","setPerAction","option","isObject","perAction","enabled","isBool","getRect","isString","isElement","querySelector","rectChecker","checker","_backCompatOption","optionName","newValue","_iterator","names","_isArray","Array","isArray","_i","Symbol","iterator","next","done","value","inContext","ownerDocument","_onOffMultiple","method","useCapture","search","trim","split","prop","eventTypes","addDelegate","add","removeDelegate","remove","base","perActions","actionName","methodDict","methodName","_iterator2","settingsMethods","_isArray2","_i2","_ref2","setting","unset","delegatedEvents","delegated","selectors","contexts","delegateListener","delegateUseCapture","_iterator3","interactions","_isArray3","_i3","_ref3","interacting","stop","indexOfElement","get","dontCheckInContext","ret","forEachSelector","callback","./Eventable","./actions","./scope","./utils/browser","./utils/domUtils","./utils/events","./utils/isType","5","doOnInteractions","eventTarget","utils","getActualElement","path","curEventTarget","matches","browser","supportsTouch","test","prevTouchTime","Date","getTime","changedTouches","pointer","finder","Interaction","invalidPointer","supportsPointerEvent","mouse","pointerIsDown","pointerType","_updateEventTargets","endAll","end","onDocSignal","signalName","doc","eventMethod","docEvents","methodNames","prepared","name","axis","edges","pointers","pointerIds","downTargets","holdTimers","prevCoords","downEvent","downPointer","_eventTarget","_curEventTarget","pointerWasMoved","_interacting","pointerDown","pointerIndex","updatePointer","setCoords","copyCoords","pointerExtend","start","copyAction","pointerMove","simulation","duplicateMove","hypot","pointerMoveTolerance","getPointerIndex","duplicate","interactingBeforeMove","setCoordDeltas","doMove","_dontFireMove","pointerUp","removePointer","currentAction","getPointerId","id","pEventTypes","PointerEvent","move","cancel","mousedown","mousemove","mouseup","touchstart","touchmove","touchend","touchcancel","blur","endAllInteractions","./utils","./utils/interactionFinder","6","defaultOptions","drag","mouseButtons","snap","restrict","inertia","autoScroll","startAxis","lockAxis","dragOptions","getCursor","abs","draggable","ondragstart","ondragend","merge","../InteractEvent","../Interactable","../Interaction","../defaultOptions","../utils","./index","7","collectDrops","drops","elements","current","drop","accept","matchesSelector","dropElements","querySelectorAll","currentElement","dropzones","fireActiveDrops","prevElement","activeDrops","setActiveDrops","dragElement","possibleDrops","rects","getDrop","dragEvent","validDrops","dynamicDrop","j","rect","dropCheck","dropIndex","indexOfDeepestElement","dropzone","getDropEvents","pointerEvent","dropEvents","enter","leave","activate","deactivate","tmpl","dropElement","dropTarget","prevDropElement","prevDropTarget","dragLeave","prevDropzone","dragEnter","dragmove","fireDropEvents","draggableElement","dropResult","_ref4","_ref5","_ref6","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","isNumber","max","min","dropped","dropOverlap","getPageXY","horizontal","vertical","top","bottom","dragRect","cx","width","cy","height","overlapArea","overlapRatio","_ref7","_ref8","../interact","../scope","8","gesture","ds","startDistance","prevDistance","distance","startAngle","prevAngle","scale","Infinity","isNaN","gesturable","ongesturestart","ongestureend","touches","touchDistance","box","touchBBox","touchAngle","da","prevScale","9","firePrepared","newEvent","10","checkResizeEdge","interactableElement","margin","matchesUpTo","defaultMargin","resize","square","preserveAspectRatio","NaN","invert","resizeOptions","resizeEdges","edge","axes","cursors","isIe9OrOlder","xy","topleft","bottomright","topright","bottomleft","cursorKey","edgeNames","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","inverted","previous","delta","deltaRect","invertible","originalEdges","startAspectRatio","swap","resizable","onresizestart","onresizeend","resizeAxes","../utils/browser","11","raf","isWindow","domUtils","container","isScrolling","prevTime","request","scroll","now","scrollBy","scrollLeft","scrollTop","check","onInteractionMove","innerWidth","innerHeight","getElementClientRect","./Interaction","./utils/raf","./utils/window","12","getAction","defaultActionChecker","actionChecker","ignoreFrom","allowFrom","testIgnore","testAllow","testIgnoreAllow","styleCursor","../actions","../utils/domUtils","../utils/isType","13","autoStart","delayTimer","delay","setTimeout","clearTimeout","14","checkStartAxis","thisAxis","parentNode","setActionDefaults","absX","absY","currentAxis","getDraggable","selector","useMatchesSelectorPolyfill","manualStart","_action","validateAction","elementInteractable","selectorInteractable","../actions/drag","15","../actions/gesture","16","withinInteractionLimit","validateSelector","matchElements","match","matchElement","getActionInfo","pushMatches","actionInfo","prepare","documentElement","style","cursor","maxActions","maxPerElement","activeInteractions","targetCount","targetElementCount","maxInteractions","otherAction","arg","0","../utils/Signals","./InteractableMethods","17","../actions/resize","18","resistance","minSpeed","endSpeed","allowResume","smoothEndDuration","19","./actions/drag","./actions/drop","./actions/gesture","./actions/resize","./autoScroll","./autoStart/delay","./autoStart/drag","./autoStart/gesture","./autoStart/resize","./inertia","./interact","./interactablePreventDefault.js","./legacyBrowsers","./modifiers/restrict","./modifiers/restrictEdges","./modifiers/restrictSize","./modifiers/snap","./modifiers/snapSize","./pointerEvents","./pointerEvents/holdRepeat","./pointerEvents/interactableTargets","20","calcInertia","status","inertiaOptions","lambda","inertiaDur","log","v0","startEvent","sx","sy","modifiedXe","xe","vx0","modifiedYe","ye","vy0","te","lambda_v0","one_ve_v0","inertiaFrame","updateInertiaCoords","inertiaStatus","progress","exp","quadPoint","getQuadraticCurvePoint","animationFrame","boundInertiaFrame","active","smoothEndFrame","easeOutQuad","boundSmoothEndFrame","smoothEnd","pageUp","upCoords","clientUp","modifiers","vys","apply","resumeEvent","resetStatuses","modifierStatuses","statuses","pointerSpeed","inertiaPossible","modifierResult","modifierArg","preEnd","requireEndOnly","setAll","shouldMove","locked","./InteractEvent","./modifiers","21","globalEvents","isSet","debug","getPointerAverage","pointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","closest","removeDocument","./Interactable","22","onInteractionEvent","checkAndPreventDefault","_arr","eventSignal","dragstart","23","onIE8Dblclick","iFinder","prevTap","pointerEvents","collectEventTargets","toString","Object","obj","String","replace","isIE8","selectFix","onDocIE8","24","shouldDo","endOnly","setOffsets","pageCoords","startOffset","modifierName","modifierOffsets","setOffset","result","changed","modifier","offset","_status","modifiedX","modifiedY","modifyCoords","../utils/extend","25","restriction","elementRect","useStatusXY","26","getRestrictionRect","getStringOptionResult","rectUtils","noMin","noMax","restrictEdges","xywhToTlbr","../utils/rect","27","restrictSize","minSize","tlbrToXywh","maxSize","./restrictEdges","28","range","targets","offsets","relativePoints","snapOffset","relativeX","relativeY","realX","realY","offsetX","offsetY","snapTarget","inRange","snapChanged","createSnapGrid","grid","limits","gridx","round","gridy","newX","newY","29","snapSize","../utils/","./snap","30","endHoldRepeat","holdIntervalHandle","clearInterval","count","interval","eventable","holdRepeatInterval","signal","types","./index.js","31","preventOriginalDefault","originalEvent","firePointers","createNewDoubleTap","pointerId","tapTime","props","_utils$getOriginXY","originX","originY","doubleTap","getPath","filter","holdDuration","createSignalListener","simpleSignals","simpleEvents","timeout","eventCopy","timers","timer","minDuration","forEach","../utils/arr","32","collectSelectors","els","__backCompatOption","33","documents","onWindowUnload","./utils/domObjects","34","Signals","targetListeners","./arr","35","array","source","36","domObjects","Element","navigator","DocumentTouch","isOperaMobile","appName","userAgent","isIOS7","platform","appVersion","prefixedMatchesSelector","MSPointerEvent","over","out","./domObjects","./isType","./window","37","blank","DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch","38","parent","child","node","isDocFrag","host","matchesSelectorPolyfill","elems","nodeList","realWindow","deepestZoneParents","dropzoneParents","deepestZone","unshift","ownerSVGElement","parents","lastChild","previousSibling","limit","correspondingUseElement","getScrollXY","relevantWindow","scrollX","scrollY","clientRect","getBoundingClientRect","getClientRects","_scroll","./browser","39","elementIndex","typeCount","attachedListeners","useAttachEvent","supplied","wrapped","useCount","_attachedListeners$elementIndex","listenerIndex","wrappedListener","srcElement","preventDef","stopProp","stopImmProp","addEvent","removeEvent","hasOwnProperty","matchFound","fn","useCap","fakeEvent","pExtend","returnValue","cancelBubble","_elements","_targets","_attachedListeners","./domUtils","./pointerExtend","40","dest","41","actionOptions","actionOrigin","42","sqrt","43","warnOnce","message","warned","console","warn","arguments","_getQBezierValue","p1","p2","p3","iT","startX","startY","cpX","cpY","endX","endY","position","b","c","d","src","./extend","./getOriginXY","./hypot","./pointerUtils","44","methodOrder","mouseEvent","details","simulationResume","firstNonActive","_iterator4","_isArray4","_i4","hasPointer","_ref9","_iterator5","_isArray5","_i5","idle","_ref10","_iterator6","_isArray6","_i6","45","_window","nodeType","nodeName","thing","./isWindow","46","Window","47","prefixedPropREs","deprecated","vendor","webkit","48","dom","pointerUtils","targetObj","prev","cur","isNativePointer","getXY","getClientXY","identifier","tmpXY","getTouchPair","average","screenX","screenY","minX","minY","maxX","maxY","sourceX","sourceY","49","vendors","lastTime","requestAnimationFrame","currTime","timeToCall","50","51","el","createTextNode","wrap","rootNode","defaultView","parentWindow"],"mappings":"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","file":"interact.min.js","sourcesContent":["/**\n * interact.js 1.3.0\n *\n * Copyright (c) 2012-2016 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n","/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n}\nelse {\n  module.exports = require('./src/index');\n}\n","/**\n * interact.js 1.3.0\n *\n * Copyright (c) 2012-2016 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n * In a (windowless) server environment this file exports a factory function\n * that takes the window to use.\n *\n *     var interact = require('interact.js')(windowObject);\n *\n * See https://github.com/taye/interact.js/issues/187\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n} else {\n  module.exports = require('./src/index');\n}\n\n},{\"./src/index\":19,\"./src/utils/window\":51}],2:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _require = require('./utils/arr');\n\nvar indexOf = _require.indexOf;\n\nvar extend = require('./utils/extend.js');\n\nfunction fireUntilImmediateStopped(event, listeners) {\n  for (var i = 0, len = listeners.length; i < len && !event.immediatePropagationStopped; i++) {\n    listeners[i](event);\n  }\n}\n\nvar Eventable = (function () {\n  function Eventable(options) {\n    _classCallCheck(this, Eventable);\n\n    this.options = extend({}, options || {});\n  }\n\n  Eventable.prototype.fire = function fire(event) {\n    var listeners = undefined;\n    var onEvent = 'on' + event.type;\n    var global = this.global;\n\n    // Interactable#on() listeners\n    if (listeners = this[event.type]) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n\n    // interactable.onevent listener\n    if (this[onEvent]) {\n      this[onEvent](event);\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n  };\n\n  Eventable.prototype.on = function on(eventType, listener) {\n    // if this type of event was never bound\n    if (this[eventType]) {\n      this[eventType].push(listener);\n    } else {\n      this[eventType] = [listener];\n    }\n  };\n\n  Eventable.prototype.off = function off(eventType, listener) {\n    // if it is an action event type\n    var eventList = this[eventType];\n    var index = eventList ? indexOf(eventList, listener) : -1;\n\n    if (index !== -1) {\n      eventList.splice(index, 1);\n    }\n\n    if (eventList && eventList.length === 0 || !listener) {\n      this[eventType] = listener;\n    }\n  };\n\n  return Eventable;\n})();\n\nmodule.exports = Eventable;\n\n},{\"./utils/arr\":35,\"./utils/extend.js\":40}],3:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar extend = require('./utils/extend');\nvar getOriginXY = require('./utils/getOriginXY');\nvar defaults = require('./defaultOptions');\nvar signals = require('./utils/Signals')['new']();\n\nvar InteractEvent = (function () {\n  function InteractEvent(interaction, event, action, phase, element, related) {\n    _classCallCheck(this, InteractEvent);\n\n    var target = interaction.target;\n    var deltaSource = (target && target.options || defaults).deltaSource;\n    var origin = getOriginXY(target, element, action);\n    var starting = phase === 'start';\n    var ending = phase === 'end';\n    var coords = starting ? interaction.startCoords : interaction.curCoords;\n    var prevEvent = interaction.prevEvent;\n\n    element = element || interaction.element;\n\n    var page = extend({}, coords.page);\n    var client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey = event.ctrlKey;\n    this.altKey = event.altKey;\n    this.shiftKey = event.shiftKey;\n    this.metaKey = event.metaKey;\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.target = element;\n    this.currentTarget = element;\n    this.relatedTarget = related || null;\n    this.type = action + (phase || '');\n    this.interaction = interaction;\n    this.interactable = target;\n\n    this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1] : prevEvent.t0;\n\n    var signalArg = {\n      interaction: interaction,\n      event: event,\n      action: action,\n      phase: phase,\n      element: element,\n      related: related,\n      page: page,\n      client: client,\n      coords: coords,\n      starting: starting,\n      ending: ending,\n      deltaSource: deltaSource,\n      iEvent: this\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    } else {\n      this.pageX = page.x;\n      this.pageY = page.y;\n      this.clientX = client.x;\n      this.clientY = client.y;\n    }\n\n    this.x0 = interaction.startCoords.page.x - origin.x;\n    this.y0 = interaction.startCoords.page.y - origin.y;\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n\n    this.timeStamp = coords.timeStamp;\n    this.dt = interaction.pointerDelta.timeStamp;\n    this.duration = this.timeStamp - this.t0;\n\n    // speed and velocity in pixels per second\n    this.speed = interaction.pointerDelta[deltaSource].speed;\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null;\n\n    signals.fire('new', signalArg);\n  }\n\n  InteractEvent.prototype.getSwipe = function getSwipe() {\n    var interaction = this.interaction;\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null;\n    }\n\n    var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n    var overlap = 22.5;\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    var left = 135 - overlap <= angle && angle < 225 + overlap;\n    var up = 225 - overlap <= angle && angle < 315 + overlap;\n\n    var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\n    var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\n    return {\n      up: up,\n      down: down,\n      left: left,\n      right: right,\n      angle: angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY\n      }\n    };\n  };\n\n  InteractEvent.prototype.preventDefault = function preventDefault() {};\n\n  InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  };\n\n  InteractEvent.prototype.stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n\n  return InteractEvent;\n})();\n\nsignals.on('set-delta', function (_ref) {\n  var iEvent = _ref.iEvent;\n  var interaction = _ref.interaction;\n  var starting = _ref.starting;\n  var deltaSource = _ref.deltaSource;\n\n  var prevEvent = starting ? iEvent : interaction.prevEvent;\n\n  if (deltaSource === 'client') {\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\n  } else {\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n\n},{\"./defaultOptions\":18,\"./utils/Signals\":34,\"./utils/extend\":40,\"./utils/getOriginXY\":41}],4:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar isType = require('./utils/isType');\nvar events = require('./utils/events');\nvar extend = require('./utils/extend');\nvar actions = require('./actions');\nvar scope = require('./scope');\nvar Eventable = require('./Eventable');\nvar defaults = require('./defaultOptions');\nvar signals = require('./utils/Signals')['new']();\n\nvar _require = require('./utils/domUtils');\n\nvar getElementRect = _require.getElementRect;\nvar nodeContains = _require.nodeContains;\n\nvar _require2 = require('./utils/arr');\n\nvar indexOf = _require2.indexOf;\nvar contains = _require2.contains;\n\nvar _require3 = require('./utils/browser');\n\nvar wheelEvent = _require3.wheelEvent;\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\n * Interactable\n [ property ]\n **\n * Object type returned by @interact\n\\*/\n\nvar Interactable = (function () {\n  function Interactable(target, options) {\n    _classCallCheck(this, Interactable);\n\n    options = options || {};\n\n    this.target = target;\n    this.events = new Eventable();\n    this._context = options.context || scope.document;\n    this._win = scope.getWindow(isType.trySelector(target) ? this._context : target);\n    this._doc = this._win.document;\n\n    signals.fire('new', {\n      target: target,\n      options: options,\n      interactable: this,\n      win: this._win\n    });\n\n    scope.addDocument(this._doc, this._win);\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\n    var onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)) {\n      this.events[onAction + 'start'] = phases.onstart;\n    }\n    if (isType.isFunction(phases.onmove)) {\n      this.events[onAction + 'move'] = phases.onmove;\n    }\n    if (isType.isFunction(phases.onend)) {\n      this.events[onAction + 'end'] = phases.onend;\n    }\n    if (isType.isFunction(phases.oninertiastart)) {\n      this.events[onAction + 'inertiastart'] = phases.oninertiastart;\n    }\n\n    return this;\n  };\n\n  Interactable.prototype.setPerAction = function setPerAction(action, options) {\n    // for all the default per-action options\n    for (var option in options) {\n      // if this option exists for this action\n      if (option in defaults[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false ? false : true;\n          }\n        } else if (isType.isBool(options[option]) && isType.isObject(defaults.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        } else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  };\n\n  /*\\\n   * Interactable.getRect\n   [ method ]\n   *\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using @Interactable.rectChecker.\n   *\n   - element (Element) #optional The element to measure.\n   = (object) The object's bounding rectangle.\n   o {\n   o     top   : 0,\n   o     left  : 0,\n   o     bottom: 0,\n   o     right : 0,\n   o     width : 0,\n   o     height: 0\n   o }\n  \\*/\n\n  Interactable.prototype.getRect = function getRect(element) {\n    element = element || this.target;\n\n    if (isType.isString(this.target) && !isType.isElement(element)) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  };\n\n  /*\\\n   * Interactable.rectChecker\n   [ method ]\n   *\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n   = (function | object) The checker function or this Interactable\n  \\*/\n\n  Interactable.prototype.rectChecker = function rectChecker(checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  };\n\n  Interactable.prototype._backCompatOption = function _backCompatOption(optionName, newValue) {\n    if (isType.trySelector(newValue) || isType.isObject(newValue)) {\n      this.options[optionName] = newValue;\n\n      for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var action = _ref;\n\n        this.options[action][optionName] = newValue;\n      }\n\n      return this;\n    }\n\n    return this.options[optionName];\n  };\n\n  /*\\\n   * Interactable.origin\n   [ method ]\n   *\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n   * OR\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\n   **\n   = (object) The current origin or this Interactable\n  \\*/\n\n  Interactable.prototype.origin = function origin(newValue) {\n    return this._backCompatOption('origin', newValue);\n  };\n\n  /*\\\n   * Interactable.deltaSource\n   [ method ]\n   *\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n   = (string | object) The current deltaSource or this Interactable\n  \\*/\n\n  Interactable.prototype.deltaSource = function deltaSource(newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  };\n\n  /*\\\n   * Interactable.context\n   [ method ]\n   *\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\n   *\n   = (Node) The context Node of this Interactable\n   **\n  \\*/\n\n  Interactable.prototype.context = function context() {\n    return this._context;\n  };\n\n  Interactable.prototype.inContext = function inContext(element) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element);\n  };\n\n  /*\\\n   * Interactable.fire\n   [ method ]\n   *\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n   = (Interactable) this Interactable\n  \\*/\n\n  Interactable.prototype.fire = function fire(iEvent) {\n    this.events.fire(iEvent);\n\n    return this;\n  };\n\n  Interactable.prototype._onOffMultiple = function _onOffMultiple(method, eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (var i = 0; i < eventType.length; i++) {\n        this[method](eventType[i], listener, useCapture);\n      }\n\n      return true;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (var prop in eventType) {\n        this[method](prop, eventType[prop], listener);\n      }\n\n      return true;\n    }\n  };\n\n  /*\\\n   * Interactable.on\n   [ method ]\n   *\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   - eventType  (string | array | object) The types of events to listen for\n   - listener   (function) The function event (s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.on = function on(eventType, listener, useCapture) {\n    // convert to boolean\n    useCapture = !!useCapture;\n\n    if (this._onOffMultiple('on', eventType, listener, useCapture)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = wheelEvent;\n    }\n\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.on(eventType, listener);\n    }\n    // delegated event for selector\n    else if (isType.isString(this.target)) {\n        events.addDelegate(this.target, this._context, eventType, listener, useCapture);\n      } else {\n        events.add(this.target, eventType, listener, useCapture);\n      }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.off\n   [ method ]\n   *\n   * Removes an InteractEvent, pointerEvent or DOM event listener\n   *\n   - eventType  (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.off = function off(eventType, listener, useCapture) {\n    // convert to boolean\n    useCapture = !!useCapture;\n\n    if (this._onOffMultiple('off', eventType, listener, useCapture)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = wheelEvent;\n    }\n\n    // if it is an action event type\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.off(eventType, listener);\n    }\n    // delegated event\n    else if (isType.isString(this.target)) {\n        events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\n      }\n      // remove listener from this Interatable's element\n      else {\n          events.remove(this.target, eventType, listener, useCapture);\n        }\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.set\n   [ method ]\n   *\n   * Reset the options of this Interactable\n   - options (object) The new settings to apply\n   = (object) This Interactable\n  \\*/\n\n  Interactable.prototype.set = function set(options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, defaults.base);\n\n    var perActions = extend({}, defaults.perAction);\n\n    for (var actionName in actions.methodDict) {\n      var methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, defaults[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (var _iterator2 = Interactable.settingsMethods, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var setting = _ref2;\n\n      this.options[setting] = defaults.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    signals.fire('set', {\n      options: options,\n      interactable: this\n    });\n\n    return this;\n  };\n\n  /*\\\n   * Interactable.unset\n   [ method ]\n   *\n   * Remove this interactable from the list of interactables and remove\n   * it's action capabilities and event listeners\n   *\n   = (object) @interact\n  \\*/\n\n  Interactable.prototype.unset = function unset() {\n    events.remove(this.target, 'all');\n\n    if (isType.isString(this.target)) {\n      // remove delegated events\n      for (var type in events.delegatedEvents) {\n        var delegated = events.delegatedEvents[type];\n\n        if (delegated.selectors[0] === this.target && delegated.contexts[0] === this._context) {\n\n          delegated.selectors.splice(0, 1);\n          delegated.contexts.splice(0, 1);\n          delegated.listeners.splice(0, 1);\n\n          // remove the arrays if they are empty\n          if (!delegated.selectors.length) {\n            delegated[type] = null;\n          }\n        }\n\n        events.remove(this._context, type, events.delegateListener);\n        events.remove(this._context, type, events.delegateUseCapture, true);\n      }\n    } else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\n\n    // Stop related interactions when an Interactable is unset\n    for (var _iterator3 = scope.interactions || [], _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var interaction = _ref3;\n\n      if (interaction.target === this && interaction.interacting()) {\n        interaction.stop();\n      }\n    }\n\n    return scope.interact;\n  };\n\n  return Interactable;\n})();\n\nscope.interactables.indexOfElement = function indexOfElement(target, context) {\n  context = context || scope.document;\n\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    if (interactable.target === target && (!isType.isString(target) || interactable._context === context)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet(element, options, dontCheckInContext) {\n  var ret = this[this.indexOfElement(element, options && options.context)];\n\n  return ret && (dontCheckInContext || ret.inContext(element)) ? ret : null;\n};\n\nscope.interactables.forEachSelector = function (callback, element) {\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    // skip non CSS selector targets and out of context elements\n    if (!isType.isString(interactable.target) || element && !interactable.inContext(element)) {\n      continue;\n    }\n\n    var ret = callback(interactable, interactable.target, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n// all interact.js eventTypes\nInteractable.eventTypes = scope.eventTypes = [];\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = ['deltaSource', 'origin', 'preventDefault', 'rectChecker'];\n\nmodule.exports = Interactable;\n\n},{\"./Eventable\":2,\"./actions\":9,\"./defaultOptions\":18,\"./scope\":33,\"./utils/Signals\":34,\"./utils/arr\":35,\"./utils/browser\":36,\"./utils/domUtils\":38,\"./utils/events\":39,\"./utils/extend\":40,\"./utils/isType\":45}],5:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar scope = require('./scope');\nvar utils = require('./utils');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\nvar finder = require('./utils/interactionFinder');\nvar signals = require('./utils/Signals')['new']();\n\nvar listeners = {};\nvar methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer'];\n\n// for ignoring browser's simulated mouse events\nvar prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nvar Interaction = (function () {\n  function Interaction() {\n    _classCallCheck(this, Interaction);\n\n    this.target = null; // current interactable being interacted with\n    this.element = null; // the target element of the interactable\n\n    this.prepared = { // action that's ready to be fired on next move event\n      name: null,\n      axis: null,\n      edges: null\n    };\n\n    // keep track of added pointers\n    this.pointers = [];\n    this.pointerIds = [];\n    this.downTargets = [];\n    this.downTimes = [];\n    this.holdTimers = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0\n    };\n\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null; // previous action event\n\n    this.pointerIsDown = false;\n    this.pointerWasMoved = false;\n    this._interacting = false;\n\n    this.mouse = false;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget) {\n    var pointerIndex = this.updatePointer(pointer);\n\n    this.pointerIsDown = true;\n\n    if (!this.interacting()) {\n      utils.setCoords(this.startCoords, this.pointers);\n\n      utils.copyCoords(this.curCoords, this.startCoords);\n      utils.copyCoords(this.prevCoords, this.startCoords);\n\n      this.downEvent = event;\n\n      this.downTimes[pointerIndex] = this.curCoords.timeStamp;\n      this.downTargets[pointerIndex] = eventTarget;\n\n      this.pointerWasMoved = false;\n\n      utils.pointerExtend(this.downPointer, pointer);\n    }\n\n    signals.fire('down', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      pointerIndex: pointerIndex,\n      interaction: this\n    });\n  };\n\n  /*\\\n   * Interaction.start\n   [ method ]\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate number\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   - action  (object)  The action to be performed - drag, resize, etc.\n   - target  (Interactable) The Interactable to target\n   - element (Element) The DOM Element to target\n   = (object) interact\n   **\n   | interact(target)\n   |   .draggable({\n   |     // disable the default drag start by down->move\n   |     manualStart: true\n   |   })\n   |   // start dragging after the user holds the pointer down\n   |   .on('hold', function (event) {\n   |     var interaction = event.interaction;\n   |\n   |     if (!interaction.interacting()) {\n   |       interaction.start({ name: 'drag' },\n   |                         event.interactable,\n   |                         event.currentTarget);\n   |     }\n   | });\n   \\*/\n\n  Interaction.prototype.start = function start(action, target, element) {\n    if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target = target;\n    this.element = element;\n\n    signals.fire('action-start', {\n      interaction: this,\n      event: this.downEvent\n    });\n  };\n\n  Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.updatePointer(pointer);\n      utils.setCoords(this.curCoords, this.pointers);\n    }\n\n    var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n\n    var dx = undefined;\n    var dy = undefined;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n    }\n\n    var signalArg = {\n      pointer: pointer,\n      pointerIndex: this.getPointerIndex(pointer),\n      event: event,\n      eventTarget: eventTarget,\n      dx: dx,\n      dy: dy,\n      duplicate: duplicateMove,\n      interaction: this,\n      interactingBeforeMove: this.interacting()\n    };\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n    }\n\n    signals.fire('move', signalArg);\n\n    if (!duplicateMove) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        this.doMove(signalArg);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n    }\n  };\n\n  /*\\\n   * Interaction.doMove\n   [ method ]\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   *\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('dragmove', function (event) {\n   |     if (someCondition) {\n   |       // change the snap settings\n   |       event.interactable.draggable({ snap: { targets: [] }});\n   |       // fire another move event with re-calculated snap\n   |       event.interaction.doMove();\n   |     }\n   |   });\n   \\*/\n\n  Interaction.prototype.doMove = function doMove(signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('action-move', signalArg);\n    }\n\n    this._dontFireMove = false;\n  };\n\n  // End interact move events and stop auto-scroll unless simulation is running\n\n  Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\n    var pointerIndex = this.getPointerIndex(pointer);\n\n    signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\n      pointer: pointer,\n      pointerIndex: pointerIndex,\n      event: event,\n      eventTarget: eventTarget,\n      curEventTarget: curEventTarget,\n      interaction: this\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n    }\n\n    this.pointerIsDown = false;\n    this.removePointer(pointer);\n  };\n\n  /*\\\n   * Interaction.end\n   [ method ]\n   *\n   * Stop the current action and fire an end event. Inertial movement does\n   * not happen.\n   *\n   - event (PointerEvent) #optional\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('move', function (event) {\n   |     if (event.pageX > 1000) {\n   |       // end the current action\n   |       event.interaction.end();\n   |       // stop all further listeners from being called\n   |       event.stopImmediatePropagation();\n   |     }\n   |   });\n   \\*/\n\n  Interaction.prototype.end = function end(event) {\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event: event,\n        interaction: this\n      });\n    }\n\n    this.stop();\n  };\n\n  Interaction.prototype.currentAction = function currentAction() {\n    return this._interacting ? this.prepared.name : null;\n  };\n\n  Interaction.prototype.interacting = function interacting() {\n    return this._interacting;\n  };\n\n  Interaction.prototype.stop = function stop() {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  };\n\n  Interaction.prototype.getPointerIndex = function getPointerIndex(pointer) {\n    return this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n  };\n\n  Interaction.prototype.updatePointer = function updatePointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.getPointerIndex(pointer);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  };\n\n  Interaction.prototype.removePointer = function removePointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      return;\n    }\n\n    this.pointers.splice(index, 1);\n    this.pointerIds.splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes.splice(index, 1);\n    this.holdTimers.splice(index, 1);\n  };\n\n  Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\n    this._eventTarget = target;\n    this._curEventTarget = currentTarget;\n  };\n\n  return Interaction;\n})();\n\nfor (var i = 0, len = methodNames.length; i < len; i++) {\n  var method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions(method) {\n  return function (event) {\n    var eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    var curEventTarget = utils.getActualElement(event.currentTarget);\n    var matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (var i = 0; i < event.changedTouches.length; i++) {\n        var pointer = event.changedTouches[i];\n        var interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction()]);\n      }\n    } else {\n      var invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (var i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500;\n      }\n\n      if (!invalidPointer) {\n        var interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = /mouse/i.test(event.pointerType || event.type)\n          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n           || event.pointerType === 4 || !event.pointerType;\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref[0];\n      var interaction = _ref[1];\n\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  };\n}\n\nfunction endAll(event) {\n  for (var i = 0; i < scope.interactions.length; i++) {\n    var interaction = scope.interactions[i];\n\n    interaction.end(event);\n    signals.fire('endall', { event: event, interaction: interaction });\n  }\n}\n\nvar docEvents = {/* 'eventType': listenerFunc */};\nvar pEventTypes = browser.pEventTypes;\n\nif (scope.PointerEvent) {\n  docEvents[pEventTypes.down] = listeners.pointerDown;\n  docEvents[pEventTypes.move] = listeners.pointerMove;\n  docEvents[pEventTypes.up] = listeners.pointerUp;\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\n} else {\n  docEvents.mousedown = listeners.pointerDown;\n  docEvents.mousemove = listeners.pointerMove;\n  docEvents.mouseup = listeners.pointerUp;\n\n  docEvents.touchstart = listeners.pointerDown;\n  docEvents.touchmove = listeners.pointerMove;\n  docEvents.touchend = listeners.pointerUp;\n  docEvents.touchcancel = listeners.pointerUp;\n}\n\ndocEvents.blur = endAll;\n\nfunction onDocSignal(_ref2, signalName) {\n  var doc = _ref2.doc;\n\n  var eventMethod = signalName.indexOf('add') === 0 ? events.add : events.remove;\n\n  // delegate event listener\n  for (var eventType in scope.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener);\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  for (var eventType in docEvents) {\n    eventMethod(doc, eventType, docEvents[eventType]);\n  }\n}\n\nscope.signals.on('add-document', onDocSignal);\nscope.signals.on('remove-document', onDocSignal);\n\nInteraction.pointerMoveTolerance = 1;\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.endAll = endAll;\nInteraction.signals = signals;\nInteraction.docEvents = docEvents;\n\nscope.endAllInteractions = endAll;\n\nmodule.exports = Interaction;\n\n},{\"./scope\":33,\"./utils\":43,\"./utils/Signals\":34,\"./utils/browser\":36,\"./utils/events\":39,\"./utils/interactionFinder\":44}],6:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar drag = {\n  defaults: {\n    enabled: false,\n    mouseButtons: null,\n\n    origin: null,\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    startAxis: 'xy',\n    lockAxis: 'xy'\n  },\n\n  checker: function (pointer, event, interactable) {\n    var dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled ? { name: 'drag', axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis } : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  }\n};\n\nInteraction.signals.on('before-action-move', function (_ref) {\n  var interaction = _ref.interaction;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy = 0;\n  } else if (axis === 'y') {\n    interaction.curCoords.page.x = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx = 0;\n  }\n});\n\n// dragmove\nInteractEvent.signals.on('new', function (_ref2) {\n  var iEvent = _ref2.iEvent;\n  var interaction = _ref2.interaction;\n\n  if (iEvent.type !== 'dragmove') {\n    return;\n  }\n\n  var axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    iEvent.pageY = interaction.startCoords.page.y;\n    iEvent.clientY = interaction.startCoords.client.y;\n    iEvent.dy = 0;\n  } else if (axis === 'y') {\n    iEvent.pageX = interaction.startCoords.page.x;\n    iEvent.clientX = interaction.startCoords.client.x;\n    iEvent.dx = 0;\n  }\n});\n\n/*\\\n * Interactable.draggable\n [ method ]\n *\n * Gets or sets whether drag actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of drag events\n | var isDraggable = interact('ul li').draggable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n = (object) This Interactable\n | interact(element).draggable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // the axis in which the first movement must be\n |     // for the drag sequence to start\n |     // 'xy' by default - any direction\n |     startAxis: 'x' || 'y' || 'xy',\n |\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\n |     // 'x' or 'y' to restrict movement to either axis\n |     // 'start' to restrict movement to the axis the drag started in\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\n |\n |     // max number of drags that can happen concurrently\n |     // with elements of this Interactable. Infinity by default\n |     max: Infinity,\n |\n |     // max number of drags that can target the same element+Interactable\n |     // 1 by default\n |     maxPerElement: 2\n | });\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false ? false : true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    if (!options) {\n      this.ondragstart = this.ondragstart = this.ondragend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(Interactable.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'draginertiaresume', 'dragend']);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":43,\"./index\":9}],7:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar scope = require('../scope');\nvar interact = require('../interact');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar drop = {\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer'\n  }\n};\n\nvar dynamicDrop = false;\n\nInteraction.signals.on('action-start', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements = [];\n  interaction.activeDrops.rects = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction, interaction.element);\n  }\n\n  var dragEvent = interaction.prevEvent;\n  var dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var iEvent = _ref3.iEvent;\n  var event = _ref3.event;\n\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return;\n  }\n\n  var draggableElement = interaction.element;\n  var dragEvent = iEvent;\n  var dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('action-move', function (_ref4) {\n  var interaction = _ref4.interaction;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function (_ref6) {\n  var interaction = _ref6.interaction;\n\n  interaction.activeDrops.dropzones = interaction.activeDrops.elements = interaction.activeDrops.rects = interaction.dropEvents = null;\n});\n\nfunction collectDrops(interaction, element) {\n  var drops = [];\n  var elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var _iterator = scope.interactables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var current = _ref;\n\n    if (!current.options.drop.enabled) {\n      continue;\n    }\n\n    var accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if (utils.isElement(accept) && accept !== element || utils.isString(accept) && !utils.matchesSelector(element, accept)) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    var dropElements = utils.isString(current.target) ? current._context.querySelectorAll(current.target) : [current.target];\n\n    for (var i = 0; i < dropElements.length; i++) {\n      var currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements: elements,\n    dropzones: drops\n  };\n}\n\nfunction fireActiveDrops(interaction, event) {\n  var prevElement = undefined;\n\n  // loop through all active dropzones and trigger event\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    var current = interaction.activeDrops.dropzones[i];\n    var currentElement = interaction.activeDrops.elements[i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops(interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  var possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements = possibleDrops.elements;\n  interaction.activeDrops.rects = [];\n\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] = interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop(dragEvent, event, dragElement) {\n  var interaction = dragEvent.interaction;\n  var validDrops = [];\n\n  if (dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    var current = interaction.activeDrops.dropzones[j];\n    var currentElement = interaction.activeDrops.elements[j];\n    var rect = interaction.activeDrops.rects[j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  var dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element: interaction.activeDrops.elements[dropIndex] || null\n  };\n}\n\nfunction getDropEvents(interaction, pointerEvent, dragEvent) {\n  var dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null\n  };\n\n  var tmpl = {\n    dragEvent: dragEvent,\n    interaction: interaction,\n    target: interaction.dropElement,\n    dropzone: interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable: dragEvent.interactable,\n    timeStamp: dragEvent.timeStamp\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave = dropEvents.leave.target = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent: dragEvent,\n        interaction: interaction,\n        target: interaction.dropElement,\n        dropzone: interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable: dragEvent.interactable,\n        timeStamp: dragEvent.timeStamp,\n        type: 'dragenter'\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n    dragEvent.relatedTarget = interaction.dropElement;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove: dragEvent,\n      type: 'dropmove'\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents(interaction, dropEvents) {\n  if (dropEvents.leave) {\n    interaction.prevDropTarget.fire(dropEvents.leave);\n  }\n  if (dropEvents.move) {\n    interaction.dropTarget.fire(dropEvents.move);\n  }\n  if (dropEvents.enter) {\n    interaction.dropTarget.fire(dropEvents.enter);\n  }\n  if (dropEvents.drop) {\n    interaction.dropTarget.fire(dropEvents.drop);\n  }\n  if (dropEvents.move) {\n    interaction.dropTarget.fire(dropEvents.move);\n  }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(interaction, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget = interaction.dropTarget;\n  interaction.prevDropElement = interaction.dropElement;\n}\n\n/*\\\n * Interactable.dropzone\n [ method ]\n *\n * Returns or sets whether elements can be dropped onto this\n * Interactable to trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged\n * element is over this Interactable.\n *\n | interact(target)\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\n |                       dropped,           // bool result of the default checker\n |                       dropzone,          // dropzone Interactable\n |                       dropElement,       // dropzone elemnt\n |                       draggable,         // draggable Interactable\n |                       draggableElement) {// draggable element\n |\n |   return dropped && event.target.hasAttribute('allow-drop');\n | }\n *\n *\n - options (boolean | object | null) #optional The new value to be set.\n | interact('.drop').dropzone({\n |   accept: '.can-drop' || document.getElementById('single-drop'),\n |   overlap: 'pointer' || 'center' || zeroToOne\n | }\n = (boolean | object) The current setting or this Interactable\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false ? false : true;\n\n    if (utils.isFunction(options.ondrop)) {\n      this.events.ondrop = options.ondrop;\n    }\n    if (utils.isFunction(options.ondropactivate)) {\n      this.events.ondropactivate = options.ondropactivate;\n    }\n    if (utils.isFunction(options.ondropdeactivate)) {\n      this.events.ondropdeactivate = options.ondropdeactivate;\n    }\n    if (utils.isFunction(options.ondragenter)) {\n      this.events.ondragenter = options.ondragenter;\n    }\n    if (utils.isFunction(options.ondragleave)) {\n      this.events.ondragleave = options.ondragleave;\n    }\n    if (utils.isFunction(options.ondropmove)) {\n      this.events.ondropmove = options.ondropmove;\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    } else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    if (!options) {\n      this.ondragenter = this.ondragleave = this.ondrop = this.ondropactivate = this.ondropdeactivate = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  var dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n  }\n\n  var dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    var origin = utils.getOriginXY(draggable, draggableElement, 'drag');\n    var page = utils.getPageXY(dragEvent);\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    var horizontal = page.x > rect.left && page.x < rect.right;\n    var vertical = page.y > rect.top && page.y < rect.bottom;\n\n    dropped = horizontal && vertical;\n  }\n\n  var dragRect = draggable.getRect(draggableElement);\n\n  if (dragRect && dropOverlap === 'center') {\n    var cx = dragRect.left + dragRect.width / 2;\n    var cy = dragRect.top + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (dragRect && utils.isNumber(dropOverlap)) {\n    var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\n\n    var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function (_ref7) {\n  var interactable = _ref7.interactable;\n\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement = null; // the element at the time of checking\n  interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [], // the dropzones that are mentioned below\n    elements: [], // elements of dropzones that accept the target draggable\n    rects: [] };\n});\n\n// the rects of the elements mentioned above\nInteraction.signals.on('stop', function (_ref8) {\n  var interaction = _ref8.interaction;\n\n  interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\n/*\\\n * interact.dynamicDrop\n [ method ]\n *\n * Returns or sets whether the dimensions of dropzone elements are\n * calculated on every dragmove or only on dragstart for the default\n * dropChecker\n *\n - newValue (boolean) #optional True to check on each move. False to check only before start\n = (boolean | interact) The current setting or interact\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n    //calcRects(dropzones);\n    //}\n\n    dynamicDrop = newValue;\n\n    return interact;\n  }\n  return dynamicDrop;\n};\n\nutils.merge(Interactable.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../interact\":21,\"../scope\":33,\"../utils\":43,\"./index\":9}],8:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar gesture = {\n  defaults: {\n    enabled: false,\n    origin: null,\n    restrict: null\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  }\n};\n\nInteractEvent.signals.on('new', function (_ref) {\n  var iEvent = _ref.iEvent;\n  var interaction = _ref.interaction;\n\n  if (iEvent.type !== 'gesturestart') {\n    return;\n  }\n  iEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.scale = 1;\n});\n\nInteractEvent.signals.on('new', function (_ref2) {\n  var iEvent = _ref2.iEvent;\n  var interaction = _ref2.interaction;\n\n  if (iEvent.type !== 'gesturemove') {\n    return;\n  }\n\n  iEvent.ds = iEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(iEvent);\n\n  interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.prevDistance = iEvent.distance;\n\n  if (iEvent.scale !== Infinity && iEvent.scale !== null && iEvent.scale !== undefined && !isNaN(iEvent.scale)) {\n\n    interaction.gesture.scale = iEvent.scale;\n  }\n});\n\n/*\\\n * Interactable.gesturable\n [ method ]\n *\n * Gets or sets whether multitouch gestures can be performed on the\n * Interactable's element\n *\n = (boolean) Indicates if this can be the target of gesture events\n   | var isGestureable = interact(element).gesturable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n = (object) this Interactable\n | interact(element).gesturable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // limit multiple gestures.\n |     // See the explanation in @Interactable.draggable example\n |     max: Infinity,\n |     maxPerElement: 1,\n | });\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false ? false : true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    if (!options) {\n      this.ongesturestart = this.ongesturestart = this.ongestureend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('set-delta', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var iEvent = _ref3.iEvent;\n  var action = _ref3.action;\n  var event = _ref3.event;\n  var starting = _ref3.starting;\n  var ending = _ref3.ending;\n  var deltaSource = _ref3.deltaSource;\n\n  if (action !== 'gesture') {\n    return;\n  }\n\n  var pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = 1;\n    iEvent.ds = 0;\n    iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da = 0;\n  } else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box = interaction.prevEvent.box;\n    iEvent.scale = interaction.prevEvent.scale;\n    iEvent.ds = iEvent.scale - 1;\n    iEvent.angle = interaction.prevEvent.angle;\n    iEvent.da = iEvent.angle - interaction.gesture.startAngle;\n  } else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0, // distance between two touches of touchStart\n    prevDistance: 0,\n    distance: 0,\n\n    scale: 1, // gesture.distance / gesture.startDistance\n\n    startAngle: 0, // angle of line joining two touches\n    prevAngle: 0 };\n});\n\n// angle of the previous gesture event\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(Interactable.eventTypes, ['gesturestart', 'gesturemove', 'gestureend']);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":43,\"./index\":9}],9:[function(require,module,exports){\nvar Interaction = require('../Interaction');\nvar InteractEvent = require('../InteractEvent');\n\nvar actions = {\n  firePrepared: firePrepared,\n  names: [],\n  methodDict: {}\n};\n\nInteraction.signals.on('action-start', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  firePrepared(interaction, event, 'start');\n  interaction._interacting = true;\n});\n\nInteraction.signals.on('action-move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  firePrepared(interaction, event, 'move');\n\n  // if the action was ended in a listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  firePrepared(interaction, event, 'end');\n});\n\nfunction firePrepared(interaction, event, phase) {\n  var actionName = interaction.prepared.name;\n\n  var newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element);\n\n  interaction.target.fire(newEvent);\n  interaction.prevEvent = newEvent;\n}\n\nmodule.exports = actions;\n\n},{\"../InteractEvent\":3,\"../Interaction\":5}],10:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\n// Less Precision with touch input\nvar defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\n\nvar resize = {\n  defaults: {\n    enabled: false,\n    mouseButtons: null,\n\n    origin: null,\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none'\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) {\n      return null;\n    }\n\n    var page = utils.extend({}, interaction.curCoords.page);\n    var options = interactable.options;\n\n    if (options.resize.enabled) {\n      var resizeOptions = options.resize;\n      var resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || defaultMargin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges\n          };\n        }\n      } else {\n        var right = options.resize.axis !== 'y' && page.x > rect.right - defaultMargin;\n        var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - defaultMargin;\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right ? 'x' : '') + (bottom ? 'y' : '')\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: browser.isIe9OrOlder ? {\n    x: 'e-resize',\n    y: 's-resize',\n    xy: 'se-resize',\n\n    top: 'n-resize',\n    left: 'w-resize',\n    bottom: 's-resize',\n    right: 'e-resize',\n    topleft: 'se-resize',\n    bottomright: 'se-resize',\n    topright: 'ne-resize',\n    bottomleft: 'ne-resize'\n  } : {\n    x: 'ew-resize',\n    y: 'ns-resize',\n    xy: 'nwse-resize',\n\n    top: 'ns-resize',\n    left: 'ew-resize',\n    bottom: 'ns-resize',\n    right: 'ew-resize',\n    topleft: 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright: 'nesw-resize',\n    bottomleft: 'nesw-resize'\n  },\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    } else if (action.edges) {\n      var cursorKey = '';\n      var edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (var i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  }\n};\n\n// resizestart\nInteractEvent.signals.on('new', function (_ref) {\n  var iEvent = _ref.iEvent;\n  var interaction = _ref.interaction;\n\n  if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\n    return;\n  }\n\n  var startRect = interaction.target.getRect(interaction.element);\n  var resizeOptions = interaction.target.options.resize;\n\n  /*\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n   * on the active edges and the edge being interacted with.\n   */\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n    var linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n    linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n    linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n    linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n    linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n\n    interaction.prepared._linkedEdges = linkedEdges;\n  } else {\n    interaction.prepared._linkedEdges = null;\n  }\n\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n  if (resizeOptions.preserveAspectRatio) {\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n  }\n\n  interaction.resizeRects = {\n    start: startRect,\n    current: utils.extend({}, startRect),\n    inverted: utils.extend({}, startRect),\n    previous: utils.extend({}, startRect),\n    delta: {\n      left: 0, right: 0, width: 0,\n      top: 0, bottom: 0, height: 0\n    }\n  };\n\n  iEvent.rect = interaction.resizeRects.inverted;\n  iEvent.deltaRect = interaction.resizeRects.delta;\n});\n\n// resizemove\nInteractEvent.signals.on('new', function (_ref2) {\n  var iEvent = _ref2.iEvent;\n  var phase = _ref2.phase;\n  var interaction = _ref2.interaction;\n\n  if (phase !== 'move' || !interaction.prepared.edges) {\n    return;\n  }\n\n  var resizeOptions = interaction.target.options.resize;\n  var invert = resizeOptions.invert;\n  var invertible = invert === 'reposition' || invert === 'negate';\n\n  var edges = interaction.prepared.edges;\n\n  var start = interaction.resizeRects.start;\n  var current = interaction.resizeRects.current;\n  var inverted = interaction.resizeRects.inverted;\n  var delta = interaction.resizeRects.delta;\n  var previous = utils.extend(interaction.resizeRects.previous, inverted);\n  var originalEdges = edges;\n\n  var dx = iEvent.dx;\n  var dy = iEvent.dy;\n\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\n    var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;\n\n    edges = interaction.prepared._linkedEdges;\n\n    if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n      dy = -dx / startAspectRatio;\n    } else if (originalEdges.left || originalEdges.right) {\n      dy = dx / startAspectRatio;\n    } else if (originalEdges.top || originalEdges.bottom) {\n      dx = dy * startAspectRatio;\n    }\n  }\n\n  // update the 'current' rect without modifications\n  if (edges.top) {\n    current.top += dy;\n  }\n  if (edges.bottom) {\n    current.bottom += dy;\n  }\n  if (edges.left) {\n    current.left += dx;\n  }\n  if (edges.right) {\n    current.right += dx;\n  }\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    utils.extend(inverted, current);\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      var swap = undefined;\n\n      if (inverted.top > inverted.bottom) {\n        swap = inverted.top;\n\n        inverted.top = inverted.bottom;\n        inverted.bottom = swap;\n      }\n      if (inverted.left > inverted.right) {\n        swap = inverted.left;\n\n        inverted.left = inverted.right;\n        inverted.right = swap;\n      }\n    }\n  } else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    inverted.top = Math.min(current.top, start.bottom);\n    inverted.bottom = Math.max(current.bottom, start.top);\n    inverted.left = Math.min(current.left, start.right);\n    inverted.right = Math.max(current.right, start.left);\n  }\n\n  inverted.width = inverted.right - inverted.left;\n  inverted.height = inverted.bottom - inverted.top;\n\n  for (var edge in inverted) {\n    delta[edge] = inverted[edge] - previous[edge];\n  }\n\n  iEvent.edges = interaction.prepared.edges;\n  iEvent.rect = inverted;\n  iEvent.deltaRect = delta;\n});\n\n/*\\\n * Interactable.resizable\n [ method ]\n *\n * Gets or sets whether resize actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of resize elements\n   | var isResizeable = interact('input[type=text]').resizable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n = (object) This Interactable\n   | interact(element).resizable({\n   |   onstart: function (event) {},\n   |   onmove : function (event) {},\n   |   onend  : function (event) {},\n   |\n   |   edges: {\n   |     top   : true,       // Use pointer coords to check for resize.\n   |     left  : false,      // Disable resizing from left edge.\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\n   |     right : handleEl    // Resize if pointer target is the given Element\n   |   },\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height are adjusted at a 1:1 ratio.\n   |     square: false,\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height maintain the aspect ratio they had when resizing started.\n   |     preserveAspectRatio: false,\n   |\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   |   // 'negate' will allow the rect to have negative width/height\n   |   // 'reposition' will keep the width/height positive by swapping\n   |   // the top and bottom edges and/or swapping the left and right edges\n   |   invert: 'none' || 'negate' || 'reposition'\n   |\n   |   // limit multiple resizes.\n   |   // See the explanation in the @Interactable.draggable example\n   |   max: Infinity,\n   |   maxPerElement: 1,\n   | });\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false ? false : true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    } else if (options.axis === null) {\n      this.options.resize.axis = defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    } else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    if (!options) {\n      this.onresizestart = this.onresizestart = this.onresizeend = null;\n    }\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) {\n    return false;\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    var width = utils.isNumber(rect.width) ? rect.width : rect.right - rect.left;\n    var height = utils.isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right';\n      } else if (name === 'right') {\n        name = 'left';\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom';\n      } else if (name === 'bottom') {\n        name = 'top';\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n    }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n  ? value === element\n  // otherwise check if element matches value as selector\n  : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('set-delta', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var iEvent = _ref3.iEvent;\n  var action = _ref3.action;\n\n  if (action !== 'resize' || !interaction.resizeAxes) {\n    return;\n  }\n\n  var options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    } else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  } else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    } else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(Interactable.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeinertiaresume', 'resizeend']);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":18,\"../utils\":43,\"../utils/browser\":36,\"./index\":9}],11:[function(require,module,exports){\nvar raf = require('./utils/raf');\nvar getWindow = require('./utils/window').getWindow;\nvar isWindow = require('./utils/isType').isWindow;\nvar domUtils = require('./utils/domUtils');\nvar Interaction = require('./Interaction');\nvar defaultOptions = require('./defaultOptions');\n\nvar autoScroll = {\n  defaults: {\n    enabled: false,\n    container: null, // the item that is scrolled (Window or HTMLElement)\n    margin: 60,\n    speed: 300 },\n\n  // the scroll speed in pixels per second\n  interaction: null,\n  i: null, // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(autoScroll.interaction.element);\n    var now = new Date().getTime();\n    // change in time in seconds\n    var dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    var s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      } else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    var options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function (_ref) {\n    var interaction = _ref.interaction;\n    var pointer = _ref.pointer;\n\n    if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    var top = undefined;\n    var right = undefined;\n    var bottom = undefined;\n    var left = undefined;\n\n    var options = interaction.target.options[interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left = pointer.clientX < autoScroll.margin;\n      top = pointer.clientY < autoScroll.margin;\n      right = pointer.clientX > container.innerWidth - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    } else {\n      var rect = domUtils.getElementClientRect(container);\n\n      left = pointer.clientX < rect.left + autoScroll.margin;\n      top = pointer.clientY < rect.top + autoScroll.margin;\n      right = pointer.clientX > rect.right - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0;\n    autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  }\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n\n},{\"./Interaction\":5,\"./defaultOptions\":18,\"./utils/domUtils\":38,\"./utils/isType\":45,\"./utils/raf\":49,\"./utils/window\":51}],12:[function(require,module,exports){\nvar Interactable = require('../Interactable');\nvar actions = require('../actions');\nvar isType = require('../utils/isType');\nvar domUtils = require('../utils/domUtils');\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  var action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\n * Interactable.ignoreFrom\n [ method ]\n *\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\n * event or any of it's parents match the given CSS selector or\n * Element, no drag/resize/gesture is started.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n = (string | Element | object) The current ignoreFrom value or this Interactable\n **\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\n | // or\n | interact(element).ignoreFrom('input, textarea, a');\n\\*/\nInteractable.prototype.ignoreFrom = function (newValue) {\n  return this._backCompatOption('ignoreFrom', newValue);\n};\n\n/*\\\n * Interactable.allowFrom\n [ method ]\n *\n * A drag/resize/gesture is started only If the target of the\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n * parents match the given CSS selector or Element.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n = (string | Element | object) The current allowFrom value or this Interactable\n **\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\n | // or\n | interact(element).allowFrom('.handle');\n\\*/\nInteractable.prototype.allowFrom = function (newValue) {\n  return this._backCompatOption('allowFrom', newValue);\n};\n\nInteractable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\n  if (!ignoreFrom || !isType.isElement(element)) {\n    return false;\n  }\n\n  if (isType.isString(ignoreFrom)) {\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\n  } else if (isType.isElement(ignoreFrom)) {\n    return domUtils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testAllow = function (allowFrom, interactableElement, element) {\n  if (!allowFrom) {\n    return true;\n  }\n\n  if (!isType.isElement(element)) {\n    return false;\n  }\n\n  if (isType.isString(allowFrom)) {\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement);\n  } else if (isType.isElement(allowFrom)) {\n    return domUtils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\n  return !this.testIgnore(options.ignoreFrom, interactableElement, eventTarget) && this.testAllow(options.allowFrom, interactableElement, eventTarget);\n};\n\n/*\\\n * Interactable.actionChecker\n [ method ]\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n = (Function | Interactable) The checker function or this Interactable\n *\n | interact('.resize-drag')\n |   .resizable(true)\n |   .draggable(true)\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n |\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\n |     // force drag with handle target\n |     action.name = drag;\n |   }\n |   else {\n |     // resize from the top and right edges\n |     action.name  = 'resize';\n |     action.edges = { top: true, right: true };\n |   }\n |\n |   return action;\n | });\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (isType.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\n * Interactable.styleCursor\n [ method ]\n *\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n - newValue (boolean) #optional\n = (boolean | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (isType.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  var rect = this.getRect(element);\n  var action = null;\n\n  for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var actionName = _ref;\n\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown && interaction.mouse && (event.buttons & this.options[actionName].mouseButtons) === 0) {\n      continue;\n    }\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\n},{\"../Interactable\":4,\"../actions\":9,\"../utils/domUtils\":38,\"../utils/isType\":45}],13:[function(require,module,exports){\nvar autoStart = require('./index');\nvar Interaction = require('../Interaction');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.delayTimer = null;\n});\n\nautoStart.signals.on('prepared', function (_ref) {\n  var interaction = _ref.interaction;\n\n  var actionName = interaction.prepared.name;\n\n  if (!actionName) {\n    return;\n  }\n\n  var delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.delayTimer = setTimeout(function () {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, delay);\n  }\n});\n\nInteraction.signals.on('move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var duplicate = _ref2.duplicate;\n\n  if (interaction.pointerWasMoved && !duplicate) {\n    clearTimeout(interaction.delayTimer);\n  }\n});\n\n// prevent regular down->move autoStart\nautoStart.signals.on('before-start', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  var actionName = interaction.prepared.name;\n\n  if (!actionName) {\n    return;\n  }\n\n  var delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.prepared.name = null;\n  }\n});\n\n},{\"../Interaction\":5,\"./index\":16}],14:[function(require,module,exports){\nvar autoStart = require('./index');\nvar scope = require('../scope');\nvar browser = require('../utils/browser');\n\nvar _require = require('../utils/isType');\n\nvar isElement = _require.isElement;\n\nvar _require2 = require('../utils/domUtils');\n\nvar matchesSelector = _require2.matchesSelector;\nvar parentNode = _require2.parentNode;\n\nrequire('./index').setActionDefaults(require('../actions/drag'));\n\nautoStart.signals.on('before-start', function (_ref) {\n  var interaction = _ref.interaction;\n  var eventTarget = _ref.eventTarget;\n  var dx = _ref.dx;\n  var dy = _ref.dy;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  // check if a drag is in the correct axis\n  var absX = Math.abs(dx);\n  var absY = Math.abs(dy);\n  var options = interaction.target.options.drag;\n  var startAxis = options.startAxis;\n  var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\n  interaction.prepared.axis = options.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n  : options.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n\n    if (!interaction.prepared.name) {\n      (function () {\n\n        var element = eventTarget;\n\n        var getDraggable = function (interactable, selector, context) {\n          var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n          if (interactable === interaction.target) {\n            return;\n          }\n\n          if (!options.manualStart && !interactable.testIgnoreAllow(options, element, eventTarget) && matchesSelector(element, selector, elements)) {\n\n            var _action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n\n            if (_action && _action.name === 'drag' && checkStartAxis(currentAxis, interactable) && autoStart.validateAction(_action, interactable, element, eventTarget)) {\n\n              return interactable;\n            }\n          }\n        };\n\n        var action = null;\n\n        // check all interactables\n        while (isElement(element)) {\n          var elementInteractable = scope.interactables.get(element);\n\n          if (elementInteractable && elementInteractable !== interaction.target && !elementInteractable.options.drag.manualStart) {\n\n            action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n          }\n          if (action && action.name === 'drag' && checkStartAxis(currentAxis, elementInteractable)) {\n\n            interaction.prepared.name = 'drag';\n            interaction.target = elementInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          var selectorInteractable = scope.interactables.forEachSelector(getDraggable, element);\n\n          if (selectorInteractable) {\n            interaction.prepared.name = 'drag';\n            interaction.target = selectorInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          element = parentNode(element);\n        }\n      })();\n    }\n  }\n});\n\nfunction checkStartAxis(startAxis, interactable) {\n  if (!interactable) {\n    return false;\n  }\n\n  var thisAxis = interactable.options.drag.startAxis;\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;\n}\n\n},{\"../actions/drag\":6,\"../scope\":33,\"../utils/browser\":36,\"../utils/domUtils\":38,\"../utils/isType\":45,\"./index\":16}],15:[function(require,module,exports){\nrequire('./index').setActionDefaults(require('../actions/gesture'));\n\n},{\"../actions/gesture\":8,\"./index\":16}],16:[function(require,module,exports){\nvar interact = require('../interact');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar actions = require('../actions');\nvar defaultOptions = require('../defaultOptions');\nvar browser = require('../utils/browser');\nvar scope = require('../scope');\nvar utils = require('../utils');\nvar signals = require('../utils/Signals')['new']();\n\nrequire('./InteractableMethods');\n\nvar autoStart = {\n  signals: signals,\n  withinInteractionLimit: withinInteractionLimit,\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: Infinity,\n  defaults: {\n    perAction: {\n      manualStart: false,\n      max: Infinity,\n      maxPerElement: 1,\n      allowFrom: null,\n      ignoreFrom: null\n    }\n  },\n  setActionDefaults: function (action) {\n    utils.extend(action.defaults, autoStart.defaults.perAction);\n  }\n};\n\n// set cursor style on mousedown\nInteraction.signals.on('down', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointer = _ref2.pointer;\n  var event = _ref2.event;\n  var eventTarget = _ref2.eventTarget;\n\n  if (interaction.interacting()) {\n    return;\n  }\n\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\n// set cursor style on mousemove\nInteraction.signals.on('move', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var pointer = _ref3.pointer;\n  var event = _ref3.event;\n  var eventTarget = _ref3.eventTarget;\n\n  if (!interaction.mouse || interaction.pointerIsDown || interaction.interacting()) {\n    return;\n  }\n\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  var interaction = arg.interaction;\n  var event = arg.event;\n\n  if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {\n    return;\n  }\n\n  signals.fire('before-start', arg);\n\n  var target = interaction.target;\n\n  if (interaction.prepared.name && target) {\n    // check manualStart and interaction limit\n    if (target.options[interaction.prepared.name].manualStart || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n      interaction.stop(event);\n    } else {\n      interaction.start(interaction.prepared, target, interaction.element);\n    }\n  }\n});\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction(action, interactable, element, eventTarget) {\n  if (utils.isObject(action) && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action)) {\n    return action;\n  }\n\n  return null;\n}\n\nfunction validateSelector(interaction, pointer, event, matches, matchElements, eventTarget) {\n  for (var i = 0, len = matches.length; i < len; i++) {\n    var match = matches[i];\n    var matchElement = matchElements[i];\n    var action = validateAction(match.getAction(pointer, event, interaction, matchElement), match, matchElement, eventTarget);\n\n    if (action) {\n      return {\n        action: action,\n        target: match,\n        element: matchElement\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo(interaction, pointer, event, eventTarget) {\n  var matches = [];\n  var matchElements = [];\n\n  var element = eventTarget;\n  var action = null;\n\n  function pushMatches(interactable, selector, context) {\n    var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    if (utils.matchesSelector(element, selector, elements)) {\n\n      matches.push(interactable);\n      matchElements.push(element);\n    }\n  }\n\n  while (utils.isElement(element)) {\n    matches = [];\n    matchElements = [];\n\n    var elementInteractable = scope.interactables.get(element);\n\n    if (elementInteractable && (action = validateAction(elementInteractable.getAction(pointer, event, interaction, element, eventTarget), elementInteractable, element, eventTarget)) && !elementInteractable.options[action.name].manualStart) {\n      return {\n        element: element,\n        action: action,\n        target: elementInteractable\n      };\n    } else {\n      scope.interactables.forEachSelector(pushMatches, element);\n\n      var actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\n\n      if (actionInfo.action && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n        return actionInfo;\n      }\n    }\n\n    element = utils.parentNode(element);\n  }\n\n  return {};\n}\n\nfunction prepare(interaction, _ref4) {\n  var action = _ref4.action;\n  var target = _ref4.target;\n  var element = _ref4.element;\n\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    interaction.target._doc.documentElement.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    var cursor = action ? actions[action.name].getCursor(action) : '';\n    interaction.target._doc.documentElement.style.cursor = cursor;\n  }\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteraction.signals.on('stop', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  var target = interaction.target;\n\n  if (target && target.options.styleCursor) {\n    target._doc.documentElement.style.cursor = '';\n  }\n});\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  var action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\n * Interactable.actionChecker\n [ method ]\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n = (Function | Interactable) The checker function or this Interactable\n *\n | interact('.resize-drag')\n |   .resizable(true)\n |   .draggable(true)\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n |\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\n |     // force drag with handle target\n |     action.name = drag;\n |   }\n |   else {\n |     // resize from the top and right edges\n |     action.name  = 'resize';\n |     action.edges = { top: true, right: true };\n |   }\n |\n |   return action;\n | });\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (utils.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\n * Interactable.styleCursor\n [ method ]\n *\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n - newValue (boolean) #optional\n = (boolean | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (utils.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  var rect = this.getRect(element);\n  var buttons = event.buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16\n  })[event.button];\n  var action = null;\n\n  for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var actionName = _ref;\n\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown && interaction.mouse && (buttons & this.options[actionName].mouseButtons) === 0) {\n      continue;\n    }\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\nfunction withinInteractionLimit(interactable, element, action) {\n  var options = interactable.options;\n  var maxActions = options[action.name].max;\n  var maxPerElement = options[action.name].maxPerElement;\n  var activeInteractions = 0;\n  var targetCount = 0;\n  var targetElementCount = 0;\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) {\n    return;\n  }\n\n  for (var i = 0, len = scope.interactions.length; i < len; i++) {\n    var interaction = scope.interactions[i];\n    var otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) {\n      continue;\n    }\n\n    activeInteractions++;\n\n    if (activeInteractions >= autoStart.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) {\n      continue;\n    }\n\n    targetCount += otherAction === action.name | 0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return autoStart.maxInteractions > 0;\n}\n\n/*\\\n * interact.maxInteractions\n [ method ]\n **\n * Returns or sets the maximum number of concurrent interactions allowed.\n * By default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables\n * and elements, you need to enable it in the draggable, resizable and\n * gesturable `'max'` and `'maxPerElement'` options.\n **\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    autoStart.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return autoStart.maxInteractions;\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.styleCursor = true;\n\nutils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\n\nmodule.exports = autoStart;\n\n},{\"../Interactable\":4,\"../Interaction\":5,\"../actions\":9,\"../defaultOptions\":18,\"../interact\":21,\"../scope\":33,\"../utils\":43,\"../utils/Signals\":34,\"../utils/browser\":36,\"./InteractableMethods\":12}],17:[function(require,module,exports){\nrequire('./index').setActionDefaults(require('../actions/resize'));\n\n},{\"../actions/resize\":10,\"./index\":16}],18:[function(require,module,exports){\nmodule.exports = {\n  base: {\n    accept: null,\n    preventDefault: 'auto',\n    deltaSource: 'page'\n  },\n\n  perAction: {\n    origin: { x: 0, y: 0 },\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n\n    inertia: {\n      enabled: false,\n      resistance: 10, // the lambda in exponential decay\n      minSpeed: 100, // target speed must be above this for inertia to start\n      endSpeed: 10, // the speed at which inertia is slow enough to stop\n      allowResume: true, // allow resuming an action in inertia phase\n      smoothEndDuration: 300 }\n  }\n};\n// animate to snap/restrict endOnly if there's no inertia\n\n},{}],19:[function(require,module,exports){\n/* browser entry point */\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// pointerEvents\nrequire('./pointerEvents');\nrequire('./pointerEvents/holdRepeat');\nrequire('./pointerEvents/interactableTargets');\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// delay\nrequire('./autoStart/delay');\n\n// actions\nrequire('./actions/gesture');\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/drop');\n\n// load these modifiers after resize is loaded\nrequire('./modifiers/snapSize');\nrequire('./modifiers/restrictEdges');\nrequire('./modifiers/restrictSize');\n\n// autoStart actions\nrequire('./autoStart/gesture');\nrequire('./autoStart/resize');\nrequire('./autoStart/drag');\n\n// Interactable preventDefault setting\nrequire('./interactablePreventDefault.js');\n\n// autoScroll\nrequire('./autoScroll');\n\n// export interact\nmodule.exports = require('./interact');\n\n},{\"./actions/drag\":6,\"./actions/drop\":7,\"./actions/gesture\":8,\"./actions/resize\":10,\"./autoScroll\":11,\"./autoStart/delay\":13,\"./autoStart/drag\":14,\"./autoStart/gesture\":15,\"./autoStart/resize\":17,\"./inertia\":20,\"./interact\":21,\"./interactablePreventDefault.js\":22,\"./legacyBrowsers\":23,\"./modifiers/restrict\":25,\"./modifiers/restrictEdges\":26,\"./modifiers/restrictSize\":27,\"./modifiers/snap\":28,\"./modifiers/snapSize\":29,\"./pointerEvents\":31,\"./pointerEvents/holdRepeat\":30,\"./pointerEvents/interactableTargets\":32}],20:[function(require,module,exports){\nvar InteractEvent = require('./InteractEvent');\nvar Interaction = require('./Interaction');\nvar modifiers = require('./modifiers');\nvar utils = require('./utils');\nvar animationFrame = require('./utils/raf');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active: false,\n    smoothEnd: false,\n    allowResume: false,\n\n    startEvent: null,\n    upCoords: {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i: null\n  };\n\n  interaction.boundInertiaFrame = function () {\n    return inertiaFrame.apply(interaction);\n  };\n  interaction.boundSmoothEndFrame = function () {\n    return smoothEndFrame.apply(interaction);\n  };\n});\n\nInteraction.signals.on('down', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n  var pointer = _ref.pointer;\n  var eventTarget = _ref.eventTarget;\n\n  var status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    var element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.isElement(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n        // stop inertia\n        animationFrame.cancel(status.i);\n        status.active = false;\n        interaction.simulation = null;\n\n        // update pointers to the down event's coordinates\n        interaction.updatePointer(pointer);\n        utils.setCoords(interaction.curCoords, interaction.pointers);\n\n        // fire appropriate signals\n        var signalArg = { interaction: interaction };\n        Interaction.signals.fire('before-action-move', signalArg);\n        Interaction.signals.fire('action-resume', signalArg);\n\n        // fire a reume event\n        var resumeEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiaresume', interaction.element);\n\n        interaction.target.fire(resumeEvent);\n        interaction.prevEvent = resumeEvent;\n        modifiers.resetStatuses(interaction.modifierStatuses);\n\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n        break;\n      }\n\n      element = utils.parentNode(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  var status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) {\n    return;\n  }\n\n  var target = interaction.target;\n  var options = target && target.options;\n  var inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  var now = new Date().getTime();\n  var statuses = {};\n  var page = utils.extend({}, interaction.curCoords.page);\n  var pointerSpeed = interaction.pointerDelta.client.speed;\n  var inertiaPossible = false;\n  var inertia = false;\n  var smoothEnd = false;\n  var modifierResult = undefined;\n\n  // check if inertia should be started\n  inertiaPossible = inertiaOptions && inertiaOptions.enabled && interaction.prepared.name !== 'gesture' && event !== status.startEvent;\n\n  inertia = inertiaPossible && now - interaction.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\n  var modifierArg = {\n    interaction: interaction,\n    page: page,\n    statuses: statuses,\n    preEnd: true,\n    requireEndOnly: true\n  };\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) {\n    return;\n  }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  } else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  var status = interaction.inertiaStatus;\n\n  if (status.active) {\n    animationFrame.cancel(status.i);\n    status.active = false;\n    interaction.simulation = null;\n  }\n});\n\nfunction calcInertia(interaction, status) {\n  var inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  var lambda = inertiaOptions.resistance;\n  var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame() {\n  updateInertiaCoords(this);\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  var status = this.inertiaStatus;\n  var options = this.target.options[this.prepared.name].inertia;\n  var lambda = options.resistance;\n  var t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    var progress = 1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    } else {\n      var quadPoint = utils.getQuadraticCurvePoint(0, 0, status.xe, status.ye, status.modifiedXe, status.modifiedYe, progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  } else {\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame() {\n  updateInertiaCoords(this);\n\n  var status = this.inertiaStatus;\n  var t = new Date().getTime() - status.t0;\n  var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  } else {\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd = status.active = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords(interaction) {\n  var status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) {\n    return;\n  }\n\n  var pageUp = status.upCoords.page;\n  var clientUp = status.upCoords.client;\n\n  utils.setCoords(interaction.curCoords, [{\n    pageX: pageUp.x + status.sx,\n    pageY: pageUp.y + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy\n  }]);\n}\n\n},{\"./InteractEvent\":3,\"./Interaction\":5,\"./modifiers\":24,\"./utils\":43,\"./utils/raf\":49}],21:[function(require,module,exports){\nvar browser = require('./utils/browser');\nvar events = require('./utils/events');\nvar utils = require('./utils');\nvar scope = require('./scope');\nvar Interactable = require('./Interactable');\nvar Interaction = require('./Interaction');\n\nvar globalEvents = {};\n\n/*\\\n * interact\n [ method ]\n *\n * The methods of this variable can be used to set elements as\n * interactables and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to\n * configure it.\n *\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n = (object) An @Interactable\n *\n > Usage\n | interact('#draggable').draggable(true);\n |\n | var rectables = interact('rect');\n | rectables\n |     .gesturable(true)\n |     .on('gesturemove', function (event) {\n |         // ...\n |     });\n\\*/\nfunction interact(element, options) {\n  var interactable = scope.interactables.get(element, options);\n\n  if (!interactable) {\n    interactable = new Interactable(element, options);\n    interactable.events.global = globalEvents;\n  }\n\n  return interactable;\n}\n\n/*\\\n * interact.isSet\n [ method ]\n *\n * Check if an element has been set\n - element (Element) The Element being searched for\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\n * interact.on\n [ method ]\n *\n * Adds a global listener for an InteractEvent or adds a DOM event to\n * `document`\n *\n - type       (string | array | object) The types of events to listen for\n - listener   (function) The function event (s)\n - useCapture (boolean) #optional useCapture flag for addEventListener\n = (object) interact\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator = type, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var eventType = _ref;\n\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(Interactable.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener];\n    } else {\n      globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n      events.add(scope.document, type, listener, useCapture);\n    }\n\n  return interact;\n};\n\n/*\\\n * interact.off\n [ method ]\n *\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n - type       (string | array | object) The types of events that were listened for\n - listener   (function) The listener function to be removed\n - useCapture (boolean) #optional useCapture flag for removeEventListener\n = (object) interact\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator2 = type, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var eventType = _ref2;\n\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(Interactable.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  } else {\n    var index = undefined;\n\n    if (type in globalEvents && (index = utils.indexOf(globalEvents[type], listener)) !== -1) {\n      globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.debug\n [ method ]\n *\n * Returns an object which exposes internal data\n = (object) An object with properties that outline the current state and expose internal functions and variables\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage = utils.pointerAverage;\ninteract.getTouchBBox = utils.touchBBox;\ninteract.getTouchDistance = utils.touchDistance;\ninteract.getTouchAngle = utils.touchAngle;\n\ninteract.getElementRect = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector = utils.matchesSelector;\ninteract.closest = utils.closest;\n\n/*\\\n * interact.supportsTouch\n [ method ]\n *\n = (boolean) Whether or not the browser supports touch input\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\n * interact.supportsPointerEvent\n [ method ]\n *\n = (boolean) Whether or not the browser supports PointerEvents\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\n * interact.stop\n [ method ]\n *\n * Cancels all interactions (end events are not fired)\n *\n - event (Event) An event on which to call preventDefault()\n = (object) interact\n\\*/\ninteract.stop = function (event) {\n  for (var i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.pointerMoveTolerance\n [ method ]\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n - newValue (number) #optional The movement from the start position must be greater than this value\n = (number | Interactable) The current setting or interact\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    Interaction.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return Interaction.pointerMoveTolerance;\n};\n\ninteract.addDocument = scope.addDocument;\ninteract.removeDocument = scope.removeDocument;\n\nscope.interact = interact;\n\nmodule.exports = interact;\n\n},{\"./Interactable\":4,\"./Interaction\":5,\"./scope\":33,\"./utils\":43,\"./utils/browser\":36,\"./utils/events\":39}],22:[function(require,module,exports){\nvar Interactable = require('./Interactable');\nvar Interaction = require('./Interaction');\nvar scope = require('./scope');\nvar isType = require('./utils/isType');\n\nvar _require = require('./utils/domUtils');\n\nvar nodeContains = _require.nodeContains;\nvar matchesSelector = _require.matchesSelector;\n\n/*\\\n * Interactable.preventDefault\n [ method ]\n *\n * Returns or sets whether to prevent the browser's default behaviour\n * in response to pointer events. Can be set to:\n *  - `'always'` to always prevent\n *  - `'never'` to never prevent\n *  - `'auto'` to let interact.js try to determine what would be best\n *\n - newValue (string) #optional `true`, `false` or `'auto'`\n = (string | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.preventDefault = function (newValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue;\n    return this;\n  }\n\n  if (isType.isBool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never';\n    return this;\n  }\n\n  return this.options.preventDefault;\n};\n\nInteractable.prototype.checkAndPreventDefault = function (event) {\n  var setting = this.options.preventDefault;\n\n  if (setting === 'never') {\n    return;\n  }\n\n  if (setting === 'always') {\n    event.preventDefault();\n    return;\n  }\n\n  // setting === 'auto'\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return;\n  }\n\n  // don't preventDefault on editable elements\n  if (matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n    return;\n  }\n\n  event.preventDefault();\n};\n\nfunction onInteractionEvent(_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (interaction.target) {\n    interaction.target.checkAndPreventDefault(event);\n  }\n}\n\nvar _arr = ['down', 'move', 'up', 'cancel'];\nfor (var _i = 0; _i < _arr.length; _i++) {\n  var eventSignal = _arr[_i];\n  Interaction.signals.on(eventSignal, onInteractionEvent);\n}\n\n// prevent native HTML5 drag on interact.js target elements\nInteraction.docEvents.dragstart = function preventNativeDrag(event) {\n  for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i2 >= _iterator.length) break;\n      _ref = _iterator[_i2++];\n    } else {\n      _i2 = _iterator.next();\n      if (_i2.done) break;\n      _ref = _i2.value;\n    }\n\n    var interaction = _ref;\n\n    if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n\n      interaction.target.checkAndPreventDefault(event);\n      return;\n    }\n  }\n};\n\n},{\"./Interactable\":4,\"./Interaction\":5,\"./scope\":33,\"./utils/domUtils\":38,\"./utils/isType\":45}],23:[function(require,module,exports){\nvar scope = require('./scope');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\nvar iFinder = require('./utils/interactionFinder');\n\nvar toString = Object.prototype.toString;\nvar window = scope.window;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick(event) {\n  var interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) {\n    return;\n  }\n\n  if (interaction.prevTap && event.clientX === interaction.prevTap.clientX && event.clientY === interaction.prevTap.clientY && event.target === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes[0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  (function () {\n    var selectFix = function (event) {\n      for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var interaction = _ref;\n\n        if (interaction.interacting()) {\n          interaction.target.checkAndPreventDefault(event);\n        }\n      }\n    };\n\n    var onDocIE8 = function onDocIE8(_ref2, signalName) {\n      var doc = _ref2.doc;\n      var win = _ref2.win;\n\n      var eventMethod = signalName.indexOf('listen') === 0 ? events.add : events.remove;\n\n      // For IE's lack of Event#preventDefault\n      eventMethod(doc, 'selectstart', selectFix);\n\n      if (scope.pointerEvents) {\n        eventMethod(doc, 'dblclick', onIE8Dblclick);\n      }\n    };\n\n    scope.signals.on('add-document', onDocIE8);\n    scope.signals.on('remove-document', onDocIE8);\n  })();\n}\n\nmodule.exports = null;\n\n},{\"./scope\":33,\"./utils/browser\":36,\"./utils/events\":39,\"./utils/interactionFinder\":44}],24:[function(require,module,exports){\nvar InteractEvent = require('../InteractEvent');\nvar Interaction = require('../Interaction');\nvar extend = require('../utils/extend');\n\nvar modifiers = {\n  names: [],\n\n  setOffsets: function (arg) {\n    var interaction = arg.interaction;\n    var page = arg.pageCoords;\n    var target = interaction.target;\n    var element = interaction.element;\n    var startOffset = interaction.startOffset;\n\n    var rect = target.getRect(element);\n\n    if (rect) {\n      startOffset.left = page.x - rect.left;\n      startOffset.top = page.y - rect.top;\n\n      startOffset.right = rect.right - page.x;\n      startOffset.bottom = rect.bottom - page.y;\n\n      if (!('width' in rect)) {\n        rect.width = rect.right - rect.left;\n      }\n      if (!('height' in rect)) {\n        rect.height = rect.bottom - rect.top;\n      }\n    } else {\n      startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\n    }\n\n    arg.rect = rect;\n    arg.interactable = target;\n    arg.element = element;\n\n    for (var i = 0; i < modifiers.names.length; i++) {\n      var modifierName = modifiers.names[i];\n\n      arg.options = target.options[interaction.prepared.name][modifierName];\n\n      if (!arg.options) {\n        continue;\n      }\n\n      interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\n    }\n  },\n\n  setAll: function (arg) {\n    var interaction = arg.interaction;\n    var statuses = arg.statuses;\n    var preEnd = arg.preEnd;\n    var requireEndOnly = arg.requireEndOnly;\n\n    var coords = extend({}, arg.pageCoords);\n    var result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true\n    };\n\n    for (var _iterator = modifiers.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var modifierName = _ref;\n\n      var modifier = modifiers[modifierName];\n      var options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      if (!shouldDo(options, preEnd, requireEndOnly)) {\n        continue;\n      }\n\n      arg.status = arg.status = statuses[modifierName];\n      arg.options = options;\n      arg.offset = arg.interaction.modifierOffsets[modifierName];\n\n      modifier.set(arg);\n\n      if (arg.status.locked) {\n        coords.x += arg.status.dx;\n        coords.y += arg.status.dy;\n\n        result.dx += arg.status.dx;\n        result.dy += arg.status.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if:\n    //  - there are no modifiers enabled,\n    //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\n    //  - the locked coords have changed since the last pointer move\n    result.shouldMove = !arg.status || !result.locked || arg.status.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (var _iterator2 = modifiers.names, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var modifierName = _ref2;\n\n      var _status = statuses[modifierName] || {};\n\n      _status.dx = _status.dy = 0;\n      _status.modifiedX = _status.modifiedY = NaN;\n      _status.locked = false;\n      _status.changed = true;\n\n      statuses[modifierName] = _status;\n    }\n\n    return statuses;\n  },\n\n  start: function (_ref3, signalName) {\n    var interaction = _ref3.interaction;\n\n    var arg = {\n      interaction: interaction,\n      pageCoords: (signalName === 'action-resume' ? interaction.curCoords : interaction.startCoords).page,\n      startOffset: interaction.startOffset,\n      statuses: interaction.modifierStatuses,\n      preEnd: false,\n      requireEndOnly: false\n    };\n\n    modifiers.setOffsets(arg);\n    modifiers.resetStatuses(arg.statuses);\n\n    arg.pageCoords = extend({}, interaction.startCoords.page);\n    modifiers.setAll(arg);\n  }\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n});\n\nInteraction.signals.on('action-start', modifiers.start);\nInteraction.signals.on('action-resume', modifiers.start);\n\nInteraction.signals.on('before-action-move', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var preEnd = _ref4.preEnd;\n  var interactingBeforeMove = _ref4.interactingBeforeMove;\n\n  var modifierResult = modifiers.setAll({\n    interaction: interaction,\n    preEnd: preEnd,\n    pageCoords: interaction.curCoords.page,\n    statuses: interaction.modifierStatuses,\n    requireEndOnly: false\n  });\n\n  // don't fire an action move if a modifier would keep the event in the same\n  // cordinates as before\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\n    interaction._dontFireMove = true;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref5) {\n  var interaction = _ref5.interaction;\n  var event = _ref5.event;\n\n  for (var i = 0; i < modifiers.names.length; i++) {\n    var options = interaction.target.options[interaction.prepared.name][modifiers.names[i]];\n\n    // if the endOnly option is true for any modifier\n    if (shouldDo(options, true, true)) {\n      // fire a move event at the modified coordinates\n      interaction.doMove({ event: event, preEnd: true });\n      break;\n    }\n  }\n});\n\nInteractEvent.signals.on('set-xy', function (arg) {\n  var iEvent = arg.iEvent;\n  var interaction = arg.interaction;\n\n  var modifierArg = extend({}, arg);\n\n  for (var i = 0; i < modifiers.names.length; i++) {\n    var modifierName = modifiers.names[i];\n    modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\n\n    if (!modifierArg.options) {\n      continue;\n    }\n\n    var modifier = modifiers[modifierName];\n\n    modifierArg.status = interaction.modifierStatuses[modifierName];\n\n    iEvent[modifierName] = modifier.modifyCoords(modifierArg);\n  }\n});\n\nfunction shouldDo(options, preEnd, requireEndOnly) {\n  return options && options.enabled && (preEnd || !options.endOnly) && (!requireEndOnly || options.endOnly);\n}\n\nmodule.exports = modifiers;\n\n},{\"../InteractEvent\":3,\"../Interaction\":5,\"../utils/extend\":40}],25:[function(require,module,exports){\nvar modifiers = require('./index');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar restrict = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    restriction: null,\n    elementRect: null\n  },\n\n  setOffset: function (_ref) {\n    var rect = _ref.rect;\n    var startOffset = _ref.startOffset;\n    var options = _ref.options;\n\n    var elementRect = options && options.elementRect;\n    var offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - rect.width * elementRect.left;\n      offset.top = startOffset.top - rect.height * elementRect.top;\n\n      offset.right = startOffset.right - rect.width * (1 - elementRect.right);\n      offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\n    } else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function (_ref2) {\n    var pageCoords = _ref2.pageCoords;\n    var interaction = _ref2.interaction;\n    var status = _ref2.status;\n    var options = _ref2.options;\n\n    var target = interaction.target;\n    var restriction = options && options.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentNode(interaction.element);\n      } else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      } else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) {\n        return status;\n      }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    var rect = restriction;\n    var modifiedX = undefined;\n    var modifiedY = undefined;\n\n    var offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      modifiedX = page.x;\n      modifiedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n        modifiedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\n        modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\n      } else {\n        modifiedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\n        modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\n      }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n  },\n\n  modifyCoords: function (_ref3) {\n    var page = _ref3.page;\n    var client = _ref3.client;\n    var status = _ref3.status;\n    var phase = _ref3.phase;\n    var options = _ref3.options;\n\n    var elementRect = options && options.elementRect;\n\n    if (options && options.enabled && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy\n        };\n      }\n    }\n  }\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n\n},{\"../defaultOptions\":18,\"../utils\":43,\"./index\":24}],26:[function(require,module,exports){\n// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     min: { top:   0, left:   0, right: 100, bottom: 100 },\n//     max: { top: 500, left: 500, right: 600, bottom: 600 },\n//   },\n// });\n\nvar modifiers = require('./index');\nvar utils = require('../utils');\nvar rectUtils = require('../utils/rect');\nvar defaultOptions = require('../defaultOptions');\nvar resize = require('../actions/resize');\n\nvar noMin = { top: -Infinity, left: -Infinity, bottom: -Infinity, right: -Infinity };\nvar noMax = { top: +Infinity, left: +Infinity, bottom: +Infinity, right: +Infinity };\n\nvar restrictEdges = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n    offset: null\n  },\n\n  setOffset: function (_ref) {\n    var interaction = _ref.interaction;\n    var startOffset = _ref.startOffset;\n    var options = _ref.options;\n\n    if (!options) {\n      return utils.extend({}, startOffset);\n    }\n\n    var offset = getRestrictionRect(offset, interaction);\n\n    if (offset) {\n      return {\n        top: startOffset.top + offset.y,\n        left: startOffset.left + offset.x,\n        bottom: startOffset.bottom + offset.y,\n        right: startOffset.right + offset.x\n      };\n    }\n\n    return startOffset;\n  },\n\n  set: function (_ref2) {\n    var pageCoords = _ref2.pageCoords;\n    var interaction = _ref2.interaction;\n    var status = _ref2.status;\n    var offset = _ref2.offset;\n    var options = _ref2.options;\n\n    var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\n    var min = rectUtils.xywhToTlbr(getRestrictionRect(options.min, interaction)) || noMin;\n    var max = rectUtils.xywhToTlbr(getRestrictionRect(options.max, interaction)) || noMax;\n\n    var modifiedX = page.x;\n    var modifiedY = page.y;\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    if (edges.top) {\n      modifiedY = Math.max(Math.min(max.top + offset.top, page.y), min.top + offset.top);\n    } else if (edges.bottom) {\n      modifiedY = Math.max(Math.min(max.bottom - offset.bottom, page.y), min.bottom - offset.bottom);\n    }\n    if (edges.left) {\n      modifiedX = Math.max(Math.min(max.left + offset.left, page.x), min.left + offset.left);\n    } else if (edges.right) {\n      modifiedX = Math.max(Math.min(max.right - offset.right, page.x), min.right - offset.right);\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n\n    //console.log(status.dx, status.modifiedX, status.changed, status.locked);\n  },\n\n  modifyCoords: function (_ref3) {\n    var page = _ref3.page;\n    var client = _ref3.client;\n    var status = _ref3.status;\n    var phase = _ref3.phase;\n    var options = _ref3.options;\n\n    if (options && options.enabled && !(phase === 'start' && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy\n        };\n      }\n    }\n  },\n\n  noMin: noMin,\n  noMax: noMax,\n  getRestrictionRect: getRestrictionRect\n};\n\nfunction getRestrictionRect(value, interaction) {\n  value = utils.getStringOptionResult(value, interaction.element) || value;\n\n  if (utils.isFunction(value)) {\n    value = value(interaction.resizeRects.inverted);\n  }\n\n  if (utils.isElement(value)) {\n    value = utils.getElementRect(value);\n  }\n\n  return value;\n}\n\nmodifiers.restrictEdges = restrictEdges;\nmodifiers.names.push('restrictEdges');\n\ndefaultOptions.perAction.restrictEdges = restrictEdges.defaults;\nresize.defaults.restrictEdges = restrictEdges.defaults;\n\nmodule.exports = restrictEdges;\n\n},{\"../actions/resize\":10,\"../defaultOptions\":18,\"../utils\":43,\"../utils/rect\":50,\"./index\":24}],27:[function(require,module,exports){\n// This module adds the options.resize.restrictSize setting which sets min and\n// max width and height for the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictSize: {\n//     min: { width: -600, height: -600 },\n//     max: { width:  600, height:  600 },\n//   },\n// });\n\nvar modifiers = require('./index');\nvar restrictEdges = require('./restrictEdges');\nvar utils = require('../utils');\nvar rectUtils = require('../utils/rect');\nvar defaultOptions = require('../defaultOptions');\nvar resize = require('../actions/resize');\n\nvar noMin = { width: -Infinity, height: -Infinity };\nvar noMax = { width: +Infinity, height: +Infinity };\n\nvar restrictSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null\n  },\n\n  setOffset: function (_ref) {\n    var interaction = _ref.interaction;\n\n    return interaction.startOffset;\n  },\n\n  set: function (arg) {\n    var interaction = arg.interaction;\n    var options = arg.options;\n\n    var edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    var rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\n\n    var minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\n    var maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\n\n    arg.options = {\n      enabled: options.enabled,\n      endOnly: options.endOnly,\n      min: utils.extend({}, restrictEdges.noMin),\n      max: utils.extend({}, restrictEdges.noMax)\n    };\n\n    if (edges.top) {\n      arg.options.min.top = rect.bottom - maxSize.height;\n      arg.options.max.top = rect.bottom - minSize.height;\n    } else if (edges.bottom) {\n      arg.options.min.bottom = rect.top + minSize.height;\n      arg.options.max.bottom = rect.top + maxSize.height;\n    }\n    if (edges.left) {\n      arg.options.min.left = rect.right - maxSize.width;\n      arg.options.max.left = rect.right - minSize.width;\n    } else if (edges.right) {\n      arg.options.min.right = rect.left + minSize.width;\n      arg.options.max.right = rect.left + maxSize.width;\n    }\n\n    return restrictEdges.set(arg);\n  },\n\n  modifyCoords: restrictEdges.modifyCoords\n};\n\nmodifiers.restrictSize = restrictSize;\nmodifiers.names.push('restrictSize');\n\ndefaultOptions.perAction.restrictSize = restrictSize.defaults;\nresize.defaults.restrictSize = restrictSize.defaults;\n\nmodule.exports = restrictSize;\n\n},{\"../actions/resize\":10,\"../defaultOptions\":18,\"../utils\":43,\"../utils/rect\":50,\"./index\":24,\"./restrictEdges\":26}],28:[function(require,module,exports){\nvar modifiers = require('./index');\nvar interact = require('../interact');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range: Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null\n  },\n\n  setOffset: function (_ref4) {\n    var interaction = _ref4.interaction;\n    var interactable = _ref4.interactable;\n    var element = _ref4.element;\n    var rect = _ref4.rect;\n    var startOffset = _ref4.startOffset;\n    var options = _ref4.options;\n\n    var offsets = [];\n    var origin = options.origin || utils.getOriginXY(interactable, element, interaction.prepared.name);\n    options = options || interactable.options[interaction.prepared.name].snap || {};\n\n    var snapOffset = undefined;\n\n    if (options.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y\n      };\n    } else if (options.offset === 'self') {\n      snapOffset = {\n        x: rect.left - origin.x,\n        y: rect.top - origin.y\n      };\n    } else {\n      snapOffset = options.offset || { x: 0, y: 0 };\n    }\n\n    if (rect && options.relativePoints && options.relativePoints.length) {\n      for (var _iterator = options.relativePoints, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var relativeX = _ref.x;\n        var relativeY = _ref.y;\n\n        offsets.push({\n          x: startOffset.left - rect.width * relativeX + snapOffset.x,\n          y: startOffset.top - rect.height * relativeY + snapOffset.y\n        });\n      }\n    } else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function (_ref5) {\n    var interaction = _ref5.interaction;\n    var pageCoords = _ref5.pageCoords;\n    var status = _ref5.status;\n    var options = _ref5.options;\n    var offsets = _ref5.offset;\n\n    var targets = [];\n    var target = undefined;\n    var page = undefined;\n    var i = undefined;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    } else {\n      var origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    var len = options.targets ? options.targets.length : 0;\n\n    for (var _iterator2 = offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var offsetX = _ref2.x;\n      var offsetY = _ref2.y;\n\n      var relativeX = page.x - offsetX;\n      var relativeY = page.y - offsetY;\n\n      for (var _iterator3 = options.targets, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var snapTarget = _ref3;\n\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        } else {\n          target = snapTarget;\n        }\n\n        if (!target) {\n          continue;\n        }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? target.x + offsetX : relativeX,\n          y: utils.isNumber(target.y) ? target.y + offsetY : relativeY,\n\n          range: utils.isNumber(target.range) ? target.range : options.range\n        });\n      }\n    }\n\n    var closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      var range = target.range;\n      var dx = target.x - page.x;\n      var dy = target.y - page.y;\n      var distance = utils.hypot(dx, dy);\n      var inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n      // is the closest target in range?\n      ? closest.inRange && range !== Infinity\n      // the pointer is relatively deeper in this target\n      ? distance / range < closest.distance / closest.range\n      // this target has Infinite range and the closest doesn't\n      : range === Infinity && closest.range !== Infinity ||\n      // OR this target is closer that the previous closest\n      distance < closest.distance :\n      // The other is not in range and the pointer is closer to this target\n      !closest.inRange && distance < closest.distance)) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    var snapChanged = undefined;\n\n    if (closest.target) {\n      snapChanged = status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y;\n\n      status.modifiedX = closest.target.x;\n      status.modifiedY = closest.target.y;\n    } else {\n      snapChanged = true;\n\n      status.modifiedX = NaN;\n      status.modifiedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = snapChanged || closest.inRange && !status.locked;\n    status.locked = closest.inRange;\n  },\n\n  modifyCoords: function (_ref6) {\n    var page = _ref6.page;\n    var client = _ref6.client;\n    var status = _ref6.status;\n    var phase = _ref6.phase;\n    var options = _ref6.options;\n\n    var relativePoints = options && options.relativePoints;\n\n    if (options && options.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range: status.range,\n        locked: status.locked,\n        x: status.modifiedX,\n        y: status.modifiedY,\n        realX: status.realX,\n        realY: status.realY,\n        dx: status.dx,\n        dy: status.dy\n      };\n    }\n  }\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    var limits = grid.limits || {\n      left: -Infinity,\n      right: Infinity,\n      top: -Infinity,\n      bottom: Infinity\n    };\n    var offsetX = 0;\n    var offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    var gridx = Math.round((x - offsetX) / grid.x);\n    var gridy = Math.round((y - offsetY) / grid.y);\n\n    var newX = Math.max(limits.left, Math.min(limits.right, gridx * grid.x + offsetX));\n    var newY = Math.max(limits.top, Math.min(limits.bottom, gridy * grid.y + offsetY));\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n\n},{\"../defaultOptions\":18,\"../interact\":21,\"../utils\":43,\"./index\":24}],29:[function(require,module,exports){\n// This module allows snapping of the size of targets during resize\n// interactions.\n\nvar modifiers = require('./index');\nvar snap = require('./snap');\nvar defaultOptions = require('../defaultOptions');\nvar resize = require('../actions/resize');\nvar utils = require('../utils/');\n\nvar snapSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range: Infinity,\n    targets: null,\n    offsets: null\n  },\n\n  setOffset: function (arg) {\n    var interaction = arg.interaction;\n    var options = arg.options;\n\n    var edges = interaction.prepared.edges;\n\n    if (!edges) {\n      return;\n    }\n\n    arg.options = {\n      relativePoints: [{\n        x: edges.left ? 0 : 1,\n        y: edges.top ? 0 : 1\n      }],\n      origin: { x: 0, y: 0 },\n      offset: 'self',\n      range: options.range\n    };\n\n    var offsets = snap.setOffset(arg);\n    arg.options = options;\n\n    return offsets;\n  },\n\n  set: function (arg) {\n    var interaction = arg.interaction;\n    var options = arg.options;\n    var offset = arg.offset;\n    var pageCoords = arg.pageCoords;\n\n    var page = utils.extend({}, pageCoords);\n    var relativeX = page.x - offset[0].x;\n    var relativeY = page.y - offset[0].y;\n\n    arg.options = utils.extend({}, options);\n    arg.options.targets = [];\n\n    for (var _iterator = options.targets, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var snapTarget = _ref;\n\n      var target = undefined;\n\n      if (utils.isFunction(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction);\n      } else {\n        target = snapTarget;\n      }\n\n      if (!target) {\n        continue;\n      }\n\n      if ('width' in target && 'height' in target) {\n        target.x = target.width;\n        target.y = target.height;\n      }\n\n      arg.options.targets.push(target);\n    }\n\n    snap.set(arg);\n  },\n\n  modifyCoords: function (arg) {\n    var options = arg.options;\n\n    arg.options = utils.extend({}, options);\n    arg.options.enabled = options.enabled;\n    arg.options.relativePoints = [null];\n\n    snap.modifyCoords(arg);\n  }\n};\n\nmodifiers.snapSize = snapSize;\nmodifiers.names.push('snapSize');\n\ndefaultOptions.perAction.snapSize = snapSize.defaults;\nresize.defaults.snapSize = snapSize.defaults;\n\nmodule.exports = snapSize;\n\n},{\"../actions/resize\":10,\"../defaultOptions\":18,\"../utils/\":43,\"./index\":24,\"./snap\":28}],30:[function(require,module,exports){\nvar pointerEvents = require('./index.js');\nvar Interaction = require('../Interaction');\n\npointerEvents.signals.on('new', function (_ref) {\n  var pointerEvent = _ref.pointerEvent;\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1;\n});\n\npointerEvents.signals.on('fired', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointerEvent = _ref2.pointerEvent;\n  var eventTarget = _ref2.eventTarget;\n  var targets = _ref2.targets;\n\n  if (pointerEvent.type !== 'hold') {\n    return;\n  }\n\n  // get the repeat interval from the first eventable\n  var interval = targets[0].eventable.options.holdRepeatInterval;\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) {\n    return;\n  }\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(function () {\n    pointerEvents.collectEventTargets(interaction, pointerEvent, pointerEvent, eventTarget, 'hold');\n  }, interval);\n});\n\nfunction endHoldRepeat(_ref3) {\n  var interaction = _ref3.interaction;\n\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle);\n    interaction.holdIntervalHandle = null;\n  }\n}\n\nvar _arr = ['move', 'up', 'cancel', 'endall'];\nfor (var _i = 0; _i < _arr.length; _i++) {\n  var signal = _arr[_i];\n  Interaction.signals.on(signal, endHoldRepeat);\n}\n\n// don't repeat by default\npointerEvents.defaults.holdRepeatInterval = 0;\npointerEvents.types.push('holdrepeat');\n\n},{\"../Interaction\":5,\"./index.js\":31}],31:[function(require,module,exports){\nvar scope = require('../scope');\nvar Interaction = require('../Interaction');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar defaults = require('../defaultOptions');\nvar signals = require('../utils/Signals')['new']();\n\nvar _require = require('../utils/arr');\n\nvar filter = _require.filter;\n\nvar simpleSignals = ['down', 'up', 'up', 'cancel'];\nvar simpleEvents = ['down', 'up', 'tap', 'cancel'];\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopImmediatePropagation() {\n  this.immediatePropagationStopped = this.propagationStopped = true;\n}\n\nfunction stopPropagation() {\n  this.propagationStopped = true;\n}\n\nfunction firePointers(interaction, pointer, event, eventTarget, targets, eventType) {\n  var pointerIndex = interaction.getPointerIndex(pointer);\n  var pointerEvent = {};\n  var i = undefined;\n  // for tap events\n  var interval = undefined;\n  var createNewDoubleTap = undefined;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  } else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault = preventOriginalDefault;\n    pointerEvent.stopPropagation = stopPropagation;\n    pointerEvent.stopImmediatePropagation = stopImmediatePropagation;\n    pointerEvent.interaction = interaction;\n\n    pointerEvent.timeStamp = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type = eventType;\n    pointerEvent.pointerId = utils.getPointerId(pointer);\n    pointerEvent.pointerType = interaction.mouse ? 'mouse' : !browser.supportsPointerEvent ? 'touch' : utils.isString(pointer.pointerType) ? pointer.pointerType : [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === pointerEvent.target && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  var signalArg = {\n    interaction: interaction,\n    pointerEvent: pointerEvent,\n    pointer: pointer,\n    event: event,\n    eventTarget: eventTarget,\n    targets: targets\n  };\n\n  signals.fire('new', signalArg);\n\n  for (i = 0; i < targets.length; i++) {\n    var target = targets[i];\n\n    pointerEvent.currentTarget = target.element;\n\n    for (var prop in target.props || {}) {\n      pointerEvent[prop] = target.props[prop];\n    }\n\n    var _utils$getOriginXY = utils.getOriginXY(target.eventable, target.element);\n\n    var originX = _utils$getOriginXY.x;\n    var originY = _utils$getOriginXY.y;\n\n    pointerEvent.pageX -= originX;\n    pointerEvent.pageY -= originY;\n    pointerEvent.clientX -= originX;\n    pointerEvent.clientY -= originY;\n\n    pointerEvent.eventable = target.eventable;\n\n    target.eventable.fire(pointerEvent);\n\n    pointerEvent.pageX += originX;\n    pointerEvent.pageY += originY;\n    pointerEvent.clientX += originX;\n    pointerEvent.clientY += originY;\n\n    if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].element !== pointerEvent.currentTarget) {\n      break;\n    }\n  }\n\n  signals.fire('fired', signalArg);\n\n  if (createNewDoubleTap) {\n    var doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  } else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets(interaction, pointer, event, eventTarget, eventType) {\n  var pointerIndex = interaction.getPointerIndex(pointer);\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n  // or if the pointerup target is different to the pointerdown target\n   || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  var targets = [];\n  var path = utils.getPath(eventTarget);\n  var signalArg = {\n    targets: targets,\n    interaction: interaction,\n    pointer: pointer,\n    event: event,\n    eventTarget: eventTarget,\n    eventType: eventType,\n    path: path,\n    element: null\n  };\n\n  for (var _iterator = path, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var element = _ref;\n\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (eventType === 'hold') {\n    targets = filter(targets, function (target) {\n      return target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration;\n    });\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, eventType);\n  }\n}\n\nInteraction.signals.on('move', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var pointer = _ref3.pointer;\n  var event = _ref3.event;\n  var eventTarget = _ref3.eventTarget;\n  var duplicateMove = _ref3.duplicateMove;\n\n  var pointerIndex = interaction.getPointerIndex(pointer);\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nInteraction.signals.on('down', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var pointer = _ref4.pointer;\n  var event = _ref4.event;\n  var eventTarget = _ref4.eventTarget;\n  var pointerIndex = _ref4.pointerIndex;\n\n  // copy event to be used in timeout for IE8\n  var eventCopy = browser.isIE8 ? utils.extend({}, event) : event;\n  var timers = interaction.holdTimers;\n\n  if (!timers[pointerIndex]) {\n    timers[pointerIndex] = { duration: Infinity, timeout: null };\n  }\n\n  var timer = timers[pointerIndex];\n  var path = utils.getPath(eventTarget);\n  var signalArg = {\n    interaction: interaction,\n    pointer: pointer,\n    event: event,\n    eventTarget: eventTarget,\n    eventType: 'hold',\n    targets: [],\n    path: path,\n    element: null\n  };\n\n  for (var _iterator2 = path, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var element = _ref2;\n\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (!signalArg.targets.length) {\n    return;\n  }\n\n  var minDuration = Infinity;\n\n  for (var i = 0; i < signalArg.targets.length; i++) {\n    var target = signalArg.targets[i];\n    var holdDuration = target.eventable.options.holdDuration;\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration;\n    }\n  }\n\n  timer.duration = minDuration;\n  timer.timeout = setTimeout(function () {\n\n    collectEventTargets(interaction, browser.isIE8 ? eventCopy : pointer, eventCopy, eventTarget, 'hold');\n  }, minDuration);\n});\n\n['up', 'cancel'].forEach(function (signalName) {\n  Interaction.signals.on(signalName, function (_ref5) {\n    var interaction = _ref5.interaction;\n    var pointerIndex = _ref5.pointerIndex;\n\n    if (interaction.holdTimers[pointerIndex]) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n  });\n});\n\nfunction createSignalListener(event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction, arg.pointer, arg.event, arg.eventTarget, event);\n  };\n}\n\nfor (var i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap = null; // the most recent tap event on this interaction\n  interaction.tapTime = 0; // time of the most recent tap event\n});\n\ndefaults.pointerEvents = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 }\n};\n\nmodule.exports = scope.pointerEvents = {\n  firePointers: firePointers,\n  collectEventTargets: collectEventTargets,\n  preventOriginalDefault: preventOriginalDefault,\n  signals: signals,\n  defaults: defaults.pointerEvents,\n  types: ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']\n};\n\n},{\"../Interaction\":5,\"../defaultOptions\":18,\"../scope\":33,\"../utils\":43,\"../utils/Signals\":34,\"../utils/arr\":35,\"../utils/browser\":36}],32:[function(require,module,exports){\nvar pointerEvents = require('./index');\nvar Interactable = require('../Interactable');\nvar browser = require('../utils/browser');\nvar isType = require('../utils/isType');\nvar domUtils = require('../utils/domUtils');\nvar scope = require('../scope');\nvar extend = require('../utils/extend');\n\nvar _require = require('../utils/arr');\n\nvar merge = _require.merge;\n\npointerEvents.signals.on('collect-targets', function (_ref) {\n  var targets = _ref.targets;\n  var element = _ref.element;\n  var eventType = _ref.eventType;\n  var eventTarget = _ref.eventTarget;\n\n  function collectSelectors(interactable, selector, context) {\n    var els = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    var eventable = interactable.events;\n    var options = eventable.options;\n\n    if (eventable[eventType] && isType.isElement(element) && domUtils.matchesSelector(element, selector, els) && interactable.testIgnoreAllow(options, element, eventTarget)) {\n\n      targets.push({\n        element: element,\n        eventable: eventable,\n        props: { interactable: interactable }\n      });\n    }\n  }\n\n  var interactable = scope.interactables.get(element);\n\n  if (interactable) {\n    var eventable = interactable.events;\n    var options = eventable.options;\n\n    if (eventable[eventType] && interactable.testIgnoreAllow(options, element, eventTarget)) {\n      targets.push({\n        element: element,\n        eventable: eventable,\n        props: { interactable: interactable }\n      });\n    }\n  }\n\n  scope.interactables.forEachSelector(collectSelectors, element);\n});\n\nInteractable.signals.on('new', function (_ref2) {\n  var interactable = _ref2.interactable;\n\n  interactable.events.getRect = function (element) {\n    return interactable.getRect(element);\n  };\n});\n\nInteractable.signals.on('set', function (_ref3) {\n  var interactable = _ref3.interactable;\n  var options = _ref3.options;\n\n  extend(interactable.events.options, pointerEvents.defaults);\n  extend(interactable.events.options, options);\n});\n\nmerge(Interactable.eventTypes, pointerEvents.types);\n\nInteractable.prototype.pointerEvents = function (options) {\n  extend(this.events.options, options);\n\n  return this;\n};\n\nvar __backCompatOption = Interactable.prototype._backCompatOption;\n\nInteractable.prototype._backCompatOption = function (optionName, newValue) {\n  var ret = __backCompatOption.call(this, optionName, newValue);\n\n  if (ret === this) {\n    this.events.options[optionName] = newValue;\n  }\n\n  return ret;\n};\n\nInteractable.settingsMethods.push('pointerEvents');\n\n},{\"../Interactable\":4,\"../scope\":33,\"../utils/arr\":35,\"../utils/browser\":36,\"../utils/domUtils\":38,\"../utils/extend\":40,\"../utils/isType\":45,\"./index\":31}],33:[function(require,module,exports){\nvar utils = require('./utils');\nvar extend = require('./utils/extend');\nvar events = require('./utils/events');\nvar signals = require('./utils/Signals')['new']();\n\nvar scope = {\n  signals: signals,\n  events: events,\n  utils: utils,\n\n  documents: [], // all documents being listened to\n\n  addDocument: function (doc, win) {\n    // do nothing if document is already known\n    if (utils.contains(scope.documents, doc)) {\n      return false;\n    }\n\n    win = win || scope.getWindow(doc);\n\n    scope.documents.push(doc);\n    events.documents.push(doc);\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== scope.document) {\n      events.add(win, 'unload', scope.onWindowUnload);\n    }\n\n    signals.fire('add-document', { doc: doc, win: win });\n  },\n\n  removeDocument: function (doc, win) {\n    var index = utils.indexOf(scope.documents, doc);\n\n    win = win || scope.getWindow(doc);\n\n    events.remove(win, 'unload', scope.onWindowUnload);\n\n    scope.documents.splice(index, 1);\n    events.documents.splice(index, 1);\n\n    signals.fire('remove-document', { win: win, doc: doc });\n  },\n\n  onWindowUnload: function () {\n    scope.removeDocument(this.document, this);\n  }\n};\n\nextend(scope, require('./utils/window'));\nextend(scope, require('./utils/domObjects'));\n\nmodule.exports = scope;\n\n},{\"./utils\":43,\"./utils/Signals\":34,\"./utils/domObjects\":37,\"./utils/events\":39,\"./utils/extend\":40,\"./utils/window\":51}],34:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _require = require('./arr');\n\nvar indexOf = _require.indexOf;\n\nvar Signals = (function () {\n  function Signals() {\n    _classCallCheck(this, Signals);\n\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  Signals.prototype.on = function on(name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  };\n\n  Signals.prototype.off = function off(name, listener) {\n    if (!this.listeners[name]) {\n      return;\n    }\n\n    var index = indexOf(this.listeners[name], listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  };\n\n  Signals.prototype.fire = function fire(name, arg) {\n    var targetListeners = this.listeners[name];\n\n    if (!targetListeners) {\n      return;\n    }\n\n    for (var i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  };\n\n  return Signals;\n})();\n\nSignals['new'] = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n\n},{\"./arr\":35}],35:[function(require,module,exports){\nfunction indexOf(array, target) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains(array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nfunction filter(array, test) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    if (test(array[i])) {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  indexOf: indexOf,\n  contains: contains,\n  merge: merge,\n  filter: filter\n};\n\n},{}],36:[function(require,module,exports){\nvar win = require('./window');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar Element = domObjects.Element;\nvar navigator = win.window.navigator;\n\nvar browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!('ontouchstart' in win.window || isType.isFunction(win.window.DocumentTouch) && domObjects.document instanceof win.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIE8: 'attachEvent' in win.window && !('addEventListener' in win.window),\n\n  // Opera Mobile must be handled differently\n  isOperaMobile: navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto'),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n\n  isIe9OrOlder: /MSIE (8|9)/.test(navigator.userAgent),\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n\n  useMatchesSelectorPolyfill: false,\n\n  pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === win.window.MSPointerEvent ? {\n    up: 'MSPointerUp',\n    down: 'MSPointerDown',\n    over: 'mouseover',\n    out: 'mouseout',\n    move: 'MSPointerMove',\n    cancel: 'MSPointerCancel'\n  } : {\n    up: 'pointerup',\n    down: 'pointerdown',\n    over: 'pointerover',\n    out: 'pointerout',\n    move: 'pointermove',\n    cancel: 'pointercancel'\n  } : null,\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  wheelEvent: 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n\n},{\"./domObjects\":37,\"./isType\":45,\"./window\":51}],37:[function(require,module,exports){\nvar domObjects = {};\nvar win = require('./window').window;\n\nfunction blank() {}\n\ndomObjects.document = win.document;\ndomObjects.DocumentFragment = win.DocumentFragment || blank;\ndomObjects.SVGElement = win.SVGElement || blank;\ndomObjects.SVGSVGElement = win.SVGSVGElement || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.Element = win.Element || blank;\ndomObjects.HTMLElement = win.HTMLElement || domObjects.Element;\n\ndomObjects.Event = win.Event;\ndomObjects.Touch = win.Touch || blank;\ndomObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\n\nmodule.exports = domObjects;\n\n},{\"./window\":51}],38:[function(require,module,exports){\nvar win = require('./window');\nvar browser = require('./browser');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (element, selector) {\n    while (isType.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return element;\n      }\n\n      element = domUtils.parentNode(element);\n    }\n\n    return null;\n  },\n\n  parentNode: function (node) {\n    var parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill ? function (element, selector, elems) {\n    elems = elems || element.parentNode.querySelectorAll(selector);\n\n    for (var i = 0, len = elems.length; i < len; i++) {\n      if (elems[i] === element) {\n        return true;\n      }\n    }\n\n    return false;\n  } : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    var deepestZoneParents = [];\n    var dropzoneParents = [];\n    var dropzone = undefined;\n    var deepestZone = elements[0];\n    var index = deepestZone ? 0 : -1;\n    var parent = undefined;\n    var child = undefined;\n    var i = undefined;\n    var n = undefined;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n          deepestZone = dropzone;\n          index = i;\n          continue;\n        }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      } else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        } else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (isType.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentNode(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\n    };\n  },\n\n  getElementClientRect: function (element) {\n    var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n\n    return clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top\n    };\n  },\n\n  getElementRect: function (element) {\n    var clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      var _scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left += _scroll.x;\n      clientRect.right += _scroll.x;\n      clientRect.top += _scroll.y;\n      clientRect.bottom += _scroll.y;\n    }\n\n    return clientRect;\n  },\n\n  getPath: function (element) {\n    var path = [];\n\n    while (element) {\n      path.push(element);\n      element = domUtils.parentNode(element);\n    }\n\n    return path;\n  }\n};\n\nmodule.exports = domUtils;\n\n},{\"./browser\":36,\"./domObjects\":37,\"./isType\":45,\"./window\":51}],39:[function(require,module,exports){\nvar isType = require('./isType');\nvar domUtils = require('./domUtils');\nvar pExtend = require('./pointerExtend');\n\nvar _require = require('./window');\n\nvar window = _require.window;\nvar getWindow = _require.getWindow;\n\nvar _require2 = require('./arr');\n\nvar indexOf = _require2.indexOf;\nvar contains = _require2.contains;\n\nvar useAttachEvent = 'attachEvent' in window && !('addEventListener' in window);\nvar addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener';\nvar removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener';\nvar on = useAttachEvent ? 'on' : '';\n\nvar elements = [];\nvar targets = [];\nvar attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nvar delegatedEvents = {};\n\nvar documents = [];\n\nfunction add(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push(useAttachEvent ? {\n      supplied: [],\n      wrapped: [],\n      useCount: []\n    } : null);\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    var ret = undefined;\n\n    if (useAttachEvent) {\n      var _attachedListeners$elementIndex = attachedListeners[elementIndex];\n      var supplied = _attachedListeners$elementIndex.supplied;\n      var wrapped = _attachedListeners$elementIndex.wrapped;\n      var useCount = _attachedListeners$elementIndex.useCount;\n\n      var listenerIndex = indexOf(supplied, listener);\n\n      var wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault = event.preventDefault || preventDef;\n          event.stopPropagation = event.stopPropagation || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      } else {\n        useCount[listenerIndex]++;\n      }\n    } else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  var wrappedListener = listener;\n  var listeners = undefined;\n  var listenerIndex = undefined;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    var len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (var i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    } else {\n      for (var i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate(selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts: [],\n      listeners: []\n    };\n\n    // add delegate listener functions\n    for (var i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  var delegated = delegatedEvents[type];\n  var index = undefined;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts.push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate(selector, context, type, listener, useCapture) {\n  var delegated = delegatedEvents[type];\n  var matchFound = false;\n  var index = undefined;\n\n  if (!delegated) {\n    return;\n  }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n\n      var listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (var i = listeners.length - 1; i >= 0; i--) {\n        var fn = listeners[i][0];\n        var useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts.splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) {\n        break;\n      }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener(event, useCapture) {\n  var fakeEvent = {};\n  var delegated = delegatedEvents[event.type];\n  var eventTarget = domUtils.getActualElement(event.path ? event.path[0] : event.target);\n  var element = eventTarget;\n\n  useCapture = useCapture ? true : false;\n\n  // duplicate the event so that currentTarget can be changed\n  pExtend(fakeEvent, event);\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (var i = 0; i < delegated.selectors.length; i++) {\n      var selector = delegated.selectors[i];\n      var context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\n\n        var listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (var j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element);\n  }\n}\n\nfunction delegateUseCapture(event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef() {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp() {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp() {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add: add,\n  remove: remove,\n\n  addDelegate: addDelegate,\n  removeDelegate: removeDelegate,\n\n  delegateListener: delegateListener,\n  delegateUseCapture: delegateUseCapture,\n  delegatedEvents: delegatedEvents,\n  documents: documents,\n\n  useAttachEvent: useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners\n};\n\n},{\"./arr\":35,\"./domUtils\":38,\"./isType\":45,\"./pointerExtend\":47,\"./window\":51}],40:[function(require,module,exports){\nmodule.exports = function extend(dest, source) {\n  for (var prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n\n},{}],41:[function(require,module,exports){\nvar _require = require('./domUtils');\n\nvar closest = _require.closest;\nvar parentNode = _require.parentNode;\nvar getElementRect = _require.getElementRect;\n\nvar _require2 = require('./isType');\n\nvar isElement = _require2.isElement;\nvar isFunction = _require2.isFunction;\nvar trySelector = _require2.trySelector;\n\nmodule.exports = function (target, element, action) {\n  var actionOptions = target.options[action];\n  var actionOrigin = actionOptions && actionOptions.origin;\n  var origin = actionOrigin || target.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentNode(element);\n  } else if (origin === 'self') {\n    origin = target.getRect(element);\n  } else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(target && element);\n  }\n\n  if (isElement(origin)) {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = 'x' in origin ? origin.x : origin.left;\n  origin.y = 'y' in origin ? origin.y : origin.top;\n\n  return origin;\n};\n\n},{\"./domUtils\":38,\"./isType\":45}],42:[function(require,module,exports){\nmodule.exports = function (x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\n},{}],43:[function(require,module,exports){\nvar extend = require('./extend');\nvar win = require('./window');\n\nvar utils = {\n  warnOnce: function (method, message) {\n    var warned = false;\n\n    return function () {\n      if (!warned) {\n        win.window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  },\n\n  // http://stackoverflow.com/a/5634528/2280888\n  _getQBezierValue: function (t, p1, p2, p3) {\n    var iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  },\n\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x: utils._getQBezierValue(position, startX, cpX, endX),\n      y: utils._getQBezierValue(position, startY, cpY, endY)\n    };\n  },\n\n  // http://gizma.com/easing/\n  easeOutQuad: function (t, b, c, d) {\n    t /= d;\n    return -c * t * (t - 2) + b;\n  },\n\n  copyAction: function (dest, src) {\n    dest.name = src.name;\n    dest.axis = src.axis;\n    dest.edges = src.edges;\n\n    return dest;\n  },\n\n  getStringOptionResult: function (value, interactable, element) {\n    if (!utils.isString(value)) {\n      return null;\n    }\n\n    if (value === 'parent') {\n      value = utils.parentNode(element);\n    } else if (value === 'self') {\n      value = interactable.getRect(element);\n    } else {\n      value = utils.closest(element, value);\n    }\n\n    return value;\n  },\n\n  extend: extend,\n  hypot: require('./hypot'),\n  getOriginXY: require('./getOriginXY')\n};\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n\nmodule.exports = utils;\n\n},{\"./arr\":35,\"./domUtils\":38,\"./extend\":40,\"./getOriginXY\":41,\"./hypot\":42,\"./isType\":45,\"./pointerUtils\":48,\"./window\":51}],44:[function(require,module,exports){\nvar scope = require('../scope');\nvar utils = require('./index');\nvar browser = require('./browser');\n\nvar finder = {\n  methodOrder: ['simulationResume', 'mouse', 'hasPointer', 'idle'],\n\n  search: function (pointer, eventType, eventTarget) {\n    var mouseEvent = /mouse/i.test(pointer.pointerType || eventType)\n    // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n     || pointer.pointerType === 4;\n    var pointerId = utils.getPointerId(pointer);\n    var details = { pointer: pointer, pointerId: pointerId, mouseEvent: mouseEvent, eventType: eventType, eventTarget: eventTarget };\n\n    for (var _iterator = finder.methodOrder, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var method = _ref;\n\n      var interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function (_ref7) {\n    var mouseEvent = _ref7.mouseEvent;\n    var eventType = _ref7.eventType;\n    var eventTarget = _ref7.eventTarget;\n\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (var _iterator2 = scope.interactions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var interaction = _ref2;\n\n      var element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume && interaction.mouse === mouseEvent) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentNode(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function (_ref8) {\n    var pointerId = _ref8.pointerId;\n    var mouseEvent = _ref8.mouseEvent;\n    var eventType = _ref8.eventType;\n\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    var firstNonActive = undefined;\n\n    for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var interaction = _ref3;\n\n      if (interaction.mouse) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) {\n          continue;\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n            firstNonActive = interaction;\n          }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // Find any interaction specifically for mouse.\n    // ignore the interaction if the eventType is a mousedown, and a simulation\n    // is active\n    for (var _iterator4 = scope.interactions, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var interaction = _ref4;\n\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function (_ref9) {\n    var pointerId = _ref9.pointerId;\n\n    for (var _iterator5 = scope.interactions, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var interaction = _ref5;\n\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function (_ref10) {\n    var mouseEvent = _ref10.mouseEvent;\n\n    for (var _iterator6 = scope.interactions, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var interaction = _ref6;\n\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        var target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n          continue;\n        }\n\n      if (!interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  }\n};\n\nmodule.exports = finder;\n\n},{\"../scope\":33,\"./browser\":36,\"./index\":43}],45:[function(require,module,exports){\nvar win = require('./window');\nvar isWindow = require('./isWindow');\nvar domObjects = require('./domObjects');\n\nvar isType = {\n  isElement: function (o) {\n    if (!o || typeof o !== 'object') {\n      return false;\n    }\n\n    var _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element) ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  },\n\n  isArray: null,\n\n  isWindow: function (thing) {\n    return thing === win.window || isWindow(thing);\n  },\n\n  isDocFrag: function (thing) {\n    return isType.isObject(thing) && thing.nodeType === 11;\n  },\n\n  isObject: function (thing) {\n    return !!thing && typeof thing === 'object';\n  },\n\n  isFunction: function (thing) {\n    return typeof thing === 'function';\n  },\n\n  isNumber: function (thing) {\n    return typeof thing === 'number';\n  },\n\n  isBool: function (thing) {\n    return typeof thing === 'boolean';\n  },\n\n  isString: function (thing) {\n    return typeof thing === 'string';\n  },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) {\n      return false;\n    }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  }\n};\n\nisType.isArray = function (thing) {\n  return isType.isObject(thing) && typeof thing.length !== 'undefined' && isType.isFunction(thing.splice);\n};\n\nmodule.exports = isType;\n\n},{\"./domObjects\":37,\"./isWindow\":46,\"./window\":51}],46:[function(require,module,exports){\nmodule.exports = function (thing) {\n  return !!(thing && thing.Window) && thing instanceof thing.Window;\n};\n\n},{}],47:[function(require,module,exports){\nfunction pointerExtend(dest, source) {\n  for (var prop in source) {\n    var prefixedPropREs = module.exports.prefixedPropREs;\n    var deprecated = false;\n\n    // skip deprecated prefixed properties\n    for (var vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true;\n        break;\n      }\n    }\n\n    if (!deprecated) {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n};\n\nmodule.exports = pointerExtend;\n\n},{}],48:[function(require,module,exports){\nvar hypot = require('./hypot');\nvar browser = require('./browser');\nvar dom = require('./domObjects');\nvar isType = require('./isType');\nvar pointerExtend = require('./pointerExtend');\n\nvar pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setCoordDeltas: function (targetObj, prev, cur) {\n    targetObj.page.x = cur.page.x - prev.page.x;\n    targetObj.page.y = cur.page.y - prev.page.y;\n    targetObj.client.x = cur.client.x - prev.client.x;\n    targetObj.client.y = cur.client.y - prev.client.y;\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx = targetObj.page.x / dt;\n    targetObj.page.vy = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx = targetObj.client.x / dt;\n    targetObj.client.vy = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function (pointer) {\n    return pointer instanceof dom.Event || pointer instanceof dom.Touch;\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    } else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    } else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n  },\n\n  setCoords: function (targetObj, pointers, timeStamp) {\n    var pointer = pointers.length > 1 ? pointerUtils.pointerAverage(pointers) : pointers[0];\n\n    var tmpXY = {};\n\n    pointerUtils.getPageXY(pointer, tmpXY);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    pointerUtils.getClientXY(pointer, tmpXY);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = isType.isNumber(timeStamp) ? timeStamp : new Date().getTime();\n  },\n\n  pointerExtend: pointerExtend,\n\n  getTouchPair: function (event) {\n    var touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n        if (event.type === 'touchend') {\n          if (event.touches.length === 1) {\n            touches[0] = event.touches[0];\n            touches[1] = event.changedTouches[0];\n          } else if (event.touches.length === 0) {\n            touches[0] = event.changedTouches[0];\n            touches[1] = event.changedTouches[1];\n          }\n        } else {\n          touches[0] = event.touches[0];\n          touches[1] = event.touches[1];\n        }\n      }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    var average = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n\n    for (var _iterator = pointers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref;\n\n      for (var prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (var prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = pointerUtils.getTouchPair(event);\n    var minX = Math.min(touches[0].pageX, touches[1].pageX);\n    var minY = Math.min(touches[0].pageY, touches[1].pageY);\n    var maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    var maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n\n    var dx = touches[0][sourceX] - touches[1][sourceX];\n    var dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n    var dx = touches[1][sourceX] - touches[0][sourceX];\n    var dy = touches[1][sourceY] - touches[0][sourceY];\n    var angle = 180 * Math.atan2(dy, dx) / Math.PI;\n\n    return angle;\n  }\n};\n\nmodule.exports = pointerUtils;\n\n},{\"./browser\":36,\"./domObjects\":37,\"./hypot\":42,\"./isType\":45,\"./pointerExtend\":47}],49:[function(require,module,exports){\nvar _require = require('./window');\n\nvar window = _require.window;\n\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nvar lastTime = 0;\nvar request = undefined;\nvar cancel = undefined;\n\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request: request,\n  cancel: cancel\n};\n\n},{\"./window\":51}],50:[function(require,module,exports){\nvar extend = require('./extend');\n\nmodule.exports = {\n  xywhToTlbr: function (rect) {\n    if (rect && !('left' in rect && 'top' in rect)) {\n      rect = extend({}, rect);\n\n      rect.left = rect.x || 0;\n      rect.top = rect.y || 0;\n      rect.right = rect.right || rect.left + rect.width;\n      rect.bottom = rect.bottom || rect.top + rect.height;\n    }\n\n    return rect;\n  },\n\n  tlbrToXywh: function (rect) {\n    if (rect && !('x' in rect && 'y' in rect)) {\n      rect = extend({}, rect);\n\n      rect.x = rect.left || 0;\n      rect.top = rect.top || 0;\n      rect.width = rect.width || rect.right - rect.x;\n      rect.height = rect.height || rect.bottom - rect.y;\n    }\n\n    return rect;\n  }\n};\n\n},{\"./extend\":40}],51:[function(require,module,exports){\nvar win = module.exports;\nvar isWindow = require('./isWindow');\n\nfunction init(window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  var el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window);\n  }\n\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window = undefined;\n  win.realWindow = undefined;\n} else {\n  init(window);\n}\n\nwin.getWindow = function getWindow(node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  var rootNode = node.ownerDocument || node;\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n\n},{\"./isWindow\":46}]},{},[1])(1)\n});\n\n","const { indexOf } = require('./utils/arr');\nconst extend = require('./utils/extend.js');\n\nfunction fireUntilImmediateStopped (event, listeners) {\n  for (let i = 0, len = listeners.length; i < len && !event.immediatePropagationStopped; i++) {\n    listeners[i](event);\n  }\n}\n\nclass Eventable {\n\n  constructor (options) {\n    this.options = extend({}, options || {});\n  }\n\n  fire (event) {\n    let listeners;\n    const onEvent = 'on' + event.type;\n    const global = this.global;\n\n    // Interactable#on() listeners\n    if ((listeners = this[event.type])) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n\n    // interactable.onevent listener\n    if (this[onEvent]) {\n      this[onEvent](event);\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\n      fireUntilImmediateStopped(event, listeners);\n    }\n  }\n\n  on (eventType, listener) {\n    // if this type of event was never bound\n    if (this[eventType]) {\n      this[eventType].push(listener);\n    }\n    else {\n      this[eventType] = [listener];\n    }\n  }\n\n  off (eventType, listener) {\n    // if it is an action event type\n    const eventList = this[eventType];\n    const index     = eventList? indexOf(eventList, listener) : -1;\n\n    if (index !== -1) {\n      eventList.splice(index, 1);\n    }\n\n    if (eventList && eventList.length === 0 || !listener) {\n      this[eventType] = listener;\n    }\n  }\n}\n\nmodule.exports = Eventable;\n","const extend      = require('./utils/extend');\nconst getOriginXY = require('./utils/getOriginXY');\nconst defaults    = require('./defaultOptions');\nconst signals     = require('./utils/Signals').new();\n\nclass InteractEvent {\n  constructor (interaction, event, action, phase, element, related) {\n    const target      = interaction.target;\n    const deltaSource = (target && target.options || defaults).deltaSource;\n    const origin      = getOriginXY(target, element, action);\n    const starting    = phase === 'start';\n    const ending      = phase === 'end';\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\n    const prevEvent   = interaction.prevEvent;\n\n    element = element || interaction.element;\n\n    const page   = extend({}, coords.page);\n    const client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey       = event.ctrlKey;\n    this.altKey        = event.altKey;\n    this.shiftKey      = event.shiftKey;\n    this.metaKey       = event.metaKey;\n    this.button        = event.button;\n    this.buttons       = event.buttons;\n    this.target        = element;\n    this.currentTarget = element;\n    this.relatedTarget = related || null;\n    this.type          = action + (phase || '');\n    this.interaction   = interaction;\n    this.interactable  = target;\n\n    this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1]\n                       : prevEvent.t0;\n\n    const signalArg = {\n      interaction,\n      event,\n      action,\n      phase,\n      element,\n      related,\n      page,\n      client,\n      coords,\n      starting,\n      ending,\n      deltaSource,\n      iEvent: this,\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    }\n    else {\n      this.pageX     = page.x;\n      this.pageY     = page.y;\n      this.clientX   = client.x;\n      this.clientY   = client.y;\n    }\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n\n    this.timeStamp = coords.timeStamp;\n    this.dt        = interaction.pointerDelta.timeStamp;\n    this.duration  = this.timeStamp - this.t0;\n\n    // speed and velocity in pixels per second\n    this.speed = interaction.pointerDelta[deltaSource].speed;\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\n    this.swipe = (ending || phase === 'inertiastart')? this.getSwipe() : null;\n\n    signals.fire('new', signalArg);\n  }\n\n  getSwipe () {\n    const interaction = this.interaction;\n\n    if (interaction.prevEvent.speed < 600\n        || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null;\n    }\n\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n    const overlap = 22.5;\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap;\n    const up   = 225 - overlap <= angle && angle < 315 + overlap;\n\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    };\n  }\n\n  preventDefault () {}\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  }\n\n  stopPropagation () {\n    this.propagationStopped = true;\n  }\n}\n\nsignals.on('set-delta', function ({ iEvent, interaction, starting, deltaSource }) {\n  const prevEvent = starting? iEvent : interaction.prevEvent;\n\n  if (deltaSource === 'client') {\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\n  }\n  else {\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n","const isType    = require('./utils/isType');\nconst events    = require('./utils/events');\nconst extend    = require('./utils/extend');\nconst actions   = require('./actions');\nconst scope     = require('./scope');\nconst Eventable = require('./Eventable');\nconst defaults  = require('./defaultOptions');\nconst signals   = require('./utils/Signals').new();\n\nconst { getElementRect, nodeContains } = require('./utils/domUtils');\nconst { indexOf, contains }            = require('./utils/arr');\nconst { wheelEvent }                   = require('./utils/browser');\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\n * Interactable\n [ property ]\n **\n * Object type returned by @interact\n\\*/\nclass Interactable {\n  constructor (target, options) {\n    options = options || {};\n\n    this.target   = target;\n    this.events   = new Eventable();\n    this._context = options.context || scope.document;\n    this._win     = scope.getWindow(isType.trySelector(target)? this._context : target);\n    this._doc     = this._win.document;\n\n    signals.fire('new', {\n      target,\n      options,\n      interactable: this,\n      win: this._win,\n    });\n\n    scope.addDocument( this._doc, this._win );\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  setOnEvents (action, phases) {\n    const onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)       ) { this.events[onAction + 'start'        ] = phases.onstart         ; }\n    if (isType.isFunction(phases.onmove)        ) { this.events[onAction + 'move'         ] = phases.onmove          ; }\n    if (isType.isFunction(phases.onend)         ) { this.events[onAction + 'end'          ] = phases.onend           ; }\n    if (isType.isFunction(phases.oninertiastart)) { this.events[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\n\n    return this;\n  }\n\n  setPerAction (action, options) {\n    // for all the default per-action options\n    for (const option in options) {\n      // if this option exists for this action\n      if (option in defaults[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\n          }\n        }\n        else if (isType.isBool(options[option]) && isType.isObject(defaults.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        }\n        else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  }\n\n  /*\\\n   * Interactable.getRect\n   [ method ]\n   *\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using @Interactable.rectChecker.\n   *\n   - element (Element) #optional The element to measure.\n   = (object) The object's bounding rectangle.\n   o {\n   o     top   : 0,\n   o     left  : 0,\n   o     bottom: 0,\n   o     right : 0,\n   o     width : 0,\n   o     height: 0\n   o }\n  \\*/\n  getRect (element) {\n    element = element || this.target;\n\n    if (isType.isString(this.target) && !(isType.isElement(element))) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  }\n\n  /*\\\n   * Interactable.rectChecker\n   [ method ]\n   *\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n   = (function | object) The checker function or this Interactable\n  \\*/\n  rectChecker (checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  }\n\n  _backCompatOption (optionName, newValue) {\n    if (isType.trySelector(newValue) || isType.isObject(newValue)) {\n      this.options[optionName] = newValue;\n\n      for (const action of actions.names) {\n        this.options[action][optionName] = newValue;\n      }\n\n      return this;\n    }\n\n    return this.options[optionName];\n  }\n\n  /*\\\n   * Interactable.origin\n   [ method ]\n   *\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n   * OR\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\n   **\n   = (object) The current origin or this Interactable\n  \\*/\n  origin (newValue) {\n    return this._backCompatOption('origin', newValue);\n  }\n\n  /*\\\n   * Interactable.deltaSource\n   [ method ]\n   *\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n   = (string | object) The current deltaSource or this Interactable\n  \\*/\n  deltaSource (newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  }\n\n  /*\\\n   * Interactable.context\n   [ method ]\n   *\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\n   *\n   = (Node) The context Node of this Interactable\n   **\n  \\*/\n  context () {\n    return this._context;\n  }\n\n  inContext (element) {\n    return (this._context === element.ownerDocument\n            || nodeContains(this._context, element));\n  }\n\n  /*\\\n   * Interactable.fire\n   [ method ]\n   *\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n   = (Interactable) this Interactable\n  \\*/\n  fire (iEvent) {\n    this.events.fire(iEvent);\n\n    return this;\n  }\n\n  _onOffMultiple (method, eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (let i = 0; i < eventType.length; i++) {\n        this[method](eventType[i], listener, useCapture);\n      }\n\n      return true;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (const prop in eventType) {\n        this[method](prop, eventType[prop], listener);\n      }\n\n      return true;\n    }\n  }\n\n  /*\\\n   * Interactable.on\n   [ method ]\n   *\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   - eventType  (string | array | object) The types of events to listen for\n   - listener   (function) The function event (s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) This Interactable\n  \\*/\n  on (eventType, listener, useCapture) {\n    // convert to boolean\n    useCapture = !!useCapture;\n\n    if (this._onOffMultiple('on', eventType, listener, useCapture)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') { eventType = wheelEvent; }\n\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.on(eventType, listener);\n    }\n    // delegated event for selector\n    else if (isType.isString(this.target)) {\n      events.addDelegate(this.target, this._context, eventType, listener, useCapture);\n    }\n    else {\n      events.add(this.target, eventType, listener, useCapture);\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.off\n   [ method ]\n   *\n   * Removes an InteractEvent, pointerEvent or DOM event listener\n   *\n   - eventType  (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) This Interactable\n  \\*/\n  off (eventType, listener, useCapture) {\n    // convert to boolean\n    useCapture = !!useCapture;\n\n    if (this._onOffMultiple('off', eventType, listener, useCapture)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') { eventType = wheelEvent; }\n\n    // if it is an action event type\n    if (contains(Interactable.eventTypes, eventType)) {\n      this.events.off(eventType, listener);\n    }\n    // delegated event\n    else if (isType.isString(this.target)) {\n      events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\n    }\n    // remove listener from this Interatable's element\n    else {\n      events.remove(this.target, eventType, listener, useCapture);\n    }\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.set\n   [ method ]\n   *\n   * Reset the options of this Interactable\n   - options (object) The new settings to apply\n   = (object) This Interactable\n  \\*/\n  set (options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, defaults.base);\n\n    const perActions = extend({}, defaults.perAction);\n\n    for (const actionName in actions.methodDict) {\n      const methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, defaults[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (const setting of Interactable.settingsMethods) {\n      this.options[setting] = defaults.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    signals.fire('set', {\n      options,\n      interactable: this,\n    });\n\n    return this;\n  }\n\n  /*\\\n   * Interactable.unset\n   [ method ]\n   *\n   * Remove this interactable from the list of interactables and remove\n   * it's action capabilities and event listeners\n   *\n   = (object) @interact\n  \\*/\n  unset () {\n    events.remove(this.target, 'all');\n\n    if (isType.isString(this.target)) {\n      // remove delegated events\n      for (const type in events.delegatedEvents) {\n        const delegated = events.delegatedEvents[type];\n\n        if (delegated.selectors[0] === this.target\n            && delegated.contexts[0] === this._context) {\n\n          delegated.selectors.splice(0, 1);\n          delegated.contexts .splice(0, 1);\n          delegated.listeners.splice(0, 1);\n\n          // remove the arrays if they are empty\n          if (!delegated.selectors.length) {\n            delegated[type] = null;\n          }\n        }\n\n        events.remove(this._context, type, events.delegateListener);\n        events.remove(this._context, type, events.delegateUseCapture, true);\n      }\n    }\n    else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\n\n    // Stop related interactions when an Interactable is unset\n    for (const interaction of scope.interactions || []) {\n      if (interaction.target === this && interaction.interacting()) {\n        interaction.stop();\n      }\n    }\n\n    return scope.interact;\n  }\n}\n\nscope.interactables.indexOfElement = function indexOfElement (target, context) {\n  context = context || scope.document;\n\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    if (interactable.target === target\n        && (!isType.isString(target) || (interactable._context === context))) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet (element, options, dontCheckInContext) {\n  const ret = this[this.indexOfElement(element, options && options.context)];\n\n  return ret && (dontCheckInContext || ret.inContext(element))? ret : null;\n};\n\nscope.interactables.forEachSelector = function (callback, element) {\n  for (let i = 0; i < this.length; i++) {\n    const interactable = this[i];\n\n    // skip non CSS selector targets and out of context elements\n    if (!isType.isString(interactable.target)\n        || (element && !interactable.inContext(element))) {\n      continue;\n    }\n\n    const ret = callback(interactable, interactable.target, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n// all interact.js eventTypes\nInteractable.eventTypes = scope.eventTypes = [];\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = [ 'deltaSource', 'origin', 'preventDefault', 'rectChecker' ];\n\nmodule.exports = Interactable;\n","const scope   = require('./scope');\nconst utils   = require('./utils');\nconst events  = require('./utils/events');\nconst browser = require('./utils/browser');\nconst finder  = require('./utils/interactionFinder');\nconst signals = require('./utils/Signals').new();\n\nconst listeners   = {};\nconst methodNames = [\n  'pointerDown', 'pointerMove', 'pointerUp',\n  'updatePointer', 'removePointer',\n];\n\n// for ignoring browser's simulated mouse events\nlet prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nclass Interaction {\n  constructor () {\n    this.target        = null; // current interactable being interacted with\n    this.element       = null; // the target element of the interactable\n\n    this.prepared      = {     // action that's ready to be fired on next move event\n      name : null,\n      axis : null,\n      edges: null,\n    };\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n    this.holdTimers  = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0,\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0,\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this._interacting    = false;\n\n    this.mouse = false;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  pointerDown (pointer, event, eventTarget) {\n    const pointerIndex = this.updatePointer(pointer);\n\n    this.pointerIsDown = true;\n\n    if (!this.interacting()) {\n      utils.setCoords(this.startCoords, this.pointers);\n\n      utils.copyCoords(this.curCoords , this.startCoords);\n      utils.copyCoords(this.prevCoords, this.startCoords);\n\n      this.downEvent = event;\n\n      this.downTimes[pointerIndex] = this.curCoords.timeStamp;\n      this.downTargets[pointerIndex] = eventTarget;\n\n      this.pointerWasMoved = false;\n\n      utils.pointerExtend(this.downPointer, pointer);\n    }\n\n    signals.fire('down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      interaction: this,\n    });\n  }\n\n  /*\\\n   * Interaction.start\n   [ method ]\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate number\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   - action  (object)  The action to be performed - drag, resize, etc.\n   - target  (Interactable) The Interactable to target\n   - element (Element) The DOM Element to target\n   = (object) interact\n   **\n   | interact(target)\n   |   .draggable({\n   |     // disable the default drag start by down->move\n   |     manualStart: true\n   |   })\n   |   // start dragging after the user holds the pointer down\n   |   .on('hold', function (event) {\n   |     var interaction = event.interaction;\n   |\n   |     if (!interaction.interacting()) {\n   |       interaction.start({ name: 'drag' },\n   |                         event.interactable,\n   |                         event.currentTarget);\n   |     }\n   | });\n   \\*/\n  start (action, target, element) {\n    if (this.interacting()\n        || !this.pointerIsDown\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target         = target;\n    this.element        = element;\n\n    signals.fire('action-start', {\n      interaction: this,\n      event: this.downEvent,\n    });\n  }\n\n  pointerMove (pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.updatePointer(pointer);\n      utils.setCoords(this.curCoords, this.pointers);\n    }\n\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                           && this.curCoords.page.y === this.prevCoords.page.y\n                           && this.curCoords.client.x === this.prevCoords.client.x\n                           && this.curCoords.client.y === this.prevCoords.client.y);\n\n    let dx;\n    let dy;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n    }\n\n    const signalArg = {\n      pointer,\n      pointerIndex: this.getPointerIndex(pointer),\n      event,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this,\n      interactingBeforeMove: this.interacting(),\n    };\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n    }\n\n    signals.fire('move', signalArg);\n\n    if (!duplicateMove) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        this.doMove(signalArg);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n    }\n  }\n\n  /*\\\n   * Interaction.doMove\n   [ method ]\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   *\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('dragmove', function (event) {\n   |     if (someCondition) {\n   |       // change the snap settings\n   |       event.interactable.draggable({ snap: { targets: [] }});\n   |       // fire another move event with re-calculated snap\n   |       event.interaction.doMove();\n   |     }\n   |   });\n   \\*/\n  doMove (signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this,\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('action-move', signalArg);\n    }\n\n    this._dontFireMove = false;\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\n    const pointerIndex = this.getPointerIndex(pointer);\n\n    signals.fire(/cancel$/i.test(event.type)? 'cancel' : 'up', {\n      pointer,\n      pointerIndex,\n      event,\n      eventTarget,\n      curEventTarget,\n      interaction: this,\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n    }\n\n    this.pointerIsDown = false;\n    this.removePointer(pointer);\n  }\n\n  /*\\\n   * Interaction.end\n   [ method ]\n   *\n   * Stop the current action and fire an end event. Inertial movement does\n   * not happen.\n   *\n   - event (PointerEvent) #optional\n   **\n   | interact(target)\n   |   .draggable(true)\n   |   .on('move', function (event) {\n   |     if (event.pageX > 1000) {\n   |       // end the current action\n   |       event.interaction.end();\n   |       // stop all further listeners from being called\n   |       event.stopImmediatePropagation();\n   |     }\n   |   });\n   \\*/\n  end (event) {\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event,\n        interaction: this,\n      });\n    }\n\n    this.stop();\n  }\n\n  currentAction () {\n    return this._interacting? this.prepared.name: null;\n  }\n\n  interacting () {\n    return this._interacting;\n  }\n\n  stop () {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  }\n\n  getPointerIndex (pointer) {\n    return this.mouse? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n  }\n\n  updatePointer (pointer) {\n    const id = utils.getPointerId(pointer);\n    let index = this.getPointerIndex(pointer);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  }\n\n  removePointer (pointer) {\n    const id = utils.getPointerId(pointer);\n    const index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) { return; }\n\n    this.pointers   .splice(index, 1);\n    this.pointerIds .splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes  .splice(index, 1);\n    this.holdTimers .splice(index, 1);\n  }\n\n  _updateEventTargets (target, currentTarget) {\n    this._eventTarget    = target;\n    this._curEventTarget = currentTarget;\n  }\n}\n\nfor (let i = 0, len = methodNames.length; i < len; i++) {\n  const method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions (method) {\n  return (function (event) {\n    const eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    const curEventTarget = utils.getActualElement(event.currentTarget);\n    const matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (let i = 0; i < event.changedTouches.length; i++) {\n        const pointer = event.changedTouches[i];\n        const interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction()]);\n      }\n    }\n    else {\n      let invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || (new Date().getTime() - prevTouchTime < 500);\n      }\n\n      if (!invalidPointer) {\n        let interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = (/mouse/i.test(event.pointerType || event.type)\n                               // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                               || event.pointerType === 4\n                               || !event.pointerType);\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (const [pointer, interaction] of matches) {\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  });\n}\n\nfunction endAll (event) {\n  for (let i = 0; i < scope.interactions.length; i++) {\n    const interaction = scope.interactions[i];\n\n    interaction.end(event);\n    signals.fire('endall', { event, interaction });\n  }\n}\n\nconst docEvents = { /* 'eventType': listenerFunc */ };\nconst pEventTypes = browser.pEventTypes;\n\nif (scope.PointerEvent) {\n  docEvents[pEventTypes.down  ] = listeners.pointerDown;\n  docEvents[pEventTypes.move  ] = listeners.pointerMove;\n  docEvents[pEventTypes.up    ] = listeners.pointerUp;\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\n}\nelse {\n  docEvents.mousedown   = listeners.pointerDown;\n  docEvents.mousemove   = listeners.pointerMove;\n  docEvents.mouseup     = listeners.pointerUp;\n\n  docEvents.touchstart  = listeners.pointerDown;\n  docEvents.touchmove   = listeners.pointerMove;\n  docEvents.touchend    = listeners.pointerUp;\n  docEvents.touchcancel = listeners.pointerUp;\n}\n\ndocEvents.blur = endAll;\n\nfunction onDocSignal ({ doc }, signalName) {\n  const eventMethod = signalName.indexOf('add') === 0\n    ? events.add : events.remove;\n\n  // delegate event listener\n  for (const eventType in scope.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener);\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  for (const eventType in docEvents) {\n    eventMethod(doc, eventType, docEvents[eventType]);\n  }\n}\n\nscope.signals.on('add-document'   , onDocSignal);\nscope.signals.on('remove-document', onDocSignal);\n\nInteraction.pointerMoveTolerance = 1;\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.endAll = endAll;\nInteraction.signals = signals;\nInteraction.docEvents = docEvents;\n\nscope.endAllInteractions = endAll;\n\nmodule.exports = Interaction;\n","const actions        = require('./index');\nconst utils          = require('../utils');\nconst InteractEvent  = require('../InteractEvent');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drag = {\n  defaults: {\n    enabled     : false,\n    mouseButtons: null,\n\n    origin    : null,\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    startAxis : 'xy',\n    lockAxis  : 'xy',\n  },\n\n  checker: function (pointer, event, interactable) {\n    const dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled\n      ? { name: 'drag', axis: (dragOptions.lockAxis === 'start'\n                               ? dragOptions.startAxis\n                               : dragOptions.lockAxis)}\n      : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  },\n};\n\nInteraction.signals.on('before-action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y   = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy   = 0;\n  }\n  else if (axis === 'y') {\n    interaction.curCoords.page.x   = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx   = 0;\n  }\n});\n\n// dragmove\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'dragmove') { return; }\n\n  const axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    iEvent.pageY   = interaction.startCoords.page.y;\n    iEvent.clientY = interaction.startCoords.client.y;\n    iEvent.dy = 0;\n  }\n  else if (axis === 'y') {\n    iEvent.pageX   = interaction.startCoords.page.x;\n    iEvent.clientX = interaction.startCoords.client.x;\n    iEvent.dx = 0;\n  }\n});\n\n/*\\\n * Interactable.draggable\n [ method ]\n *\n * Gets or sets whether drag actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of drag events\n | var isDraggable = interact('ul li').draggable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n = (object) This Interactable\n | interact(element).draggable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // the axis in which the first movement must be\n |     // for the drag sequence to start\n |     // 'xy' by default - any direction\n |     startAxis: 'x' || 'y' || 'xy',\n |\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\n |     // 'x' or 'y' to restrict movement to either axis\n |     // 'start' to restrict movement to the axis the drag started in\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\n |\n |     // max number of drags that can happen concurrently\n |     // with elements of this Interactable. Infinity by default\n |     max: Infinity,\n |\n |     // max number of drags that can target the same element+Interactable\n |     // 1 by default\n |     maxPerElement: 2\n | });\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false? false: true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    if (!options) {\n      this.ondragstart = this.ondragstart = this.ondragend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(Interactable.eventTypes, [\n  'dragstart',\n  'dragmove',\n  'draginertiastart',\n  'draginertiaresume',\n  'dragend',\n]);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n","const actions        = require('./index');\nconst utils          = require('../utils');\nconst scope          = require('../scope');\nconst interact       = require('../interact');\nconst InteractEvent  = require('../InteractEvent');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst drop = {\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  },\n};\n\nlet dynamicDrop = false;\n\nInteraction.signals.on('action-start', function ({ interaction, event }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements  = [];\n  interaction.activeDrops.rects     = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction, interaction.element);\n  }\n\n  const dragEvent = interaction.prevEvent;\n  const dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new', function ({ interaction, iEvent, event }) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return; }\n\n  const draggableElement = interaction.element;\n  const dragEvent = iEvent;\n  const dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget  = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('action-move', function ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function ({ interaction }) {\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function ({ interaction }) {\n  interaction.activeDrops.dropzones =\n    interaction.activeDrops.elements =\n    interaction.activeDrops.rects =\n    interaction.dropEvents = null;\n});\n\nfunction collectDrops (interaction, element) {\n  const drops = [];\n  const elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const current of scope.interactables) {\n    if (!current.options.drop.enabled) { continue; }\n\n    const accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if ((utils.isElement(accept) && accept !== element)\n        || (utils.isString(accept)\n        && !utils.matchesSelector(element, accept))) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.isString(current.target)\n      ? current._context.querySelectorAll(current.target)\n      : [current.target];\n\n    for (let i = 0; i < dropElements.length; i++) {\n      const currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements,\n    dropzones: drops,\n  };\n}\n\nfunction fireActiveDrops (interaction, event) {\n  let prevElement;\n\n  // loop through all active dropzones and trigger event\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    const current = interaction.activeDrops.dropzones[i];\n    const currentElement = interaction.activeDrops.elements [i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops (interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  const possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements  = possibleDrops.elements;\n  interaction.activeDrops.rects     = [];\n\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] =\n      interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop (dragEvent, event, dragElement) {\n  const interaction = dragEvent.interaction;\n  const validDrops = [];\n\n  if (dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    const current        = interaction.activeDrops.dropzones[j];\n    const currentElement = interaction.activeDrops.elements [j];\n    const rect           = interaction.activeDrops.rects    [j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\n      ? currentElement\n      : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element : interaction.activeDrops.elements [dropIndex] || null,\n  };\n}\n\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  };\n\n  const tmpl = {\n    dragEvent,\n    interaction,\n    target       : interaction.dropElement,\n    dropzone     : interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable    : dragEvent.interactable,\n    timeStamp    : dragEvent.timeStamp,\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent,\n        interaction,\n        target       : interaction.dropElement,\n        dropzone     : interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable    : dragEvent.interactable,\n        timeStamp    : dragEvent.timeStamp,\n        type         : 'dragenter',\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n    dragEvent.relatedTarget = interaction.dropElement;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target   = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target   = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove     : dragEvent,\n      type         : 'dropmove',\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents (interaction, dropEvents) {\n  if (dropEvents.leave) { interaction.prevDropTarget.fire(dropEvents.leave); }\n  if (dropEvents.move ) {     interaction.dropTarget.fire(dropEvents.move ); }\n  if (dropEvents.enter) {     interaction.dropTarget.fire(dropEvents.enter); }\n  if (dropEvents.drop ) {     interaction.dropTarget.fire(dropEvents.drop ); }\n  if (dropEvents.move ) {     interaction.dropTarget.fire(dropEvents.move ); }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(interaction, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget  = interaction.dropTarget;\n  interaction.prevDropElement = interaction.dropElement;\n}\n\n/*\\\n * Interactable.dropzone\n [ method ]\n *\n * Returns or sets whether elements can be dropped onto this\n * Interactable to trigger drop events\n *\n * Dropzones can receive the following events:\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n *  - `dragmove` when a draggable that has entered the dropzone is moved\n *  - `drop` when a draggable is dropped into this dropzone\n *\n * Use the `accept` option to allow only elements that match the given CSS\n * selector or element. The value can be:\n *\n *  - **an Element** - only that element can be dropped into this dropzone.\n *  - **a string**, - the element being dragged must match it as a CSS selector.\n *  - **`null`** - accept options is cleared - it accepts any element.\n *\n * Use the `overlap` option to set how drops are checked for. The allowed\n * values are:\n *\n *   - `'pointer'`, the pointer must be over the dropzone (default)\n *   - `'center'`, the draggable element's center must be over the dropzone\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n *   over the dropzone\n *\n * Use the `checker` option to specify a function to check if a dragged\n * element is over this Interactable.\n *\n | interact(target)\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\n |                       dropped,           // bool result of the default checker\n |                       dropzone,          // dropzone Interactable\n |                       dropElement,       // dropzone elemnt\n |                       draggable,         // draggable Interactable\n |                       draggableElement) {// draggable element\n |\n |   return dropped && event.target.hasAttribute('allow-drop');\n | }\n *\n *\n - options (boolean | object | null) #optional The new value to be set.\n | interact('.drop').dropzone({\n |   accept: '.can-drop' || document.getElementById('single-drop'),\n |   overlap: 'pointer' || 'center' || zeroToOne\n | }\n = (boolean | object) The current setting or this Interactable\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false? false: true;\n\n    if (utils.isFunction(options.ondrop)          ) { this.events.ondrop           = options.ondrop          ; }\n    if (utils.isFunction(options.ondropactivate)  ) { this.events.ondropactivate   = options.ondropactivate  ; }\n    if (utils.isFunction(options.ondropdeactivate)) { this.events.ondropdeactivate = options.ondropdeactivate; }\n    if (utils.isFunction(options.ondragenter)     ) { this.events.ondragenter      = options.ondragenter     ; }\n    if (utils.isFunction(options.ondragleave)     ) { this.events.ondragleave      = options.ondragleave     ; }\n    if (utils.isFunction(options.ondropmove)      ) { this.events.ondropmove       = options.ondropmove      ; }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    }\n    else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    if (!options) {\n      this.ondragenter = this.ondragleave = this.ondrop\n        = this.ondropactivate = this.ondropdeactivate = null;\n    }\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  let dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return (this.options.drop.checker\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n      : false);\n  }\n\n  const dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement, 'drag');\n    const page = utils.getPageXY(dragEvent);\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    const horizontal = (page.x > rect.left) && (page.x < rect.right);\n    const vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n    dropped = horizontal && vertical;\n  }\n\n  const dragRect = draggable.getRect(draggableElement);\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2;\n    const cy = dragRect.top  + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (dragRect && utils.isNumber(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function ({ interactable }) {\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement     = null; // the element at the time of checking\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents      = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [],      // the dropzones that are mentioned below\n    elements : [],      // elements of dropzones that accept the target draggable\n    rects    : [],      // the rects of the elements mentioned above\n  };\n\n});\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  interaction.dropTarget = interaction.dropElement =\n    interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\n/*\\\n * interact.dynamicDrop\n [ method ]\n *\n * Returns or sets whether the dimensions of dropzone elements are\n * calculated on every dragmove or only on dragstart for the default\n * dropChecker\n *\n - newValue (boolean) #optional True to check on each move. False to check only before start\n = (boolean | interact) The current setting or interact\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n    //}\n\n    dynamicDrop = newValue;\n\n    return interact;\n  }\n  return dynamicDrop;\n};\n\nutils.merge(Interactable.eventTypes, [\n  'dragenter',\n  'dragleave',\n  'dropactivate',\n  'dropdeactivate',\n  'dropmove',\n  'drop',\n]);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n","const actions        = require('./index');\nconst utils          = require('../utils');\nconst InteractEvent  = require('../InteractEvent');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\nconst gesture = {\n  defaults: {\n    enabled : false,\n    origin  : null,\n    restrict: null,\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  },\n};\n\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'gesturestart') { return; }\n  iEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.scale = 1;\n});\n\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'gesturemove') { return; }\n\n  iEvent.ds = iEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(iEvent);\n\n  interaction.gesture.prevAngle = iEvent.angle;\n  interaction.gesture.prevDistance = iEvent.distance;\n\n  if (iEvent.scale !== Infinity\n      && iEvent.scale !== null\n      && iEvent.scale !== undefined\n      && !isNaN(iEvent.scale)) {\n\n    interaction.gesture.scale = iEvent.scale;\n  }\n});\n\n/*\\\n * Interactable.gesturable\n [ method ]\n *\n * Gets or sets whether multitouch gestures can be performed on the\n * Interactable's element\n *\n = (boolean) Indicates if this can be the target of gesture events\n   | var isGestureable = interact(element).gesturable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n = (object) this Interactable\n | interact(element).gesturable({\n |     onstart: function (event) {},\n |     onmove : function (event) {},\n |     onend  : function (event) {},\n |\n |     // limit multiple gestures.\n |     // See the explanation in @Interactable.draggable example\n |     max: Infinity,\n |     maxPerElement: 1,\n | });\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false? false: true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    if (!options) {\n      this.ongesturestart = this.ongesturestart = this.ongestureend = null;\n    }\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action, event, starting, ending, deltaSource }) {\n  if (action !== 'gesture') { return; }\n\n  const pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = 1;\n    iEvent.ds       = 0;\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da       = 0;\n  }\n  else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box      = interaction.prevEvent.box;\n    iEvent.scale    = interaction.prevEvent.scale;\n    iEvent.ds       = iEvent.scale - 1;\n    iEvent.angle    = interaction.prevEvent.angle;\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\n  }\n  else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box      = utils.touchBBox(pointers);\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0,   // distance between two touches of touchStart\n    prevDistance : 0,\n    distance     : 0,\n\n    scale: 1,           // gesture.distance / gesture.startDistance\n\n    startAngle: 0,      // angle of line joining two touches\n    prevAngle : 0,      // angle of the previous gesture event\n  };\n});\n\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(Interactable.eventTypes, [\n  'gesturestart',\n  'gesturemove',\n  'gestureend',\n]);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n","const Interaction   = require('../Interaction');\nconst InteractEvent = require('../InteractEvent');\n\nconst actions = {\n  firePrepared,\n  names: [],\n  methodDict: {},\n};\n\nInteraction.signals.on('action-start', function ({ interaction, event }) {\n  firePrepared(interaction, event, 'start');\n  interaction._interacting = true;\n});\n\nInteraction.signals.on('action-move', function ({ interaction, event }) {\n  firePrepared(interaction, event, 'move');\n\n  // if the action was ended in a listener\n  if (!interaction.interacting()) { return false; }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  firePrepared(interaction, event, 'end');\n});\n\nfunction firePrepared (interaction, event, phase) {\n  const actionName = interaction.prepared.name;\n\n  const newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element);\n\n  interaction.target.fire(newEvent);\n  interaction.prevEvent = newEvent;\n}\n\nmodule.exports = actions;\n","const actions        = require('./index');\nconst utils          = require('../utils');\nconst browser        = require('../utils/browser');\nconst InteractEvent  = require('../InteractEvent');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst defaultOptions = require('../defaultOptions');\n\n// Less Precision with touch input\nconst defaultMargin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\n\nconst resize = {\n  defaults: {\n    enabled     : false,\n    mouseButtons: null,\n\n    origin    : null,\n    snap      : null,\n    restrict  : null,\n    inertia   : null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) { return null; }\n\n    const page = utils.extend({}, interaction.curCoords.page);\n    const options = interactable.options;\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize;\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n                                              resizeOptions.edges[edge],\n                                              page,\n                                              interaction._eventTarget,\n                                              element,\n                                              rect,\n                                              resizeOptions.margin || defaultMargin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges,\n          };\n        }\n      }\n      else {\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - defaultMargin);\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - defaultMargin);\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: (browser.isIe9OrOlder ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  }),\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    }\n    else if (action.edges) {\n      let cursorKey = '';\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (let i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  },\n};\n\n// resizestart\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\n  if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\n    return;\n  }\n\n  const startRect = interaction.target.getRect(interaction.element);\n  const resizeOptions = interaction.target.options.resize;\n\n  /*\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n   * on the active edges and the edge being interacted with.\n   */\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n    const linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n    interaction.prepared._linkedEdges = linkedEdges;\n  }\n  else {\n    interaction.prepared._linkedEdges = null;\n  }\n\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n  if (resizeOptions.preserveAspectRatio) {\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n  }\n\n  interaction.resizeRects = {\n    start     : startRect,\n    current   : utils.extend({}, startRect),\n    inverted  : utils.extend({}, startRect),\n    previous  : utils.extend({}, startRect),\n    delta     : {\n      left: 0, right : 0, width : 0,\n      top : 0, bottom: 0, height: 0,\n    },\n  };\n\n  iEvent.rect = interaction.resizeRects.inverted;\n  iEvent.deltaRect = interaction.resizeRects.delta;\n});\n\n// resizemove\nInteractEvent.signals.on('new', function ({ iEvent, phase, interaction }) {\n  if (phase !== 'move' || !interaction.prepared.edges) { return; }\n\n  const resizeOptions = interaction.target.options.resize;\n  const invert = resizeOptions.invert;\n  const invertible = invert === 'reposition' || invert === 'negate';\n\n  let edges = interaction.prepared.edges;\n\n  const start      = interaction.resizeRects.start;\n  const current    = interaction.resizeRects.current;\n  const inverted   = interaction.resizeRects.inverted;\n  const delta      = interaction.resizeRects.delta;\n  const previous   = utils.extend(interaction.resizeRects.previous, inverted);\n  const originalEdges = edges;\n\n  let dx = iEvent.dx;\n  let dy = iEvent.dy;\n\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\n    const startAspectRatio = resizeOptions.preserveAspectRatio\n      ? interaction.resizeStartAspectRatio\n      : 1;\n\n    edges = interaction.prepared._linkedEdges;\n\n    if ((originalEdges.left && originalEdges.bottom)\n        || (originalEdges.right && originalEdges.top)) {\n      dy = -dx / startAspectRatio;\n    }\n    else if (originalEdges.left || originalEdges.right ) { dy = dx / startAspectRatio; }\n    else if (originalEdges.top  || originalEdges.bottom) { dx = dy * startAspectRatio; }\n  }\n\n  // update the 'current' rect without modifications\n  if (edges.top   ) { current.top    += dy; }\n  if (edges.bottom) { current.bottom += dy; }\n  if (edges.left  ) { current.left   += dx; }\n  if (edges.right ) { current.right  += dx; }\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    utils.extend(inverted, current);\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      let swap;\n\n      if (inverted.top > inverted.bottom) {\n        swap = inverted.top;\n\n        inverted.top = inverted.bottom;\n        inverted.bottom = swap;\n      }\n      if (inverted.left > inverted.right) {\n        swap = inverted.left;\n\n        inverted.left = inverted.right;\n        inverted.right = swap;\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    inverted.top    = Math.min(current.top, start.bottom);\n    inverted.bottom = Math.max(current.bottom, start.top);\n    inverted.left   = Math.min(current.left, start.right);\n    inverted.right  = Math.max(current.right, start.left);\n  }\n\n  inverted.width  = inverted.right  - inverted.left;\n  inverted.height = inverted.bottom - inverted.top ;\n\n  for (const edge in inverted) {\n    delta[edge] = inverted[edge] - previous[edge];\n  }\n\n  iEvent.edges = interaction.prepared.edges;\n  iEvent.rect = inverted;\n  iEvent.deltaRect = delta;\n});\n\n/*\\\n * Interactable.resizable\n [ method ]\n *\n * Gets or sets whether resize actions can be performed on the\n * Interactable\n *\n = (boolean) Indicates if this can be the target of resize elements\n   | var isResizeable = interact('input[type=text]').resizable();\n * or\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n = (object) This Interactable\n   | interact(element).resizable({\n   |   onstart: function (event) {},\n   |   onmove : function (event) {},\n   |   onend  : function (event) {},\n   |\n   |   edges: {\n   |     top   : true,       // Use pointer coords to check for resize.\n   |     left  : false,      // Disable resizing from left edge.\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\n   |     right : handleEl    // Resize if pointer target is the given Element\n   |   },\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height are adjusted at a 1:1 ratio.\n   |     square: false,\n   |\n   |     // Width and height can be adjusted independently. When `true`, width and\n   |     // height maintain the aspect ratio they had when resizing started.\n   |     preserveAspectRatio: false,\n   |\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   |   // 'negate' will allow the rect to have negative width/height\n   |   // 'reposition' will keep the width/height positive by swapping\n   |   // the top and bottom edges and/or swapping the left and right edges\n   |   invert: 'none' || 'negate' || 'reposition'\n   |\n   |   // limit multiple resizes.\n   |   // See the explanation in the @Interactable.draggable example\n   |   max: Infinity,\n   |   maxPerElement: 1,\n   | });\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false? false: true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    }\n    else if (options.axis === null) {\n      this.options.resize.axis = defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    }\n    else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    if (!options) {\n      this.onresizestart = this.onresizestart = this.onresizeend = null;\n    }\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) { return false; }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = utils.isNumber(rect.width )? rect.width  : rect.right  - rect.left;\n    const height = utils.isNumber(rect.height)? rect.height : rect.bottom - rect.top ;\n\n    if (width < 0) {\n      if      (name === 'left' ) { name = 'right'; }\n      else if (name === 'right') { name = 'left' ; }\n    }\n    if (height < 0) {\n      if      (name === 'top'   ) { name = 'bottom'; }\n      else if (name === 'bottom') { name = 'top'   ; }\n    }\n\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) { return false; }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action }) {\n  if (action !== 'resize' || !interaction.resizeAxes) { return; }\n\n  const options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    }\n    else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    }\n    else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(Interactable.eventTypes, [\n  'resizestart',\n  'resizemove',\n  'resizeinertiastart',\n  'resizeinertiaresume',\n  'resizeend',\n]);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n","const raf            = require('./utils/raf');\nconst getWindow      = require('./utils/window').getWindow;\nconst isWindow       = require('./utils/isType').isWindow;\nconst domUtils       = require('./utils/domUtils');\nconst Interaction    = require('./Interaction');\nconst defaultOptions = require('./defaultOptions');\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    container: null,     // the item that is scrolled (Window or HTMLElement)\n    margin   : 60,\n    speed    : 300,      // the scroll speed in pixels per second\n  },\n\n  interaction: null,\n  i: null,    // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(autoScroll.interaction.element);\n    const now = new Date().getTime();\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    const s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      }\n      else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop  += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    const options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function ({ interaction, pointer }) {\n    if (!(interaction.interacting()\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\n    const container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left   = pointer.clientX < autoScroll.margin;\n      top    = pointer.clientY < autoScroll.margin;\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container);\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = (right ? 1: left? -1: 0);\n    autoScroll.y = (bottom? 1:  top? -1: 0);\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed  = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  },\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n","const Interactable = require('../Interactable');\nconst actions      = require('../actions');\nconst isType       = require('../utils/isType');\nconst domUtils     = require('../utils/domUtils');\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\n * Interactable.ignoreFrom\n [ method ]\n *\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\n * event or any of it's parents match the given CSS selector or\n * Element, no drag/resize/gesture is started.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n = (string | Element | object) The current ignoreFrom value or this Interactable\n **\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\n | // or\n | interact(element).ignoreFrom('input, textarea, a');\n\\*/\nInteractable.prototype.ignoreFrom = function (newValue) {\n  return this._backCompatOption('ignoreFrom', newValue);\n};\n\n/*\\\n * Interactable.allowFrom\n [ method ]\n *\n * A drag/resize/gesture is started only If the target of the\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n * parents match the given CSS selector or Element.\n *\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n = (string | Element | object) The current allowFrom value or this Interactable\n **\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\n | // or\n | interact(element).allowFrom('.handle');\n\\*/\nInteractable.prototype.allowFrom = function (newValue) {\n  return this._backCompatOption('allowFrom', newValue);\n};\n\nInteractable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\n  if (!ignoreFrom || !isType.isElement(element)) { return false; }\n\n  if (isType.isString(ignoreFrom)) {\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\n  }\n  else if (isType.isElement(ignoreFrom)) {\n    return domUtils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testAllow = function (allowFrom, interactableElement, element) {\n  if (!allowFrom) { return true; }\n\n  if (!isType.isElement(element)) { return false; }\n\n  if (isType.isString(allowFrom)) {\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement);\n  }\n  else if (isType.isElement(allowFrom)) {\n    return domUtils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n};\n\nInteractable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\n  return (!this.testIgnore(options.ignoreFrom, interactableElement, eventTarget)\n    && this.testAllow(options.allowFrom, interactableElement, eventTarget));\n};\n\n/*\\\n * Interactable.actionChecker\n [ method ]\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n = (Function | Interactable) The checker function or this Interactable\n *\n | interact('.resize-drag')\n |   .resizable(true)\n |   .draggable(true)\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n |\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\n |     // force drag with handle target\n |     action.name = drag;\n |   }\n |   else {\n |     // resize from the top and right edges\n |     action.name  = 'resize';\n |     action.edges = { top: true, right: true };\n |   }\n |\n |   return action;\n | });\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (isType.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\n * Interactable.styleCursor\n [ method ]\n *\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n - newValue (boolean) #optional\n = (boolean | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (isType.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  const rect = this.getRect(element);\n  let action = null;\n\n  for (const actionName of actions.names) {\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown\n        && interaction.mouse\n        && (event.buttons & this.options[actionName].mouseButtons) === 0) {\n      continue;\n    }\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\n","const autoStart   = require('./index');\nconst Interaction = require('../Interaction');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.delayTimer = null;\n});\n\nautoStart.signals.on('prepared', function ({ interaction }) {\n  const actionName = interaction.prepared.name;\n\n  if (!actionName) { return; }\n\n  const delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.delayTimer = setTimeout(() => {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, delay);\n  }\n});\n\nInteraction.signals.on('move', function ({ interaction, duplicate }) {\n  if (interaction.pointerWasMoved && !duplicate) {\n    clearTimeout(interaction.delayTimer);\n  }\n});\n\n// prevent regular down->move autoStart\nautoStart.signals.on('before-start', function ({ interaction }) {\n  const actionName = interaction.prepared.name;\n\n  if (!actionName) { return; }\n\n  const delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.prepared.name = null;\n  }\n});\n","const autoStart = require('./index');\nconst scope     = require('../scope');\nconst browser   = require('../utils/browser');\n\nconst { isElement } = require('../utils/isType');\nconst { matchesSelector, parentNode } = require('../utils/domUtils');\n\nrequire('./index').setActionDefaults(require('../actions/drag'));\n\nautoStart.signals.on('before-start',  function ({ interaction, eventTarget, dx, dy }) {\n  if (interaction.prepared.name !== 'drag') { return; }\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx);\n  const absY = Math.abs(dy);\n  const options = interaction.target.options.drag;\n  const startAxis = options.startAxis;\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n  interaction.prepared.axis = options.lockAxis === 'start'\n    ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n    : options.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n\n    if (!interaction.prepared.name) {\n\n      let element = eventTarget;\n\n      const getDraggable = function (interactable, selector, context) {\n        const elements = browser.useMatchesSelectorPolyfill\n            ? context.querySelectorAll(selector)\n            : undefined;\n\n        if (interactable === interaction.target) { return; }\n\n        if (!options.manualStart\n            && !interactable.testIgnoreAllow(options, element, eventTarget)\n            && matchesSelector(element, selector, elements)) {\n\n          const action = interactable.getAction(interaction.downPointer,\n                                                interaction.downEvent,\n                                                interaction,\n                                                element);\n\n          if (action\n              && action.name === 'drag'\n              && checkStartAxis(currentAxis, interactable)\n              && autoStart.validateAction(action, interactable, element, eventTarget)) {\n\n            return interactable;\n          }\n        }\n      };\n\n      let action = null;\n\n      // check all interactables\n      while (isElement(element)) {\n        const elementInteractable = scope.interactables.get(element);\n\n        if (elementInteractable\n            && elementInteractable !== interaction.target\n            && !elementInteractable.options.drag.manualStart) {\n\n          action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n        }\n        if (action\n            && action.name === 'drag'\n            && checkStartAxis(currentAxis, elementInteractable)) {\n\n          interaction.prepared.name = 'drag';\n          interaction.target = elementInteractable;\n          interaction.element = element;\n          break;\n        }\n\n        const selectorInteractable = scope.interactables.forEachSelector(getDraggable, element);\n\n        if (selectorInteractable) {\n          interaction.prepared.name = 'drag';\n          interaction.target = selectorInteractable;\n          interaction.element = element;\n          break;\n        }\n\n        element = parentNode(element);\n      }\n    }\n  }\n});\n\nfunction checkStartAxis (startAxis, interactable) {\n  if (!interactable) { return false; }\n\n  const thisAxis = interactable.options.drag.startAxis;\n\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis);\n}\n","require('./index').setActionDefaults(require('../actions/gesture'));\n","const interact       = require('../interact');\nconst Interactable   = require('../Interactable');\nconst Interaction    = require('../Interaction');\nconst actions        = require('../actions');\nconst defaultOptions = require('../defaultOptions');\nconst browser        = require('../utils/browser');\nconst scope          = require('../scope');\nconst utils          = require('../utils');\nconst signals        = require('../utils/Signals').new();\n\nrequire('./InteractableMethods');\n\nconst autoStart = {\n  signals,\n  withinInteractionLimit,\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: Infinity,\n  defaults: {\n    perAction: {\n      manualStart: false,\n      max: Infinity,\n      maxPerElement: 1,\n      allowFrom:  null,\n      ignoreFrom: null,\n    },\n  },\n  setActionDefaults: function (action) {\n    utils.extend(action.defaults, autoStart.defaults.perAction);\n  },\n};\n\n// set cursor style on mousedown\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget }) {\n  if (interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\n// set cursor style on mousemove\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget }) {\n  if (!interaction.mouse\n      || interaction.pointerIsDown\n      || interaction.interacting()) { return; }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  const { interaction, event } = arg;\n\n  if (!interaction.pointerIsDown\n      || interaction.interacting()\n      || !interaction.pointerWasMoved\n      || !interaction.prepared.name) {\n    return;\n  }\n\n  signals.fire('before-start', arg);\n\n  const target = interaction.target;\n\n  if (interaction.prepared.name && target) {\n    // check manualStart and interaction limit\n    if (target.options[interaction.prepared.name].manualStart\n        || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n      interaction.stop(event);\n    }\n    else {\n      interaction.start(interaction.prepared, target, interaction.element);\n    }\n  }\n});\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (action, interactable, element, eventTarget) {\n  if (utils.isObject(action)\n      && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget)\n      && interactable.options[action.name].enabled\n      && withinInteractionLimit(interactable, element, action)) {\n    return action;\n  }\n\n  return null;\n}\n\nfunction validateSelector (interaction, pointer, event, matches, matchElements, eventTarget) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i];\n    const matchElement = matchElements[i];\n    const action = validateAction(match.getAction(pointer, event, interaction, matchElement),\n                                  match,\n                                  matchElement,\n                                  eventTarget);\n\n    if (action) {\n      return {\n        action,\n        target: match,\n        element: matchElement,\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo (interaction, pointer, event, eventTarget) {\n  let matches = [];\n  let matchElements = [];\n\n  let element = eventTarget;\n  let action = null;\n\n  function pushMatches (interactable, selector, context) {\n    const elements = (browser.useMatchesSelectorPolyfill\n      ? context.querySelectorAll(selector)\n      : undefined);\n\n    if (utils.matchesSelector(element, selector, elements)) {\n\n      matches.push(interactable);\n      matchElements.push(element);\n    }\n  }\n\n  while (utils.isElement(element)) {\n    matches = [];\n    matchElements = [];\n\n    const elementInteractable = scope.interactables.get(element);\n\n    if (elementInteractable\n        && (action = validateAction(elementInteractable.getAction(pointer, event, interaction, element, eventTarget),\n                                    elementInteractable,\n                                    element,\n                                    eventTarget))\n        && !elementInteractable.options[action.name].manualStart) {\n      return {\n        element,\n        action,\n        target: elementInteractable,\n      };\n    }\n    else {\n      scope.interactables.forEachSelector(pushMatches, element);\n\n      const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\n\n      if (actionInfo.action\n          && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n        return actionInfo;\n      }\n    }\n\n    element = utils.parentNode(element);\n  }\n\n  return {};\n}\n\nfunction prepare (interaction, { action, target, element }) {\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    interaction.target._doc.documentElement.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    const cursor = action? actions[action.name].getCursor(action) : '';\n    interaction.target._doc.documentElement.style.cursor = cursor;\n  }\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteraction.signals.on('stop', function ({ interaction }) {\n  const target = interaction.target;\n\n  if (target && target.options.styleCursor) {\n    target._doc.documentElement.style.cursor = '';\n  }\n});\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\n * Interactable.actionChecker\n [ method ]\n *\n * Gets or sets the function used to check action to be performed on\n * pointerDown\n *\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n = (Function | Interactable) The checker function or this Interactable\n *\n | interact('.resize-drag')\n |   .resizable(true)\n |   .draggable(true)\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n |\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\n |     // force drag with handle target\n |     action.name = drag;\n |   }\n |   else {\n |     // resize from the top and right edges\n |     action.name  = 'resize';\n |     action.edges = { top: true, right: true };\n |   }\n |\n |   return action;\n | });\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (utils.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\n * Interactable.styleCursor\n [ method ]\n *\n * Returns or sets whether the the cursor should be changed depending on the\n * action that would be performed if the mouse were pressed and dragged.\n *\n - newValue (boolean) #optional\n = (boolean | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (utils.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  const rect = this.getRect(element);\n  const buttons = event.buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16,\n  })[event.button];\n  let action = null;\n\n  for (const actionName of actions.names) {\n    // check mouseButton setting if the pointer is down\n    if (interaction.pointerIsDown\n        && interaction.mouse\n        && (buttons & this.options[actionName].mouseButtons) === 0) {\n      continue;\n    }\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\nfunction withinInteractionLimit (interactable, element, action) {\n  const options = interactable.options;\n  const maxActions = options[action.name].max;\n  const maxPerElement = options[action.name].maxPerElement;\n  let activeInteractions = 0;\n  let targetCount = 0;\n  let targetElementCount = 0;\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) { return; }\n\n  for (let i = 0, len = scope.interactions.length; i < len; i++) {\n    const interaction = scope.interactions[i];\n    const otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) { continue; }\n\n    activeInteractions++;\n\n    if (activeInteractions >= autoStart.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) { continue; }\n\n    targetCount += (otherAction === action.name)|0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return autoStart.maxInteractions > 0;\n}\n\n/*\\\n * interact.maxInteractions\n [ method ]\n **\n * Returns or sets the maximum number of concurrent interactions allowed.\n * By default only 1 interaction is allowed at a time (for backwards\n * compatibility). To allow multiple interactions on the same Interactables\n * and elements, you need to enable it in the draggable, resizable and\n * gesturable `'max'` and `'maxPerElement'` options.\n **\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    autoStart.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return autoStart.maxInteractions;\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.styleCursor = true;\n\nutils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\n\nmodule.exports = autoStart;\n","require('./index').setActionDefaults(require('../actions/resize'));\n","module.exports = {\n  base: {\n    accept        : null,\n    preventDefault: 'auto',\n    deltaSource   : 'page',\n  },\n\n  perAction: {\n    origin: { x: 0, y: 0 },\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n\n    inertia: {\n      enabled          : false,\n      resistance       : 10,    // the lambda in exponential decay\n      minSpeed         : 100,   // target speed must be above this for inertia to start\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n      allowResume      : true,  // allow resuming an action in inertia phase\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n    },\n  },\n};\n","/* browser entry point */\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// pointerEvents\nrequire('./pointerEvents');\nrequire('./pointerEvents/holdRepeat');\nrequire('./pointerEvents/interactableTargets');\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// delay\nrequire('./autoStart/delay');\n\n// actions\nrequire('./actions/gesture');\nrequire('./actions/resize');\nrequire('./actions/drag');\nrequire('./actions/drop');\n\n// load these modifiers after resize is loaded\nrequire('./modifiers/snapSize');\nrequire('./modifiers/restrictEdges');\nrequire('./modifiers/restrictSize');\n\n// autoStart actions\nrequire('./autoStart/gesture');\nrequire('./autoStart/resize');\nrequire('./autoStart/drag');\n\n// Interactable preventDefault setting\nrequire('./interactablePreventDefault.js');\n\n// autoScroll\nrequire('./autoScroll');\n\n// export interact\nmodule.exports = require('./interact');\n","const InteractEvent  = require('./InteractEvent');\nconst Interaction    = require('./Interaction');\nconst modifiers      = require('./modifiers');\nconst utils          = require('./utils');\nconst animationFrame = require('./utils/raf');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active     : false,\n    smoothEnd  : false,\n    allowResume: false,\n\n    startEvent: null,\n    upCoords  : {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i  : null,\n  };\n\n  interaction.boundInertiaFrame   = () => inertiaFrame  .apply(interaction);\n  interaction.boundSmoothEndFrame = () => smoothEndFrame.apply(interaction);\n});\n\nInteraction.signals.on('down', function ({ interaction, event, pointer, eventTarget }) {\n  const status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    let element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.isElement(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n        // stop inertia\n        animationFrame.cancel(status.i);\n        status.active = false;\n        interaction.simulation = null;\n\n        // update pointers to the down event's coordinates\n        interaction.updatePointer(pointer);\n        utils.setCoords(interaction.curCoords, interaction.pointers);\n\n        // fire appropriate signals\n        const signalArg = { interaction };\n        Interaction.signals.fire('before-action-move', signalArg);\n        Interaction.signals.fire('action-resume'     , signalArg);\n\n        // fire a reume event\n        const resumeEvent = new InteractEvent(interaction,\n                                              event,\n                                              interaction.prepared.name,\n                                              'inertiaresume',\n                                              interaction.element);\n\n        interaction.target.fire(resumeEvent);\n        interaction.prevEvent = resumeEvent;\n        modifiers.resetStatuses(interaction.modifierStatuses);\n\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n        break;\n      }\n\n      element = utils.parentNode(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function ({ interaction, event }) {\n  const status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) { return; }\n\n  const target = interaction.target;\n  const options = target && target.options;\n  const inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  const now = new Date().getTime();\n  const statuses = {};\n  const page = utils.extend({}, interaction.curCoords.page);\n  const pointerSpeed = interaction.pointerDelta.client.speed;\n  let inertiaPossible = false;\n  let inertia = false;\n  let smoothEnd = false;\n  let modifierResult;\n\n  // check if inertia should be started\n  inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                     && interaction.prepared.name !== 'gesture'\n                     && event !== status.startEvent);\n\n  inertia = (inertiaPossible\n            && (now - interaction.curCoords.timeStamp) < 50\n            && pointerSpeed > inertiaOptions.minSpeed\n            && pointerSpeed > inertiaOptions.endSpeed);\n\n  const modifierArg = {\n    interaction,\n    page,\n    statuses,\n    preEnd: true,\n    requireEndOnly: true,\n  };\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) { return; }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent =\n    new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(modifierArg);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  }\n  else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function ({ interaction }) {\n  const status = interaction.inertiaStatus;\n\n  if (status.active) {\n    animationFrame.cancel(status.i);\n    status.active = false;\n    interaction.simulation = null;\n  }\n});\n\nfunction calcInertia (interaction, status) {\n  const inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  const lambda = inertiaOptions.resistance;\n  const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame () {\n  updateInertiaCoords(this);\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  const status = this.inertiaStatus;\n  const options = this.target.options[this.prepared.name].inertia;\n  const lambda = options.resistance;\n  const t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    const progress =  1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    }\n    else {\n      const quadPoint = utils.getQuadraticCurvePoint(0, 0,\n                                                     status.xe,\n                                                     status.ye,\n                                                     status.modifiedXe,\n                                                     status.modifiedYe,\n                                                     progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  }\n  else {\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame () {\n  updateInertiaCoords(this);\n\n  const status = this.inertiaStatus;\n  const t = new Date().getTime() - status.t0;\n  const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  }\n  else {\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd =\n      status.active = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords (interaction) {\n  const status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) { return; }\n\n  const pageUp   = status.upCoords.page;\n  const clientUp = status.upCoords.client;\n\n  utils.setCoords(interaction.curCoords, [ {\n    pageX  : pageUp.x   + status.sx,\n    pageY  : pageUp.y   + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy,\n  } ]);\n}\n","const browser      = require('./utils/browser');\nconst events       = require('./utils/events');\nconst utils        = require('./utils');\nconst scope        = require('./scope');\nconst Interactable = require('./Interactable');\nconst Interaction  = require('./Interaction');\n\nconst globalEvents = {};\n\n/*\\\n * interact\n [ method ]\n *\n * The methods of this variable can be used to set elements as\n * interactables and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to\n * configure it.\n *\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n = (object) An @Interactable\n *\n > Usage\n | interact('#draggable').draggable(true);\n |\n | var rectables = interact('rect');\n | rectables\n |     .gesturable(true)\n |     .on('gesturemove', function (event) {\n |         // ...\n |     });\n\\*/\nfunction interact (element, options) {\n  let interactable = scope.interactables.get(element, options);\n\n  if (!interactable) {\n    interactable = new Interactable(element, options);\n    interactable.events.global = globalEvents;\n  }\n\n  return interactable;\n}\n\n/*\\\n * interact.isSet\n [ method ]\n *\n * Check if an element has been set\n - element (Element) The Element being searched for\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\n * interact.on\n [ method ]\n *\n * Adds a global listener for an InteractEvent or adds a DOM event to\n * `document`\n *\n - type       (string | array | object) The types of events to listen for\n - listener   (function) The function event (s)\n - useCapture (boolean) #optional useCapture flag for addEventListener\n = (object) interact\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (const eventType of type) {\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (const prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(Interactable.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener];\n    }\n    else {\n      globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener, useCapture);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.off\n [ method ]\n *\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n - type       (string | array | object) The types of events that were listened for\n - listener   (function) The listener function to be removed\n - useCapture (boolean) #optional useCapture flag for removeEventListener\n = (object) interact\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(Interactable.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  }\n  else {\n    let index;\n\n    if (type in globalEvents\n        && (index = utils.indexOf(globalEvents[type], listener)) !== -1) {\n      globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.debug\n [ method ]\n *\n * Returns an object which exposes internal data\n = (object) An object with properties that outline the current state and expose internal functions and variables\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointerAverage;\ninteract.getTouchBBox       = utils.touchBBox;\ninteract.getTouchDistance   = utils.touchDistance;\ninteract.getTouchAngle      = utils.touchAngle;\n\ninteract.getElementRect       = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector      = utils.matchesSelector;\ninteract.closest              = utils.closest;\n\n/*\\\n * interact.supportsTouch\n [ method ]\n *\n = (boolean) Whether or not the browser supports touch input\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\n * interact.supportsPointerEvent\n [ method ]\n *\n = (boolean) Whether or not the browser supports PointerEvents\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\n * interact.stop\n [ method ]\n *\n * Cancels all interactions (end events are not fired)\n *\n - event (Event) An event on which to call preventDefault()\n = (object) interact\n\\*/\ninteract.stop = function (event) {\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\n * interact.pointerMoveTolerance\n [ method ]\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n - newValue (number) #optional The movement from the start position must be greater than this value\n = (number | Interactable) The current setting or interact\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    Interaction.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return Interaction.pointerMoveTolerance;\n};\n\ninteract.addDocument    = scope.addDocument;\ninteract.removeDocument = scope.removeDocument;\n\nscope.interact = interact;\n\nmodule.exports = interact;\n","const Interactable = require('./Interactable');\nconst Interaction  = require('./Interaction');\nconst scope        = require('./scope');\nconst isType       = require('./utils/isType');\n\nconst { nodeContains, matchesSelector } = require('./utils/domUtils');\n\n/*\\\n * Interactable.preventDefault\n [ method ]\n *\n * Returns or sets whether to prevent the browser's default behaviour\n * in response to pointer events. Can be set to:\n *  - `'always'` to always prevent\n *  - `'never'` to never prevent\n *  - `'auto'` to let interact.js try to determine what would be best\n *\n - newValue (string) #optional `true`, `false` or `'auto'`\n = (string | Interactable) The current setting or this Interactable\n\\*/\nInteractable.prototype.preventDefault = function (newValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue;\n    return this;\n  }\n\n  if (isType.isBool(newValue)) {\n    this.options.preventDefault = newValue? 'always' : 'never';\n    return this;\n  }\n\n  return this.options.preventDefault;\n};\n\nInteractable.prototype.checkAndPreventDefault = function (event) {\n  const setting = this.options.preventDefault;\n\n  if (setting === 'never') { return; }\n\n  if (setting === 'always') {\n    event.preventDefault();\n    return;\n  }\n\n  // setting === 'auto'\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return;\n  }\n\n  // don't preventDefault on editable elements\n  if (matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n    return;\n  }\n\n  event.preventDefault();\n};\n\nfunction onInteractionEvent ({ interaction, event }) {\n  if (interaction.target) {\n    interaction.target.checkAndPreventDefault(event);\n  }\n}\n\nfor (const eventSignal of ['down', 'move', 'up', 'cancel']) {\n  Interaction.signals.on(eventSignal, onInteractionEvent);\n}\n\n// prevent native HTML5 drag on interact.js target elements\nInteraction.docEvents.dragstart = function preventNativeDrag (event) {\n  for (const interaction of scope.interactions) {\n\n    if (interaction.element\n        && (interaction.element === event.target\n            || nodeContains(interaction.element, event.target))) {\n\n      interaction.target.checkAndPreventDefault(event);\n      return;\n    }\n  }\n};\n","const scope   = require('./scope');\nconst events  = require('./utils/events');\nconst browser = require('./utils/browser');\nconst iFinder = require('./utils/interactionFinder');\n\nconst toString = Object.prototype.toString;\nconst window = scope.window;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick (event) {\n  const interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) { return; }\n\n  if (interaction.prevTap\n      && event.clientX === interaction.prevTap.clientX\n      && event.clientY === interaction.prevTap.clientY\n      && event.target  === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes  [0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  const selectFix = function (event) {\n    for (const interaction of scope.interactions) {\n      if (interaction.interacting()) {\n        interaction.target.checkAndPreventDefault(event);\n      }\n    }\n  };\n\n  const onDocIE8 = function onDocIE8 ({ doc, win }, signalName) {\n    const eventMethod = signalName.indexOf('listen') === 0\n      ? events.add : events.remove;\n\n    // For IE's lack of Event#preventDefault\n    eventMethod(doc, 'selectstart', selectFix);\n\n    if (scope.pointerEvents) {\n      eventMethod(doc, 'dblclick', onIE8Dblclick);\n    }\n  };\n\n  scope.signals.on('add-document'   , onDocIE8);\n  scope.signals.on('remove-document', onDocIE8);\n}\n\nmodule.exports = null;\n","const InteractEvent = require('../InteractEvent');\nconst Interaction   = require('../Interaction');\nconst extend        = require('../utils/extend');\n\nconst modifiers = {\n  names: [],\n\n  setOffsets: function (arg) {\n    const { interaction, pageCoords: page } = arg;\n    const { target, element, startOffset } = interaction;\n    const rect = target.getRect(element);\n\n    if (rect) {\n      startOffset.left = page.x - rect.left;\n      startOffset.top  = page.y - rect.top;\n\n      startOffset.right  = rect.right  - page.x;\n      startOffset.bottom = rect.bottom - page.y;\n\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\n    }\n    else {\n      startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\n    }\n\n    arg.rect = rect;\n    arg.interactable = target;\n    arg.element = element;\n\n    for (let i = 0; i < modifiers.names.length; i++) {\n      const modifierName = modifiers.names[i];\n\n      arg.options = target.options[interaction.prepared.name][modifierName];\n\n      if (!arg.options) {\n        continue;\n      }\n\n      interaction.modifierOffsets[modifierName] =\n        modifiers[modifierName].setOffset(arg);\n    }\n  },\n\n  setAll: function (arg) {\n    const { interaction, statuses, preEnd, requireEndOnly } = arg;\n    const coords = extend({}, arg.pageCoords);\n    const result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true,\n    };\n\n    for (const modifierName of modifiers.names) {\n      const modifier = modifiers[modifierName];\n      const options = interaction.target.options[interaction.prepared.name][modifierName];\n\n      if (!shouldDo(options, preEnd, requireEndOnly)) { continue; }\n\n      arg.status = arg.status = statuses[modifierName];\n      arg.options = options;\n      arg.offset = arg.interaction.modifierOffsets[modifierName];\n\n      modifier.set(arg);\n\n      if (arg.status.locked) {\n        coords.x += arg.status.dx;\n        coords.y += arg.status.dy;\n\n        result.dx += arg.status.dx;\n        result.dy += arg.status.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if:\n    //  - there are no modifiers enabled,\n    //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\n    //  - the locked coords have changed since the last pointer move\n    result.shouldMove = !arg.status || !result.locked || arg.status.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (const modifierName of modifiers.names) {\n      const status = statuses[modifierName] || {};\n\n      status.dx = status.dy = 0;\n      status.modifiedX = status.modifiedY = NaN;\n      status.locked = false;\n      status.changed = true;\n\n      statuses[modifierName] = status;\n    }\n\n    return statuses;\n  },\n\n  start: function ({ interaction }, signalName) {\n    const arg = {\n      interaction,\n      pageCoords: (signalName === 'action-resume' ?\n                   interaction.curCoords : interaction.startCoords).page,\n      startOffset: interaction.startOffset,\n      statuses: interaction.modifierStatuses,\n      preEnd: false,\n      requireEndOnly: false,\n    };\n\n    modifiers.setOffsets(arg);\n    modifiers.resetStatuses(arg.statuses);\n\n    arg.pageCoords = extend({}, interaction.startCoords.page);\n    modifiers.setAll(arg);\n  },\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets  = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n});\n\nInteraction.signals.on('action-start' , modifiers.start);\nInteraction.signals.on('action-resume', modifiers.start);\n\nInteraction.signals.on('before-action-move', function ({ interaction, preEnd, interactingBeforeMove }) {\n  const modifierResult = modifiers.setAll({\n    interaction,\n    preEnd,\n    pageCoords: interaction.curCoords.page,\n    statuses: interaction.modifierStatuses,\n    requireEndOnly: false,\n  });\n\n  // don't fire an action move if a modifier would keep the event in the same\n  // cordinates as before\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\n    interaction._dontFireMove = true;\n  }\n});\n\nInteraction.signals.on('action-end', function ({ interaction, event }) {\n  for (let i = 0; i < modifiers.names.length; i++) {\n    const options = interaction.target.options[interaction.prepared.name][modifiers.names[i]];\n\n    // if the endOnly option is true for any modifier\n    if (shouldDo(options, true, true)) {\n      // fire a move event at the modified coordinates\n      interaction.doMove({ event, preEnd: true });\n      break;\n    }\n  }\n});\n\nInteractEvent.signals.on('set-xy', function (arg) {\n  const { iEvent, interaction } = arg;\n  const modifierArg = extend({}, arg);\n\n  for (let i = 0; i < modifiers.names.length; i++) {\n    const modifierName = modifiers.names[i];\n    modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\n\n    if (!modifierArg.options) {\n      continue;\n    }\n\n    const modifier = modifiers[modifierName];\n\n    modifierArg.status = interaction.modifierStatuses[modifierName];\n\n    iEvent[modifierName] = modifier.modifyCoords(modifierArg);\n  }\n});\n\nfunction shouldDo (options, preEnd, requireEndOnly) {\n  return (options && options.enabled\n          && (preEnd || !options.endOnly)\n          && (!requireEndOnly || options.endOnly));\n}\n\nmodule.exports = modifiers;\n","const modifiers      = require('./index');\nconst utils          = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst restrict = {\n  defaults: {\n    enabled    : false,\n    endOnly    : false,\n    restriction: null,\n    elementRect: null,\n  },\n\n  setOffset: function ({ rect, startOffset, options }) {\n    const elementRect = options && options.elementRect;\n    const offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\n\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\n    }\n    else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function ({ pageCoords, interaction, status, options }) {\n    const target    = interaction.target;\n    let restriction = options && options.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, pageCoords);\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentNode(interaction.element);\n      }\n      else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      }\n      else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) { return status; }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    const rect = restriction;\n    let modifiedX;\n    let modifiedY;\n\n    const offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      modifiedX = page.x;\n      modifiedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n      modifiedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\n      modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\n    }\n    else {\n      modifiedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\n      modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    const elementRect = options && options.elementRect;\n\n    if (options && options.enabled\n        && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     min: { top:   0, left:   0, right: 100, bottom: 100 },\n//     max: { top: 500, left: 500, right: 600, bottom: 600 },\n//   },\n// });\n\nconst modifiers      = require('./index');\nconst utils          = require('../utils');\nconst rectUtils      = require('../utils/rect');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\n\nconst noMin = { top: -Infinity, left: -Infinity, bottom: -Infinity, right: -Infinity };\nconst noMax = { top: +Infinity, left: +Infinity, bottom: +Infinity, right: +Infinity };\n\nconst restrictEdges = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n    offset: null,\n  },\n\n  setOffset: function ({ interaction, startOffset, options }) {\n    if (!options) {\n      return utils.extend({}, startOffset);\n    }\n\n    const offset = getRestrictionRect(offset, interaction);\n\n    if (offset) {\n      return {\n        top:    startOffset.top    + offset.y,\n        left:   startOffset.left   + offset.x,\n        bottom: startOffset.bottom + offset.y,\n        right:  startOffset.right  + offset.x,\n      };\n    }\n\n    return startOffset;\n  },\n\n  set: function ({ pageCoords, interaction, status, offset, options }) {\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    const page = status.useStatusXY\n      ? { x: status.x, y: status.y }\n      : utils.extend({}, pageCoords);\n    const min = rectUtils.xywhToTlbr(getRestrictionRect(options.min, interaction)) || noMin;\n    const max = rectUtils.xywhToTlbr(getRestrictionRect(options.max, interaction)) || noMax;\n\n    let modifiedX = page.x;\n    let modifiedY = page.y;\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    if (edges.top) {\n      modifiedY = Math.max(Math.min(max.top    + offset.top,    page.y), min.top    + offset.top);\n    }\n    else if (edges.bottom) {\n      modifiedY = Math.max(Math.min(max.bottom - offset.bottom, page.y), min.bottom - offset.bottom);\n    }\n    if (edges.left) {\n      modifiedX = Math.max(Math.min(max.left   + offset.left,   page.x), min.left   + offset.left);\n    }\n    else if (edges.right) {\n      modifiedX = Math.max(Math.min(max.right  - offset.right,  page.x), min.right  - offset.right);\n    }\n\n    status.dx = modifiedX - page.x;\n    status.dy = modifiedY - page.y;\n\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.modifiedX = modifiedX;\n    status.modifiedY = modifiedY;\n\n    //console.log(status.dx, status.modifiedX, status.changed, status.locked);\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    if (options && options.enabled\n        && !(phase === 'start' && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy,\n        };\n      }\n    }\n  },\n\n  noMin,\n  noMax,\n  getRestrictionRect,\n};\n\nfunction getRestrictionRect (value, interaction) {\n  value = utils.getStringOptionResult(value, interaction.element) || value;\n\n  if (utils.isFunction(value)) {\n    value = value(interaction.resizeRects.inverted);\n  }\n\n  if (utils.isElement(value)) {\n    value = utils.getElementRect(value);\n  }\n\n  return value;\n}\n\nmodifiers.restrictEdges = restrictEdges;\nmodifiers.names.push('restrictEdges');\n\ndefaultOptions.perAction.restrictEdges = restrictEdges.defaults;\nresize.defaults.restrictEdges          = restrictEdges.defaults;\n\nmodule.exports = restrictEdges;\n","// This module adds the options.resize.restrictSize setting which sets min and\n// max width and height for the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictSize: {\n//     min: { width: -600, height: -600 },\n//     max: { width:  600, height:  600 },\n//   },\n// });\n\nconst modifiers      = require('./index');\nconst restrictEdges  = require('./restrictEdges');\nconst utils          = require('../utils');\nconst rectUtils      = require('../utils/rect');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\n\nconst noMin = { width: -Infinity, height: -Infinity };\nconst noMax = { width: +Infinity, height: +Infinity };\n\nconst restrictSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    min: null,\n    max: null,\n  },\n\n  setOffset: function ({ interaction }) {\n    return interaction.startOffset;\n  },\n\n  set: function (arg) {\n    const { interaction, options } = arg;\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\n\n    if (!interaction.interacting() || !edges) {\n      return;\n    }\n\n    const rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\n\n    const minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\n    const maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\n\n    arg.options = {\n      enabled: options.enabled,\n      endOnly: options.endOnly,\n      min: utils.extend({}, restrictEdges.noMin),\n      max: utils.extend({}, restrictEdges.noMax),\n    };\n\n    if (edges.top) {\n      arg.options.min.top = rect.bottom - maxSize.height;\n      arg.options.max.top = rect.bottom - minSize.height;\n    }\n    else if (edges.bottom) {\n      arg.options.min.bottom = rect.top + minSize.height;\n      arg.options.max.bottom = rect.top + maxSize.height;\n    }\n    if (edges.left) {\n      arg.options.min.left = rect.right - maxSize.width;\n      arg.options.max.left = rect.right - minSize.width;\n    }\n    else if (edges.right) {\n      arg.options.min.right = rect.left + minSize.width;\n      arg.options.max.right = rect.left + maxSize.width;\n    }\n\n    return restrictEdges.set(arg);\n  },\n\n  modifyCoords: restrictEdges.modifyCoords,\n};\n\nmodifiers.restrictSize = restrictSize;\nmodifiers.names.push('restrictSize');\n\ndefaultOptions.perAction.restrictSize = restrictSize.defaults;\nresize.defaults.restrictSize          = restrictSize.defaults;\n\nmodule.exports = restrictSize;\n","const modifiers      = require('./index');\nconst interact       = require('../interact');\nconst utils          = require('../utils');\nconst defaultOptions = require('../defaultOptions');\n\nconst snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null,\n  },\n\n  setOffset: function ({ interaction, interactable, element, rect, startOffset, options }) {\n    const offsets = [];\n    const origin = options.origin || utils.getOriginXY(interactable, element, interaction.prepared.name);\n    options = options || interactable.options[interaction.prepared.name].snap || {};\n\n    let snapOffset;\n\n    if (options.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y,\n      };\n    }\n    else if (options.offset === 'self') {\n      snapOffset = {\n        x: rect.left - origin.x,\n        y: rect.top - origin.y,\n      };\n    }\n    else {\n      snapOffset = options.offset || { x: 0, y: 0 };\n    }\n\n    if (rect && options.relativePoints && options.relativePoints.length) {\n      for (const { x: relativeX, y: relativeY } of options.relativePoints) {\n        offsets.push({\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\n        });\n      }\n    }\n    else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function ({ interaction, pageCoords, status, options, offset: offsets }) {\n    const targets = [];\n    let target;\n    let page;\n    let i;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    }\n    else {\n      const origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    let len = options.targets? options.targets.length : 0;\n\n    for (const { x: offsetX, y: offsetY } of offsets) {\n      const relativeX = page.x - offsetX;\n      const relativeY = page.y - offsetY;\n\n      for (const snapTarget of options.targets) {\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        }\n        else {\n          target = snapTarget;\n        }\n\n        if (!target) { continue; }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? (target.x + offsetX) : relativeX,\n          y: utils.isNumber(target.y) ? (target.y + offsetY) : relativeY,\n\n          range: utils.isNumber(target.range)? target.range: options.range,\n        });\n      }\n    }\n\n    const closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0,\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      const range = target.range;\n      const dx = target.x - page.x;\n      const dy = target.y - page.y;\n      const distance = utils.hypot(dx, dy);\n      let inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n          // is the closest target in range?\n          ? (closest.inRange && range !== Infinity\n          // the pointer is relatively deeper in this target\n          ? distance / range < closest.distance / closest.range\n          // this target has Infinite range and the closest doesn't\n          : (range === Infinity && closest.range !== Infinity)\n          // OR this target is closer that the previous closest\n        || distance < closest.distance)\n          // The other is not in range and the pointer is closer to this target\n          : (!closest.inRange && distance < closest.distance))) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    let snapChanged;\n\n    if (closest.target) {\n      snapChanged = (status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y);\n\n      status.modifiedX = closest.target.x;\n      status.modifiedY = closest.target.y;\n    }\n    else {\n      snapChanged = true;\n\n      status.modifiedX = NaN;\n      status.modifiedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\n    status.locked = closest.inRange;\n  },\n\n  modifyCoords: function ({ page, client, status, phase, options }) {\n    const relativePoints = options && options.relativePoints;\n\n    if (options && options.enabled\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range  : status.range,\n        locked : status.locked,\n        x      : status.modifiedX,\n        y      : status.modifiedY,\n        realX  : status.realX,\n        realY  : status.realY,\n        dx     : status.dx,\n        dy     : status.dy,\n      };\n    }\n  },\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    const limits = grid.limits || {\n      left  : -Infinity,\n      right :  Infinity,\n      top   : -Infinity,\n      bottom:  Infinity,\n    };\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    const gridx = Math.round((x - offsetX) / grid.x);\n    const gridy = Math.round((y - offsetY) / grid.y);\n\n    const newX = Math.max(limits.left, Math.min(limits.right , gridx * grid.x + offsetX));\n    const newY = Math.max(limits.top , Math.min(limits.bottom, gridy * grid.y + offsetY));\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range,\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nconst modifiers      = require('./index');\nconst snap           = require('./snap');\nconst defaultOptions = require('../defaultOptions');\nconst resize         = require('../actions/resize');\nconst utils          = require('../utils/');\n\nconst snapSize = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range  : Infinity,\n    targets: null,\n    offsets: null,\n  },\n\n  setOffset: function (arg) {\n    const { interaction, options } = arg;\n    const edges = interaction.prepared.edges;\n\n    if (!edges) { return; }\n\n    arg.options = {\n      relativePoints: [{\n        x: edges.left? 0 : 1,\n        y: edges.top ? 0 : 1,\n      }],\n      origin: { x: 0, y: 0 },\n      offset: 'self',\n      range: options.range,\n    };\n\n    const offsets = snap.setOffset(arg);\n    arg.options = options;\n\n    return offsets;\n  },\n\n  set: function (arg) {\n    const { interaction, options, offset, pageCoords } = arg;\n    const page = utils.extend({}, pageCoords);\n    const relativeX = page.x - offset[0].x;\n    const relativeY = page.y - offset[0].y;\n\n    arg.options = utils.extend({}, options);\n    arg.options.targets = [];\n\n    for (const snapTarget of options.targets) {\n      let target;\n\n      if (utils.isFunction(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction);\n      }\n      else {\n        target = snapTarget;\n      }\n\n      if (!target) { continue; }\n\n      if ('width' in target && 'height' in target) {\n        target.x = target.width;\n        target.y = target.height;\n      }\n\n      arg.options.targets.push(target);\n    }\n\n    snap.set(arg);\n  },\n\n  modifyCoords: function (arg) {\n    const { options } = arg;\n\n    arg.options = utils.extend({}, options);\n    arg.options.enabled = options.enabled;\n    arg.options.relativePoints = [null];\n\n    snap.modifyCoords(arg);\n  },\n};\n\nmodifiers.snapSize = snapSize;\nmodifiers.names.push('snapSize');\n\ndefaultOptions.perAction.snapSize = snapSize.defaults;\nresize.defaults.snapSize          = snapSize.defaults;\n\nmodule.exports = snapSize;\n","const pointerEvents = require('./index.js');\nconst Interaction   = require('../Interaction');\n\npointerEvents.signals.on('new', function ({ pointerEvent }) {\n  pointerEvent.count = (pointerEvent.count || 0) + 1;\n});\n\npointerEvents.signals.on('fired', function ({ interaction, pointerEvent, eventTarget, targets }) {\n  if (pointerEvent.type !== 'hold') { return; }\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval;\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) { return; }\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(function () {\n    pointerEvents.collectEventTargets(interaction, pointerEvent, pointerEvent, eventTarget, 'hold');\n  }, interval);\n});\n\nfunction endHoldRepeat ({ interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle);\n    interaction.holdIntervalHandle = null;\n  }\n}\n\nfor (const signal of ['move', 'up', 'cancel', 'endall']) {\n  Interaction.signals.on(signal, endHoldRepeat);\n}\n\n// don't repeat by default\npointerEvents.defaults.holdRepeatInterval = 0;\npointerEvents.types.push('holdrepeat');\n","const scope       = require('../scope');\nconst Interaction = require('../Interaction');\nconst utils       = require('../utils');\nconst browser     = require('../utils/browser');\nconst defaults    = require('../defaultOptions');\nconst signals     = require('../utils/Signals').new();\nconst { filter }  = require('../utils/arr');\n\nconst simpleSignals = [ 'down', 'up', 'up', 'cancel' ];\nconst simpleEvents = [ 'down', 'up', 'tap', 'cancel' ];\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopImmediatePropagation () {\n  this.immediatePropagationStopped = this.propagationStopped = true;\n}\n\nfunction stopPropagation () {\n  this.propagationStopped = true;\n}\n\nfunction firePointers (interaction, pointer, event, eventTarget, targets, eventType) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n  let pointerEvent = {};\n  let i;\n  // for tap events\n  let interval;\n  let createNewDoubleTap;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  }\n  else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault           = preventOriginalDefault;\n    pointerEvent.stopPropagation          = stopPropagation;\n    pointerEvent.stopImmediatePropagation = stopImmediatePropagation;\n    pointerEvent.interaction              = interaction;\n\n    pointerEvent.timeStamp     = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type          = eventType;\n    pointerEvent.pointerId     = utils.getPointerId(pointer);\n    pointerEvent.pointerType   = interaction.mouse? 'mouse' : !browser.supportsPointerEvent? 'touch'\n      : utils.isString(pointer.pointerType)\n        ? pointer.pointerType\n        : [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap'\n                            && interaction.prevTap.target === pointerEvent.target\n                            && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  const signalArg = {\n    interaction,\n    pointerEvent,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n  };\n\n  signals.fire('new', signalArg);\n\n  for (i = 0; i < targets.length; i++) {\n    const target = targets[i];\n\n    pointerEvent.currentTarget = target.element;\n\n    for (const prop in target.props || {}) {\n      pointerEvent[prop] = target.props[prop];\n    }\n\n    const { x: originX, y: originY } = utils.getOriginXY(target.eventable, target.element);\n\n    pointerEvent.pageX   -= originX;\n    pointerEvent.pageY   -= originY;\n    pointerEvent.clientX -= originX;\n    pointerEvent.clientY -= originY;\n\n    pointerEvent.eventable = target.eventable;\n\n    target.eventable.fire(pointerEvent);\n\n    pointerEvent.pageX   += originX;\n    pointerEvent.pageY   += originY;\n    pointerEvent.clientX += originX;\n    pointerEvent.clientY += originY;\n\n    if (pointerEvent.immediatePropagationStopped\n        || (pointerEvent.propagationStopped\n            && (i + 1) < targets.length && targets[i + 1].element !== pointerEvent.currentTarget)) {\n      break;\n    }\n  }\n\n  signals.fire('fired', signalArg);\n\n  if (createNewDoubleTap) {\n    const doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt   = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  }\n  else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets (interaction, pointer, event, eventTarget, eventType) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n      // or if the pointerup target is different to the pointerdown target\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  let targets = [];\n  const path = utils.getPath(eventTarget);\n  const signalArg = {\n    targets,\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    eventType,\n    path,\n    element: null,\n  };\n\n  for (const element of path) {\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (eventType === 'hold') {\n    targets = filter(targets, function (target) {\n      return (target.eventable.options.holdDuration\n              === interaction.holdTimers[pointerIndex].duration);\n    });\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, eventType);\n  }\n}\n\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\n  const pointerIndex = interaction.getPointerIndex(pointer);\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\n  // copy event to be used in timeout for IE8\n  const eventCopy = browser.isIE8? utils.extend({}, event) : event;\n  const timers = interaction.holdTimers;\n\n  if (!timers[pointerIndex]) {\n    timers[pointerIndex] = { duration: Infinity, timeout: null };\n  }\n\n  const timer = timers[pointerIndex];\n  const path = utils.getPath(eventTarget);\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    eventType: 'hold',\n    targets: [],\n    path,\n    element: null,\n  };\n\n  for (const element of path) {\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  if (!signalArg.targets.length) { return; }\n\n  let minDuration = Infinity;\n\n  for (let i = 0; i < signalArg.targets.length; i++) {\n    const target = signalArg.targets[i];\n    const holdDuration = target.eventable.options.holdDuration;\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration;\n    }\n  }\n\n  timer.duration = minDuration;\n  timer.timeout = setTimeout(function () {\n\n    collectEventTargets(interaction,\n                        browser.isIE8? eventCopy : pointer,\n                        eventCopy,\n                        eventTarget,\n                        'hold');\n  }, minDuration);\n});\n\n['up', 'cancel'].forEach(function (signalName) {\n  Interaction.signals.on(signalName, function ({ interaction, pointerIndex }) {\n    if (interaction.holdTimers[pointerIndex]) {\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\n    }\n  });\n});\n\nfunction createSignalListener (event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction,\n                        arg.pointer,\n                        arg.event,\n                        arg.eventTarget,\n                        event);\n  };\n}\n\nfor (let i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap = null;  // the most recent tap event on this interaction\n  interaction.tapTime = 0;     // time of the most recent tap event\n});\n\ndefaults.pointerEvents = {\n  holdDuration: 600,\n  ignoreFrom  : null,\n  allowFrom   : null,\n  origin      : { x: 0, y: 0 },\n};\n\nmodule.exports = scope.pointerEvents = {\n  firePointers,\n  collectEventTargets,\n  preventOriginalDefault,\n  signals,\n  defaults: defaults.pointerEvents,\n  types: [\n    'down',\n    'move',\n    'up',\n    'cancel',\n    'tap',\n    'doubletap',\n    'hold',\n  ],\n};\n","const pointerEvents = require('./index');\nconst Interactable  = require('../Interactable');\nconst browser       = require('../utils/browser');\nconst isType        = require('../utils/isType');\nconst domUtils      = require('../utils/domUtils');\nconst scope         = require('../scope');\nconst extend        = require('../utils/extend');\nconst { merge }     = require('../utils/arr');\n\npointerEvents.signals.on('collect-targets', function ({ targets, element, eventType, eventTarget }) {\n  function collectSelectors (interactable, selector, context) {\n    const els = browser.useMatchesSelectorPolyfill\n        ? context.querySelectorAll(selector)\n        : undefined;\n\n    const eventable = interactable.events;\n    const options = eventable.options;\n\n    if (eventable[eventType]\n        && isType.isElement(element)\n        && domUtils.matchesSelector(element, selector, els)\n        && interactable.testIgnoreAllow(options, element, eventTarget)) {\n\n      targets.push({\n        element,\n        eventable,\n        props: { interactable },\n      });\n    }\n  }\n\n  const interactable = scope.interactables.get(element);\n\n  if (interactable) {\n    const eventable = interactable.events;\n    const options = eventable.options;\n\n    if (eventable[eventType]\n        && interactable.testIgnoreAllow(options, element, eventTarget)) {\n      targets.push({\n        element,\n        eventable,\n        props: { interactable },\n      });\n    }\n  }\n\n  scope.interactables.forEachSelector(collectSelectors, element);\n});\n\nInteractable.signals.on('new', function ({ interactable }) {\n  interactable.events.getRect = function (element) {\n    return interactable.getRect(element);\n  };\n});\n\nInteractable.signals.on('set', function ({ interactable, options }) {\n  extend(interactable.events.options, pointerEvents.defaults);\n  extend(interactable.events.options, options);\n});\n\nmerge(Interactable.eventTypes, pointerEvents.types);\n\nInteractable.prototype.pointerEvents = function (options) {\n  extend(this.events.options, options);\n\n  return this;\n};\n\nconst __backCompatOption = Interactable.prototype._backCompatOption;\n\nInteractable.prototype._backCompatOption = function (optionName, newValue) {\n  const ret = __backCompatOption.call(this, optionName, newValue);\n\n  if (ret === this) {\n    this.events.options[optionName] = newValue;\n  }\n\n  return ret;\n};\n\nInteractable.settingsMethods.push('pointerEvents');\n","const utils   = require('./utils');\nconst extend  = require('./utils/extend');\nconst events  = require('./utils/events');\nconst signals = require('./utils/Signals').new();\n\nconst scope = {\n  signals,\n  events,\n  utils,\n\n  documents: [],  // all documents being listened to\n\n  addDocument: function (doc, win) {\n    // do nothing if document is already known\n    if (utils.contains(scope.documents, doc)) { return false; }\n\n    win = win || scope.getWindow(doc);\n\n    scope.documents.push(doc);\n    events.documents.push(doc);\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== scope.document) {\n      events.add(win, 'unload', scope.onWindowUnload);\n    }\n\n    signals.fire('add-document', { doc, win });\n  },\n\n  removeDocument: function (doc, win) {\n    const index = utils.indexOf(scope.documents, doc);\n\n    win = win || scope.getWindow(doc);\n\n    events.remove(win, 'unload', scope.onWindowUnload);\n\n    scope.documents.splice(index, 1);\n    events.documents.splice(index, 1);\n\n    signals.fire('remove-document', { win, doc });\n  },\n\n  onWindowUnload: function () {\n    scope.removeDocument(this.document, this);\n  },\n};\n\nextend(scope, require('./utils/window'));\nextend(scope, require('./utils/domObjects'));\n\nmodule.exports = scope;\n","const { indexOf } = require('./arr');\n\nclass Signals {\n  constructor () {\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  on (name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  }\n\n  off (name, listener) {\n    if (!this.listeners[name]) { return; }\n\n    const index = indexOf(this.listeners[name], listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  }\n\n  fire (name, arg) {\n    const targetListeners = this.listeners[name];\n\n    if (!targetListeners) { return; }\n\n    for (let i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  }\n}\n\nSignals.new = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n","function indexOf (array, target) {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains (array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge (target, source) {\n  for (let i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nfunction filter (array, test) {\n  const result = [];\n\n  for (let i = 0; i < array.length; i++) {\n    if (test(array[i])) {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  indexOf,\n  contains,\n  merge,\n  filter,\n};\n","const win        = require('./window');\nconst isType     = require('./isType');\nconst domObjects = require('./domObjects');\n\nconst Element = domObjects.Element;\nconst navigator  = win.window.navigator;\n\nconst browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!(('ontouchstart' in win.window) || isType.isFunction(win.window.DocumentTouch)\n                     && domObjects.document instanceof win.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIE8: ('attachEvent' in win.window) && !('addEventListener' in win.window),\n\n  // Opera Mobile must be handled differently\n  isOperaMobile: (navigator.appName === 'Opera'\n      && browser.supportsTouch\n      && navigator.userAgent.match('Presto')),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n  isIe9OrOlder: /MSIE (8|9)/.test(navigator.userAgent),\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\n    ? 'oMatchesSelector': 'msMatchesSelector',\n\n  useMatchesSelectorPolyfill: false,\n\n  pEventTypes: (domObjects.PointerEvent\n    ? (domObjects.PointerEvent === win.window.MSPointerEvent\n      ? {\n        up:     'MSPointerUp',\n        down:   'MSPointerDown',\n        over:   'mouseover',\n        out:    'mouseout',\n        move:   'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up:     'pointerup',\n        down:   'pointerdown',\n        over:   'pointerover',\n        out:    'pointerout',\n        move:   'pointermove',\n        cancel: 'pointercancel',\n      })\n    : null),\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  wheelEvent: 'onmousewheel' in domObjects.document? 'mousewheel': 'wheel',\n\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n","const domObjects = {};\nconst win = require('./window').window;\n\nfunction blank () {}\n\ndomObjects.document           = win.document;\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\ndomObjects.SVGElement         = win.SVGElement         || blank;\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.Element            = win.Element            || blank;\ndomObjects.HTMLElement        = win.HTMLElement        || domObjects.Element;\n\ndomObjects.Event        = win.Event;\ndomObjects.Touch        = win.Touch || blank;\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\n\nmodule.exports = domObjects;\n","const win        = require('./window');\nconst browser    = require('./browser');\nconst isType     = require('./isType');\nconst domObjects = require('./domObjects');\n\nconst domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (element, selector) {\n    while (isType.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) { return element; }\n\n      element = domUtils.parentNode(element);\n    }\n\n    return null;\n  },\n\n  parentNode: function (node) {\n    let parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill\n    ? function (element, selector, elems) {\n      elems = elems || element.parentNode.querySelectorAll(selector);\n\n      for (let i = 0, len = elems.length; i < len; i++) {\n        if (elems[i] === element) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    let deepestZoneParents = [];\n    let dropzoneParents = [];\n    let dropzone;\n    let deepestZone = elements[0];\n    let index = deepestZone? 0: -1;\n    let parent;\n    let child;\n    let i;\n    let n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement\n          && dropzone instanceof domObjects.SVGElement\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      }\n      else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      const parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n],\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        }\n        else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (isType.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentNode(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return (element instanceof domObjects.SVGElementInstance\n      ? element.correspondingUseElement\n      : element);\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n    };\n  },\n\n  getElementClientRect: function (element) {\n    const clientRect = (element instanceof domObjects.SVGElement\n      ? element.getBoundingClientRect()\n      : element.getClientRects()[0]);\n\n    return clientRect && {\n      left  : clientRect.left,\n      right : clientRect.right,\n      top   : clientRect.top,\n      bottom: clientRect.bottom,\n      width : clientRect.width  || clientRect.right  - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    };\n  },\n\n  getElementRect: function (element) {\n    const clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left   += scroll.x;\n      clientRect.right  += scroll.x;\n      clientRect.top    += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  },\n\n  getPath: function (element) {\n    const path = [];\n\n    while (element) {\n      path.push(element);\n      element = domUtils.parentNode(element);\n    }\n\n    return path;\n  },\n};\n\nmodule.exports = domUtils;\n","const isType   = require('./isType');\nconst domUtils = require('./domUtils');\nconst pExtend  = require('./pointerExtend');\n\nconst { window, getWindow }  = require('./window');\nconst { indexOf, contains } = require('./arr');\n\nconst useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window);\nconst addEvent       = useAttachEvent?  'attachEvent': 'addEventListener';\nconst removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener';\nconst on             = useAttachEvent? 'on': '';\n\nconst elements          = [];\nconst targets           = [];\nconst attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nconst delegatedEvents = {};\n\nconst documents = [];\n\nfunction add (element, type, listener, useCapture) {\n  let elementIndex = indexOf(elements, element);\n  let target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0,\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push((useAttachEvent ? {\n      supplied: [],\n      wrapped : [],\n      useCount: [],\n    } : null));\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    let ret;\n\n    if (useAttachEvent) {\n      const { supplied, wrapped, useCount } = attachedListeners[elementIndex];\n      const listenerIndex = indexOf(supplied, listener);\n\n      const wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault           = event.preventDefault           || preventDef;\n          event.stopPropagation          = event.stopPropagation          || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      }\n      else {\n        useCount[listenerIndex]++;\n      }\n    }\n    else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove (element, type, listener, useCapture) {\n  const elementIndex = indexOf(elements, element);\n  const target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  let wrappedListener = listener;\n  let listeners;\n  let listenerIndex;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    const len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (let i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    }\n    else {\n      for (let i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate (selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts : [],\n      listeners: [],\n    };\n\n    // add delegate listener functions\n    for (let i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  const delegated = delegatedEvents[type];\n  let index;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts .push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate (selector, context, type, listener, useCapture) {\n  const delegated = delegatedEvents[type];\n  let matchFound = false;\n  let index;\n\n  if (!delegated) { return; }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector\n        && delegated.contexts[index] === context) {\n\n      const listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const fn = listeners[i][0];\n        const useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts .splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) { break; }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener (event, useCapture) {\n  const fakeEvent = {};\n  const delegated = delegatedEvents[event.type];\n  const eventTarget = (domUtils.getActualElement(event.path\n    ? event.path[0]\n    : event.target));\n  let element = eventTarget;\n\n  useCapture = useCapture? true: false;\n\n  // duplicate the event so that currentTarget can be changed\n  pExtend(fakeEvent, event);\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (let i = 0; i < delegated.selectors.length; i++) {\n      const selector = delegated.selectors[i];\n      const context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector)\n          && domUtils.nodeContains(context, eventTarget)\n          && domUtils.nodeContains(context, element)) {\n\n        const listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (let j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element);\n  }\n}\n\nfunction delegateUseCapture (event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef () {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault () {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp () {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp () {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add,\n  remove,\n\n  addDelegate,\n  removeDelegate,\n\n  delegateListener,\n  delegateUseCapture,\n  delegatedEvents,\n  documents,\n\n  useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners,\n};\n","module.exports = function extend (dest, source) {\n  for (const prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n","const { closest, parentNode, getElementRect } = require('./domUtils');\nconst { isElement, isFunction, trySelector }  = require('./isType');\n\nmodule.exports = function (target, element, action) {\n  const actionOptions = target.options[action];\n  const actionOrigin = actionOptions && actionOptions.origin;\n  let origin = actionOrigin || target.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentNode(element);\n  }\n  else if (origin === 'self') {\n    origin = target.getRect(element);\n  }\n  else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(target && element);\n  }\n\n  if (isElement(origin))  {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = ('x' in origin)? origin.x : origin.left;\n  origin.y = ('y' in origin)? origin.y : origin.top;\n\n  return origin;\n};\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\n","const extend = require('./extend');\nconst win    = require('./window');\n\nconst utils = {\n  warnOnce: function (method, message) {\n    let warned = false;\n\n    return function () {\n      if (!warned) {\n        win.window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  },\n\n  // http://stackoverflow.com/a/5634528/2280888\n  _getQBezierValue: function (t, p1, p2, p3) {\n    const iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  },\n\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x:  utils._getQBezierValue(position, startX, cpX, endX),\n      y:  utils._getQBezierValue(position, startY, cpY, endY),\n    };\n  },\n\n  // http://gizma.com/easing/\n  easeOutQuad: function (t, b, c, d) {\n    t /= d;\n    return -c * t*(t-2) + b;\n  },\n\n  copyAction: function (dest, src) {\n    dest.name  = src.name;\n    dest.axis  = src.axis;\n    dest.edges = src.edges;\n\n    return dest;\n  },\n\n  getStringOptionResult: function (value, interactable, element) {\n    if (!utils.isString(value)) {\n      return null;\n    }\n\n    if (value === 'parent') {\n      value = utils.parentNode(element);\n    }\n    else if (value === 'self') {\n      value = interactable.getRect(element);\n    }\n    else {\n      value = utils.closest(element, value);\n    }\n\n    return value;\n  },\n\n  extend     : extend,\n  hypot      : require('./hypot'),\n  getOriginXY: require('./getOriginXY'),\n};\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n\nmodule.exports = utils;\n","const scope   = require('../scope');\nconst utils   = require('./index');\nconst browser = require('./browser');\n\nconst finder = {\n  methodOrder: [ 'simulationResume', 'mouse', 'hasPointer', 'idle' ],\n\n  search: function (pointer, eventType, eventTarget) {\n    const mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                        || pointer.pointerType === 4);\n    const pointerId = utils.getPointerId(pointer);\n    const details = { pointer, pointerId, mouseEvent, eventType, eventTarget };\n\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function ({ mouseEvent, eventType, eventTarget }) {\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (const interaction of scope.interactions) {\n      let element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume\n          && (interaction.mouse === mouseEvent)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentNode(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function ({ pointerId, mouseEvent, eventType }) {\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    let firstNonActive;\n\n    for (const interaction of scope.interactions) {\n      if (interaction.mouse) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) { continue; }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction;\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // Find any interaction specifically for mouse.\n    // ignore the interaction if the eventType is a mousedown, and a simulation\n    // is active\n    for (const interaction of scope.interactions) {\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function ({ pointerId }) {\n    for (const interaction of scope.interactions) {\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function ({ mouseEvent }) {\n    for (const interaction of scope.interactions) {\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        const target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n        continue;\n      }\n\n      if (!interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n};\n\nmodule.exports = finder;\n","const win        = require('./window');\nconst isWindow   = require('./isWindow');\nconst domObjects = require('./domObjects');\n\nconst isType = {\n  isElement  : function (o) {\n    if (!o || (typeof o !== 'object')) { return false; }\n\n    const _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element)\n      ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string');\n  },\n\n  isArray    : null,\n\n  isWindow   : function (thing) { return thing === win.window || isWindow(thing); },\n\n  isDocFrag  : function (thing) { return isType.isObject(thing) && thing.nodeType === 11; },\n\n  isObject   : function (thing) { return !!thing && (typeof thing === 'object'); },\n\n  isFunction : function (thing) { return typeof thing === 'function'; },\n\n  isNumber   : function (thing) { return typeof thing === 'number'  ; },\n\n  isBool     : function (thing) { return typeof thing === 'boolean' ; },\n\n  isString   : function (thing) { return typeof thing === 'string'  ; },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) { return false; }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  },\n};\n\nisType.isArray = function (thing) {\n  return (isType.isObject(thing)\n      && (typeof thing.length !== 'undefined')\n      && isType.isFunction(thing.splice));\n};\n\nmodule.exports = isType;\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\n","function pointerExtend (dest, source) {\n  for (const prop in source) {\n    const prefixedPropREs = module.exports.prefixedPropREs;\n    let deprecated = false;\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true;\n        break;\n      }\n    }\n\n    if (!deprecated) {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n};\n\nmodule.exports = pointerExtend;\n","const hypot         = require('./hypot');\nconst browser       = require('./browser');\nconst dom           = require('./domObjects');\nconst isType        = require('./isType');\nconst pointerExtend = require('./pointerExtend');\n\nconst pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setCoordDeltas: function (targetObj, prev, cur) {\n    targetObj.page.x    = cur.page.x    - prev.page.x;\n    targetObj.page.y    = cur.page.y    - prev.page.y;\n    targetObj.client.x  = cur.client.x  - prev.client.x;\n    targetObj.client.y  = cur.client.y  - prev.client.y;\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\n\n    // set pointer velocity\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function  (pointer) {\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    }\n    else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    }\n    else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n  },\n\n  setCoords: function (targetObj, pointers, timeStamp) {\n    const pointer = (pointers.length > 1\n                     ? pointerUtils.pointerAverage(pointers)\n                     : pointers[0]);\n\n    const tmpXY = {};\n\n    pointerUtils.getPageXY(pointer, tmpXY);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    pointerUtils.getClientXY(pointer, tmpXY);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = isType.isNumber(timeStamp) ? timeStamp :new Date().getTime();\n  },\n\n  pointerExtend: pointerExtend,\n\n  getTouchPair: function (event) {\n    const touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      }\n      else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    const average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0,\n    };\n\n    for (const pointer of pointers) {\n      for (const prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (const prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    const touches = pointerUtils.getTouchPair(event);\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n\n\n    const dx = touches[0][sourceX] - touches[1][sourceX];\n    const dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    const sourceX = deltaSource + 'X';\n    const sourceY = deltaSource + 'Y';\n    const touches = pointerUtils.getTouchPair(event);\n    const dx = touches[1][sourceX] - touches[0][sourceX];\n    const dy = touches[1][sourceY] - touches[0][sourceY];\n    const angle = 180 * Math.atan2(dy , dx) / Math.PI;\n\n    return  angle;\n  },\n};\n\nmodule.exports = pointerUtils;\n","const { window } = require('./window');\n\nconst vendors = ['ms', 'moz', 'webkit', 'o'];\nlet lastTime = 0;\nlet request;\nlet cancel;\n\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    const currTime = new Date().getTime();\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\n                          timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request,\n  cancel,\n};\n","const extend = require('./extend');\n\nmodule.exports = {\n  xywhToTlbr: function (rect) {\n    if (rect && !('left' in rect && 'top' in rect)) {\n      rect = extend({}, rect);\n\n      rect.left   = rect.x || 0;\n      rect.top    = rect.y || 0;\n      rect.right  = rect.right   || (rect.left + rect.width);\n      rect.bottom = rect.bottom  || (rect.top + rect.height);\n    }\n\n    return rect;\n  },\n\n  tlbrToXywh: function (rect) {\n    if (rect && !('x' in rect && 'y' in rect)) {\n      rect = extend({}, rect);\n\n      rect.x      = rect.left || 0;\n      rect.top    = rect.top  || 0;\n      rect.width  = rect.width  || (rect.right  - rect.x);\n      rect.height = rect.height || (rect.bottom - rect.y);\n    }\n\n    return rect;\n  },\n};\n","const win = module.exports;\nconst isWindow = require('./isWindow');\n\nfunction init (window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  const el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document\n      && typeof window.wrap === 'function'\n    && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window);\n  }\n\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window     = undefined;\n  win.realWindow = undefined;\n}\nelse {\n  init(window);\n}\n\nwin.getWindow = function getWindow (node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  const rootNode = (node.ownerDocument || node);\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n"]}