{"version":3,"sources":["src\\minHeader.js","src\\header.js","index.js","src\\Eventable.js","src\\InteractEvent.js","src\\Interactable.js","src\\Interaction.js","src\\actions\\base.js","src\\actions\\drag.js","src\\actions\\drop.js","src\\actions\\gesture.js","src\\actions\\resize.js","src\\autoScroll.js","src\\autoStart\\InteractableMethods.js","src\\autoStart\\base.js","src\\autoStart\\delay.js","src\\autoStart\\drag.js","src\\autoStart\\gesture.js","src\\autoStart\\resize.js","src\\defaultOptions.js","src\\index.js","src\\inertia.js","src\\interact.js","src\\interactablePreventDefault.js","src\\legacyBrowsers.js","src\\modifiers\\index.js","src\\modifiers\\restrict.js","src\\modifiers\\restrictEdges.js","src\\modifiers\\restrictSize.js","src\\modifiers\\snap.js","src\\modifiers\\snapSize.js","src\\pointerEvents\\PointerEvent.js","src\\pointerEvents\\base.js","src\\pointerEvents\\holdRepeat.js","src\\pointerEvents\\interactableTargets.js","src\\scope.js","src\\utils\\Signals.js","src\\utils\\arr.js","src\\utils\\browser.js","src\\utils\\domObjects.js","src\\utils\\domUtils.js","src\\utils\\events.js","src\\utils\\extend.js","src\\utils\\getOriginXY.js","src\\utils\\hypot.js","src\\utils\\index.js","src\\utils\\interactionFinder.js","src\\utils\\is.js","src\\utils\\isWindow.js","src\\utils\\pointerExtend.js","src\\utils\\pointerUtils.js","src\\utils\\raf.js","src\\utils\\rect.js","src\\utils\\window.js"],"names":[],"mappings":"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","file":"interact.min.js","sourceRoot":"","sourcesContent":["/* interact.js v1.3.0-alpha+sha.52dcf7b | https://raw.github.com/taye/interact.js/master/LICENSE */\r\n","/**\r\n * interact.js v1.3.0-alpha+sha.52dcf7b\r\n *\r\n * Copyright (c) 2012-2017 Taye Adeyemi <dev@taye.me>\r\n * Open source under the MIT License.\r\n * https://raw.github.com/taye/interact.js/master/LICENSE\r\n */\r\n","/*\r\n * In a (windowless) server environment this file exports a factory function\r\n * that takes the window to use.\r\n *\r\n *     var interact = require('interact.js')(windowObject);\r\n *\r\n * See https://github.com/taye/interact.js/issues/187\r\n */\r\nif (typeof window === 'undefined') {\r\n  module.exports = function (window) {\r\n    require('./src/utils/window').init(window);\r\n\r\n    return require('./src/index');\r\n  };\r\n}\r\nelse {\r\n  module.exports = require('./src/index');\r\n}\r\n","const { indexOf } = require('./utils/arr');\r\nconst extend = require('./utils/extend.js');\r\n\r\nfunction fireUntilImmediateStopped (event, listeners) {\r\n  for (let i = 0, len = listeners.length; i < len && !event.immediatePropagationStopped; i++) {\r\n    listeners[i](event);\r\n  }\r\n}\r\n\r\nclass Eventable {\r\n\r\n  constructor (options) {\r\n    this.options = extend({}, options || {});\r\n  }\r\n\r\n  fire (event) {\r\n    let listeners;\r\n    const onEvent = 'on' + event.type;\r\n    const global = this.global;\r\n\r\n    // Interactable#on() listeners\r\n    if ((listeners = this[event.type])) {\r\n      fireUntilImmediateStopped(event, listeners);\r\n    }\r\n\r\n    // interactable.onevent listener\r\n    if (this[onEvent]) {\r\n      this[onEvent](event);\r\n    }\r\n\r\n    // interact.on() listeners\r\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\r\n      fireUntilImmediateStopped(event, listeners);\r\n    }\r\n  }\r\n\r\n  on (eventType, listener) {\r\n    // if this type of event was never bound\r\n    if (this[eventType]) {\r\n      this[eventType].push(listener);\r\n    }\r\n    else {\r\n      this[eventType] = [listener];\r\n    }\r\n  }\r\n\r\n  off (eventType, listener) {\r\n    // if it is an action event type\r\n    const eventList = this[eventType];\r\n    const index     = eventList? indexOf(eventList, listener) : -1;\r\n\r\n    if (index !== -1) {\r\n      eventList.splice(index, 1);\r\n    }\r\n\r\n    if (eventList && eventList.length === 0 || !listener) {\r\n      this[eventType] = listener;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Eventable;\r\n","const extend      = require('./utils/extend');\r\nconst getOriginXY = require('./utils/getOriginXY');\r\nconst defaults    = require('./defaultOptions');\r\nconst signals     = require('./utils/Signals').new();\r\n\r\nclass InteractEvent {\r\n  constructor (interaction, event, action, phase, element, related, preEnd = false) {\r\n    const target      = interaction.target;\r\n    const deltaSource = (target && target.options || defaults).deltaSource;\r\n    const origin      = getOriginXY(target, element, action);\r\n    const starting    = phase === 'start';\r\n    const ending      = phase === 'end';\r\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\r\n    const prevEvent   = interaction.prevEvent;\r\n\r\n    element = element || interaction.element;\r\n\r\n    const page   = extend({}, coords.page);\r\n    const client = extend({}, coords.client);\r\n\r\n    page.x -= origin.x;\r\n    page.y -= origin.y;\r\n\r\n    client.x -= origin.x;\r\n    client.y -= origin.y;\r\n\r\n    this.ctrlKey       = event.ctrlKey;\r\n    this.altKey        = event.altKey;\r\n    this.shiftKey      = event.shiftKey;\r\n    this.metaKey       = event.metaKey;\r\n    this.button        = event.button;\r\n    this.buttons       = event.buttons;\r\n    this.target        = element;\r\n    this.currentTarget = element;\r\n    this.relatedTarget = related || null;\r\n    this.preEnd        = preEnd;\r\n    this.type          = action + (phase || '');\r\n    this.interaction   = interaction;\r\n    this.interactable  = target;\r\n\r\n    this.t0 = starting ? interaction.downTimes[interaction.downTimes.length - 1]\r\n                       : prevEvent.t0;\r\n\r\n    const signalArg = {\r\n      interaction,\r\n      event,\r\n      action,\r\n      phase,\r\n      element,\r\n      related,\r\n      page,\r\n      client,\r\n      coords,\r\n      starting,\r\n      ending,\r\n      deltaSource,\r\n      iEvent: this,\r\n    };\r\n\r\n    signals.fire('set-xy', signalArg);\r\n\r\n    if (ending) {\r\n      // use previous coords when ending\r\n      this.pageX = prevEvent.pageX;\r\n      this.pageY = prevEvent.pageY;\r\n      this.clientX = prevEvent.clientX;\r\n      this.clientY = prevEvent.clientY;\r\n    }\r\n    else {\r\n      this.pageX     = page.x;\r\n      this.pageY     = page.y;\r\n      this.clientX   = client.x;\r\n      this.clientY   = client.y;\r\n    }\r\n\r\n    this.x0        = interaction.startCoords.page.x - origin.x;\r\n    this.y0        = interaction.startCoords.page.y - origin.y;\r\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\r\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\r\n\r\n    signals.fire('set-delta', signalArg);\r\n\r\n    this.timeStamp = coords.timeStamp;\r\n    this.dt        = interaction.pointerDelta.timeStamp;\r\n    this.duration  = this.timeStamp - this.t0;\r\n\r\n    // speed and velocity in pixels per second\r\n    this.speed = interaction.pointerDelta[deltaSource].speed;\r\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\r\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\r\n\r\n    this.swipe = (ending || phase === 'inertiastart')? this.getSwipe() : null;\r\n\r\n    signals.fire('new', signalArg);\r\n  }\r\n\r\n  getSwipe () {\r\n    const interaction = this.interaction;\r\n\r\n    if (interaction.prevEvent.speed < 600\r\n        || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\r\n      return null;\r\n    }\r\n\r\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\r\n    const overlap = 22.5;\r\n\r\n    if (angle < 0) {\r\n      angle += 360;\r\n    }\r\n\r\n    const left = 135 - overlap <= angle && angle < 225 + overlap;\r\n    const up   = 225 - overlap <= angle && angle < 315 + overlap;\r\n\r\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\r\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\r\n\r\n    return {\r\n      up,\r\n      down,\r\n      left,\r\n      right,\r\n      angle,\r\n      speed: interaction.prevEvent.speed,\r\n      velocity: {\r\n        x: interaction.prevEvent.velocityX,\r\n        y: interaction.prevEvent.velocityY,\r\n      },\r\n    };\r\n  }\r\n\r\n  preventDefault () {}\r\n\r\n  stopImmediatePropagation () {\r\n    this.immediatePropagationStopped = this.propagationStopped = true;\r\n  }\r\n\r\n  stopPropagation () {\r\n    this.propagationStopped = true;\r\n  }\r\n}\r\n\r\nsignals.on('set-delta', function ({ iEvent, interaction, starting, deltaSource }) {\r\n  const prevEvent = starting? iEvent : interaction.prevEvent;\r\n\r\n  if (deltaSource === 'client') {\r\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\r\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\r\n  }\r\n  else {\r\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\r\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\r\n  }\r\n});\r\n\r\nInteractEvent.signals = signals;\r\n\r\nmodule.exports = InteractEvent;\r\n","const is        = require('./utils/is');\r\nconst events    = require('./utils/events');\r\nconst extend    = require('./utils/extend');\r\nconst actions   = require('./actions/base');\r\nconst scope     = require('./scope');\r\nconst Eventable = require('./Eventable');\r\nconst defaults  = require('./defaultOptions');\r\nconst signals   = require('./utils/Signals').new();\r\n\r\nconst {\r\n  getElementRect,\r\n  nodeContains,\r\n  trySelector,\r\n}                           = require('./utils/domUtils');\r\nconst { getWindow }         = require('./utils/window');\r\nconst { indexOf, contains } = require('./utils/arr');\r\nconst { wheelEvent }        = require('./utils/browser');\r\n\r\n// all set interactables\r\nscope.interactables = [];\r\n\r\n/*\\\r\n * Interactable\r\n [ property ]\r\n **\r\n * Object type returned by @interact\r\n\\*/\r\nclass Interactable {\r\n  constructor (target, options) {\r\n    options = options || {};\r\n\r\n    this.target   = target;\r\n    this.events   = new Eventable();\r\n    this._context = options.context || scope.document;\r\n    this._win     = getWindow(trySelector(target)? this._context : target);\r\n    this._doc     = this._win.document;\r\n\r\n    signals.fire('new', {\r\n      target,\r\n      options,\r\n      interactable: this,\r\n      win: this._win,\r\n    });\r\n\r\n    scope.addDocument( this._doc, this._win );\r\n\r\n    scope.interactables.push(this);\r\n\r\n    this.set(options);\r\n  }\r\n\r\n  setOnEvents (action, phases) {\r\n    const onAction = 'on' + action;\r\n\r\n    if (is.function(phases.onstart)       ) { this.events[onAction + 'start'        ] = phases.onstart         ; }\r\n    if (is.function(phases.onmove)        ) { this.events[onAction + 'move'         ] = phases.onmove          ; }\r\n    if (is.function(phases.onend)         ) { this.events[onAction + 'end'          ] = phases.onend           ; }\r\n    if (is.function(phases.oninertiastart)) { this.events[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\r\n\r\n    return this;\r\n  }\r\n\r\n  setPerAction (action, options) {\r\n    // for all the default per-action options\r\n    for (const option in options) {\r\n      // if this option exists for this action\r\n      if (option in defaults[action]) {\r\n        // if the option in the options arg is an object value\r\n        if (is.object(options[option])) {\r\n          // duplicate the object\r\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\r\n\r\n          if (is.object(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\r\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\r\n          }\r\n        }\r\n        else if (is.bool(options[option]) && is.object(defaults.perAction[option])) {\r\n          this.options[action][option].enabled = options[option];\r\n        }\r\n        else if (options[option] !== undefined) {\r\n          // or if it's not undefined, do a plain assignment\r\n          this.options[action][option] = options[option];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.getRect\r\n   [ method ]\r\n   *\r\n   * The default function to get an Interactables bounding rect. Can be\r\n   * overridden using @Interactable.rectChecker.\r\n   *\r\n   - element (Element) #optional The element to measure.\r\n   = (object) The object's bounding rectangle.\r\n   o {\r\n   o     top   : 0,\r\n   o     left  : 0,\r\n   o     bottom: 0,\r\n   o     right : 0,\r\n   o     width : 0,\r\n   o     height: 0\r\n   o }\r\n  \\*/\r\n  getRect (element) {\r\n    element = element || this.target;\r\n\r\n    if (is.string(this.target) && !(is.element(element))) {\r\n      element = this._context.querySelector(this.target);\r\n    }\r\n\r\n    return getElementRect(element);\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.rectChecker\r\n   [ method ]\r\n   *\r\n   * Returns or sets the function used to calculate the interactable's\r\n   * element's rectangle\r\n   *\r\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\r\n   = (function | object) The checker function or this Interactable\r\n  \\*/\r\n  rectChecker (checker) {\r\n    if (is.function(checker)) {\r\n      this.getRect = checker;\r\n\r\n      return this;\r\n    }\r\n\r\n    if (checker === null) {\r\n      delete this.options.getRect;\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.getRect;\r\n  }\r\n\r\n  _backCompatOption (optionName, newValue) {\r\n    if (trySelector(newValue) || is.object(newValue)) {\r\n      this.options[optionName] = newValue;\r\n\r\n      for (const action of actions.names) {\r\n        this.options[action][optionName] = newValue;\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.options[optionName];\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.origin\r\n   [ method ]\r\n   *\r\n   * Gets or sets the origin of the Interactable's element.  The x and y\r\n   * of the origin will be subtracted from action event coordinates.\r\n   *\r\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\r\n   * OR\r\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\r\n   **\r\n   = (object) The current origin or this Interactable\r\n  \\*/\r\n  origin (newValue) {\r\n    return this._backCompatOption('origin', newValue);\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.deltaSource\r\n   [ method ]\r\n   *\r\n   * Returns or sets the mouse coordinate types used to calculate the\r\n   * movement of the pointer.\r\n   *\r\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\r\n   = (string | object) The current deltaSource or this Interactable\r\n  \\*/\r\n  deltaSource (newValue) {\r\n    if (newValue === 'page' || newValue === 'client') {\r\n      this.options.deltaSource = newValue;\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.options.deltaSource;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.context\r\n   [ method ]\r\n   *\r\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\r\n   *\r\n   = (Node) The context Node of this Interactable\r\n   **\r\n  \\*/\r\n  context () {\r\n    return this._context;\r\n  }\r\n\r\n  inContext (element) {\r\n    return (this._context === element.ownerDocument\r\n            || nodeContains(this._context, element));\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.fire\r\n   [ method ]\r\n   *\r\n   * Calls listeners for the given InteractEvent type bound globally\r\n   * and directly to this Interactable\r\n   *\r\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\r\n   = (Interactable) this Interactable\r\n  \\*/\r\n  fire (iEvent) {\r\n    this.events.fire(iEvent);\r\n\r\n    return this;\r\n  }\r\n\r\n  _onOffMultiple (method, eventType, listener, useCapture) {\r\n    if (is.string(eventType) && eventType.search(' ') !== -1) {\r\n      eventType = eventType.trim().split(/ +/);\r\n    }\r\n\r\n    if (is.array(eventType)) {\r\n      for (let i = 0; i < eventType.length; i++) {\r\n        this[method](eventType[i], listener, useCapture);\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    if (is.object(eventType)) {\r\n      for (const prop in eventType) {\r\n        this[method](prop, eventType[prop], listener);\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.on\r\n   [ method ]\r\n   *\r\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\r\n   *\r\n   - eventType  (string | array | object) The types of events to listen for\r\n   - listener   (function) The function event (s)\r\n   - useCapture (boolean) #optional useCapture flag for addEventListener\r\n   = (object) This Interactable\r\n  \\*/\r\n  on (eventType, listener, useCapture) {\r\n    // convert to boolean\r\n    useCapture = !!useCapture;\r\n\r\n    if (this._onOffMultiple('on', eventType, listener, useCapture)) {\r\n      return this;\r\n    }\r\n\r\n    if (eventType === 'wheel') { eventType = wheelEvent; }\r\n\r\n    if (contains(Interactable.eventTypes, eventType)) {\r\n      this.events.on(eventType, listener);\r\n    }\r\n    // delegated event for selector\r\n    else if (is.string(this.target)) {\r\n      events.addDelegate(this.target, this._context, eventType, listener, useCapture);\r\n    }\r\n    else {\r\n      events.add(this.target, eventType, listener, useCapture);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.off\r\n   [ method ]\r\n   *\r\n   * Removes an InteractEvent, pointerEvent or DOM event listener\r\n   *\r\n   - eventType  (string | array | object) The types of events that were listened for\r\n   - listener   (function) The listener function to be removed\r\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\r\n   = (object) This Interactable\r\n  \\*/\r\n  off (eventType, listener, useCapture) {\r\n    // convert to boolean\r\n    useCapture = !!useCapture;\r\n\r\n    if (this._onOffMultiple('off', eventType, listener, useCapture)) {\r\n      return this;\r\n    }\r\n\r\n    if (eventType === 'wheel') { eventType = wheelEvent; }\r\n\r\n    // if it is an action event type\r\n    if (contains(Interactable.eventTypes, eventType)) {\r\n      this.events.off(eventType, listener);\r\n    }\r\n    // delegated event\r\n    else if (is.string(this.target)) {\r\n      events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\r\n    }\r\n    // remove listener from this Interatable's element\r\n    else {\r\n      events.remove(this.target, eventType, listener, useCapture);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.set\r\n   [ method ]\r\n   *\r\n   * Reset the options of this Interactable\r\n   - options (object) The new settings to apply\r\n   = (object) This Interactable\r\n  \\*/\r\n  set (options) {\r\n    if (!is.object(options)) {\r\n      options = {};\r\n    }\r\n\r\n    this.options = extend({}, defaults.base);\r\n\r\n    const perActions = extend({}, defaults.perAction);\r\n\r\n    for (const actionName in actions.methodDict) {\r\n      const methodName = actions.methodDict[actionName];\r\n\r\n      this.options[actionName] = extend({}, defaults[actionName]);\r\n\r\n      this.setPerAction(actionName, perActions);\r\n\r\n      this[methodName](options[actionName]);\r\n    }\r\n\r\n    for (const setting of Interactable.settingsMethods) {\r\n      this.options[setting] = defaults.base[setting];\r\n\r\n      if (setting in options) {\r\n        this[setting](options[setting]);\r\n      }\r\n    }\r\n\r\n    signals.fire('set', {\r\n      options,\r\n      interactable: this,\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.unset\r\n   [ method ]\r\n   *\r\n   * Remove this interactable from the list of interactables and remove\r\n   * it's action capabilities and event listeners\r\n   *\r\n   = (object) @interact\r\n  \\*/\r\n  unset () {\r\n    events.remove(this.target, 'all');\r\n\r\n    if (is.string(this.target)) {\r\n      // remove delegated events\r\n      for (const type in events.delegatedEvents) {\r\n        const delegated = events.delegatedEvents[type];\r\n\r\n        if (delegated.selectors[0] === this.target\r\n            && delegated.contexts[0] === this._context) {\r\n\r\n          delegated.selectors.splice(0, 1);\r\n          delegated.contexts .splice(0, 1);\r\n          delegated.listeners.splice(0, 1);\r\n\r\n          // remove the arrays if they are empty\r\n          if (!delegated.selectors.length) {\r\n            delegated[type] = null;\r\n          }\r\n        }\r\n\r\n        events.remove(this._context, type, events.delegateListener);\r\n        events.remove(this._context, type, events.delegateUseCapture, true);\r\n      }\r\n    }\r\n    else {\r\n      events.remove(this, 'all');\r\n    }\r\n\r\n    signals.fire('unset', { interactable: this });\r\n\r\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\r\n\r\n    // Stop related interactions when an Interactable is unset\r\n    for (const interaction of scope.interactions || []) {\r\n      if (interaction.target === this && interaction.interacting()) {\r\n        interaction.stop();\r\n      }\r\n    }\r\n\r\n    return scope.interact;\r\n  }\r\n}\r\n\r\nscope.interactables.indexOfElement = function indexOfElement (target, context) {\r\n  context = context || scope.document;\r\n\r\n  for (let i = 0; i < this.length; i++) {\r\n    const interactable = this[i];\r\n\r\n    if (interactable.target === target && interactable._context === context) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nscope.interactables.get = function interactableGet (element, options, dontCheckInContext) {\r\n  const ret = this[this.indexOfElement(element, options && options.context)];\r\n\r\n  return ret && (is.string(element) || dontCheckInContext || ret.inContext(element))? ret : null;\r\n};\r\n\r\nscope.interactables.forEachSelector = function (callback, element) {\r\n  for (let i = 0; i < this.length; i++) {\r\n    const interactable = this[i];\r\n\r\n    // skip non CSS selector targets and out of context elements\r\n    if (!is.string(interactable.target)\r\n        || (element && !interactable.inContext(element))) {\r\n      continue;\r\n    }\r\n\r\n    const ret = callback(interactable, interactable.target, interactable._context, i, this);\r\n\r\n    if (ret !== undefined) {\r\n      return ret;\r\n    }\r\n  }\r\n};\r\n\r\n// all interact.js eventTypes\r\nInteractable.eventTypes = scope.eventTypes = [];\r\n\r\nInteractable.signals = signals;\r\n\r\nInteractable.settingsMethods = [ 'deltaSource', 'origin', 'preventDefault', 'rectChecker' ];\r\n\r\nmodule.exports = Interactable;\r\n","const scope   = require('./scope');\r\nconst utils   = require('./utils');\r\nconst events  = require('./utils/events');\r\nconst browser = require('./utils/browser');\r\nconst finder  = require('./utils/interactionFinder');\r\nconst signals = require('./utils/Signals').new();\r\n\r\nconst listeners   = {};\r\nconst methodNames = [\r\n  'pointerDown', 'pointerMove', 'pointerUp',\r\n  'updatePointer', 'removePointer',\r\n];\r\n\r\n// for ignoring browser's simulated mouse events\r\nlet prevTouchTime = 0;\r\n\r\n// all active and idle interactions\r\nscope.interactions = [];\r\n\r\nclass Interaction {\r\n  constructor () {\r\n    this.target        = null; // current interactable being interacted with\r\n    this.element       = null; // the target element of the interactable\r\n\r\n    this.prepared      = {     // action that's ready to be fired on next move event\r\n      name : null,\r\n      axis : null,\r\n      edges: null,\r\n    };\r\n\r\n    // keep track of added pointers\r\n    this.pointers    = [];\r\n    this.pointerIds  = [];\r\n    this.downTargets = [];\r\n    this.downTimes   = [];\r\n\r\n    // Previous native pointer move event coordinates\r\n    this.prevCoords = {\r\n      page     : { x: 0, y: 0 },\r\n      client   : { x: 0, y: 0 },\r\n      timeStamp: 0,\r\n    };\r\n    // current native pointer move event coordinates\r\n    this.curCoords = {\r\n      page     : { x: 0, y: 0 },\r\n      client   : { x: 0, y: 0 },\r\n      timeStamp: 0,\r\n    };\r\n\r\n    // Starting InteractEvent pointer coordinates\r\n    this.startCoords = {\r\n      page     : { x: 0, y: 0 },\r\n      client   : { x: 0, y: 0 },\r\n      timeStamp: 0,\r\n    };\r\n\r\n    // Change in coordinates and time of the pointer\r\n    this.pointerDelta = {\r\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\r\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\r\n      timeStamp: 0,\r\n    };\r\n\r\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\r\n    this.downPointer = {};\r\n\r\n    this._eventTarget    = null;\r\n    this._curEventTarget = null;\r\n\r\n    this.prevEvent = null;      // previous action event\r\n\r\n    this.pointerIsDown   = false;\r\n    this.pointerWasMoved = false;\r\n    this._interacting    = false;\r\n\r\n    this.mouse = false;\r\n\r\n    signals.fire('new', this);\r\n\r\n    scope.interactions.push(this);\r\n  }\r\n\r\n  pointerDown (pointer, event, eventTarget) {\r\n    const pointerIndex = this.updatePointer(pointer, event, true);\r\n\r\n    signals.fire('down', {\r\n      pointer,\r\n      event,\r\n      eventTarget,\r\n      pointerIndex,\r\n      interaction: this,\r\n    });\r\n  }\r\n\r\n  /*\\\r\n   * Interaction.start\r\n   [ method ]\r\n   *\r\n   * Start an action with the given Interactable and Element as tartgets. The\r\n   * action must be enabled for the target Interactable and an appropriate number\r\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\r\n   *\r\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\r\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\r\n   *\r\n   - action  (object)  The action to be performed - drag, resize, etc.\r\n   - target  (Interactable) The Interactable to target\r\n   - element (Element) The DOM Element to target\r\n   = (object) interact\r\n   **\r\n   | interact(target)\r\n   |   .draggable({\r\n   |     // disable the default drag start by down->move\r\n   |     manualStart: true\r\n   |   })\r\n   |   // start dragging after the user holds the pointer down\r\n   |   .on('hold', function (event) {\r\n   |     var interaction = event.interaction;\r\n   |\r\n   |     if (!interaction.interacting()) {\r\n   |       interaction.start({ name: 'drag' },\r\n   |                         event.interactable,\r\n   |                         event.currentTarget);\r\n   |     }\r\n   | });\r\n   \\*/\r\n  start (action, target, element) {\r\n    if (this.interacting()\r\n        || !this.pointerIsDown\r\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\r\n      return;\r\n    }\r\n\r\n    // if this interaction had been removed after stopping\r\n    // add it back\r\n    if (utils.indexOf(scope.interactions, this) === -1) {\r\n      scope.interactions.push(this);\r\n    }\r\n\r\n    utils.copyAction(this.prepared, action);\r\n    this.target         = target;\r\n    this.element        = element;\r\n\r\n    signals.fire('action-start', {\r\n      interaction: this,\r\n      event: this.downEvent,\r\n    });\r\n  }\r\n\r\n  pointerMove (pointer, event, eventTarget) {\r\n    if (!this.simulation) {\r\n      this.updatePointer(pointer);\r\n      utils.setCoords(this.curCoords, this.pointers);\r\n    }\r\n\r\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\r\n                           && this.curCoords.page.y === this.prevCoords.page.y\r\n                           && this.curCoords.client.x === this.prevCoords.client.x\r\n                           && this.curCoords.client.y === this.prevCoords.client.y);\r\n\r\n    let dx;\r\n    let dy;\r\n\r\n    // register movement greater than pointerMoveTolerance\r\n    if (this.pointerIsDown && !this.pointerWasMoved) {\r\n      dx = this.curCoords.client.x - this.startCoords.client.x;\r\n      dy = this.curCoords.client.y - this.startCoords.client.y;\r\n\r\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\r\n    }\r\n\r\n    const signalArg = {\r\n      pointer,\r\n      pointerIndex: this.getPointerIndex(pointer),\r\n      event,\r\n      eventTarget,\r\n      dx,\r\n      dy,\r\n      duplicate: duplicateMove,\r\n      interaction: this,\r\n      interactingBeforeMove: this.interacting(),\r\n    };\r\n\r\n    if (!duplicateMove) {\r\n      // set pointer coordinate, time changes and speeds\r\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\r\n    }\r\n\r\n    signals.fire('move', signalArg);\r\n\r\n    if (!duplicateMove) {\r\n      // if interacting, fire an 'action-move' signal etc\r\n      if (this.interacting()) {\r\n        this.doMove(signalArg);\r\n      }\r\n\r\n      if (this.pointerWasMoved) {\r\n        utils.copyCoords(this.prevCoords, this.curCoords);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\\\r\n   * Interaction.doMove\r\n   [ method ]\r\n   *\r\n   * Force a move of the current action at the same coordinates. Useful if\r\n   * snap/restrict has been changed and you want a movement with the new\r\n   * settings.\r\n   *\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('dragmove', function (event) {\r\n   |     if (someCondition) {\r\n   |       // change the snap settings\r\n   |       event.interactable.draggable({ snap: { targets: [] }});\r\n   |       // fire another move event with re-calculated snap\r\n   |       event.interaction.doMove();\r\n   |     }\r\n   |   });\r\n   \\*/\r\n  doMove (signalArg) {\r\n    signalArg = utils.extend({\r\n      pointer: this.pointers[0],\r\n      event: this.prevEvent,\r\n      eventTarget: this._eventTarget,\r\n      interaction: this,\r\n    }, signalArg || {});\r\n\r\n    signals.fire('before-action-move', signalArg);\r\n\r\n    if (!this._dontFireMove) {\r\n      signals.fire('action-move', signalArg);\r\n    }\r\n\r\n    this._dontFireMove = false;\r\n  }\r\n\r\n  // End interact move events and stop auto-scroll unless simulation is running\r\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\r\n    const pointerIndex = this.getPointerIndex(pointer);\r\n\r\n    signals.fire(/cancel$/i.test(event.type)? 'cancel' : 'up', {\r\n      pointer,\r\n      pointerIndex,\r\n      event,\r\n      eventTarget,\r\n      curEventTarget,\r\n      interaction: this,\r\n    });\r\n\r\n    if (!this.simulation) {\r\n      this.end(event);\r\n    }\r\n\r\n    this.pointerIsDown = false;\r\n    this.removePointer(pointer, event);\r\n  }\r\n\r\n  /*\\\r\n   * Interaction.end\r\n   [ method ]\r\n   *\r\n   * Stop the current action and fire an end event. Inertial movement does\r\n   * not happen.\r\n   *\r\n   - event (PointerEvent) #optional\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('move', function (event) {\r\n   |     if (event.pageX > 1000) {\r\n   |       // end the current action\r\n   |       event.interaction.end();\r\n   |       // stop all further listeners from being called\r\n   |       event.stopImmediatePropagation();\r\n   |     }\r\n   |   });\r\n   \\*/\r\n  end (event) {\r\n    event = event || this.prevEvent;\r\n\r\n    if (this.interacting()) {\r\n      signals.fire('action-end', {\r\n        event,\r\n        interaction: this,\r\n      });\r\n    }\r\n\r\n    this.stop();\r\n  }\r\n\r\n  currentAction () {\r\n    return this._interacting? this.prepared.name: null;\r\n  }\r\n\r\n  interacting () {\r\n    return this._interacting;\r\n  }\r\n\r\n  stop () {\r\n    signals.fire('stop', { interaction: this });\r\n\r\n    if (this._interacting) {\r\n      signals.fire('stop-active', { interaction: this });\r\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\r\n    }\r\n\r\n    this.target = this.element = null;\r\n\r\n    this._interacting = false;\r\n    this.prepared.name = this.prevEvent = null;\r\n  }\r\n\r\n  getPointerIndex (pointer) {\r\n    return utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\r\n  }\r\n\r\n  updatePointer (pointer, event, down = event && /(down|start)$/i.test(event.type)) {\r\n    const id = utils.getPointerId(pointer);\r\n    let index = this.getPointerIndex(pointer);\r\n\r\n    if (index === -1) {\r\n      index = this.pointerIds.length;\r\n      this.pointerIds[index] = id;\r\n    }\r\n\r\n    if (down) {\r\n      signals.fire('update-pointer-down', {\r\n        pointer,\r\n        event,\r\n        down,\r\n        pointerId: id,\r\n        pointerIndex: index,\r\n        interaction: this,\r\n      });\r\n    }\r\n\r\n    this.pointers[index] = pointer;\r\n\r\n    return index;\r\n  }\r\n\r\n  removePointer (pointer, event) {\r\n    const id = utils.getPointerId(pointer);\r\n    const index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\r\n\r\n    if (index === -1) { return; }\r\n\r\n    signals.fire('remove-pointer', {\r\n      pointer,\r\n      event,\r\n      pointerIndex: index,\r\n      interaction: this,\r\n    });\r\n\r\n    this.pointers   .splice(index, 1);\r\n    this.pointerIds .splice(index, 1);\r\n    this.downTargets.splice(index, 1);\r\n    this.downTimes  .splice(index, 1);\r\n  }\r\n\r\n  _updateEventTargets (target, currentTarget) {\r\n    this._eventTarget    = target;\r\n    this._curEventTarget = currentTarget;\r\n  }\r\n}\r\n\r\nfor (let i = 0, len = methodNames.length; i < len; i++) {\r\n  const method = methodNames[i];\r\n\r\n  listeners[method] = doOnInteractions(method);\r\n}\r\n\r\nfunction doOnInteractions (method) {\r\n  return (function (event) {\r\n    const [eventTarget, curEventTarget] = utils.getEventTargets(event);\r\n    const matches = []; // [ [pointer, interaction], ...]\r\n\r\n    if (browser.supportsTouch && /touch/.test(event.type)) {\r\n      prevTouchTime = new Date().getTime();\r\n\r\n      for (let i = 0; i < event.changedTouches.length; i++) {\r\n        const pointer = event.changedTouches[i];\r\n        const interaction = finder.search(pointer, event.type, eventTarget);\r\n\r\n        matches.push([pointer, interaction || new Interaction()]);\r\n      }\r\n    }\r\n    else {\r\n      let invalidPointer = false;\r\n\r\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\r\n        // ignore mouse events while touch interactions are active\r\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\r\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\r\n        }\r\n\r\n        // try to ignore mouse events that are simulated by the browser\r\n        // after a touch event\r\n        invalidPointer = invalidPointer\r\n          || (new Date().getTime() - prevTouchTime < 500)\r\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\r\n          || event.timeStamp === 0;\r\n      }\r\n\r\n      if (!invalidPointer) {\r\n        let interaction = finder.search(event, event.type, eventTarget);\r\n\r\n        if (!interaction) {\r\n\r\n          interaction = new Interaction();\r\n          interaction.mouse = (/mouse/i.test(event.pointerType || event.type)\r\n                               // MSPointerEvent.MSPOINTER_TYPE_MOUSE\r\n                               || event.pointerType === 4\r\n                               || !event.pointerType);\r\n        }\r\n\r\n        matches.push([event, interaction]);\r\n      }\r\n    }\r\n\r\n    for (const [pointer, interaction] of matches) {\r\n      interaction._updateEventTargets(eventTarget, curEventTarget);\r\n      interaction[method](pointer, event, eventTarget, curEventTarget);\r\n    }\r\n  });\r\n}\r\n\r\nfunction endAll (event) {\r\n  for (let i = 0; i < scope.interactions.length; i++) {\r\n    const interaction = scope.interactions[i];\r\n\r\n    interaction.end(event);\r\n    signals.fire('endall', { event, interaction });\r\n  }\r\n}\r\n\r\nconst docEvents = { /* 'eventType': listenerFunc */ };\r\nconst pEventTypes = browser.pEventTypes;\r\n\r\nif (scope.PointerEvent) {\r\n  docEvents[pEventTypes.down  ] = listeners.pointerDown;\r\n  docEvents[pEventTypes.move  ] = listeners.pointerMove;\r\n  docEvents[pEventTypes.up    ] = listeners.pointerUp;\r\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\r\n}\r\nelse {\r\n  docEvents.mousedown   = listeners.pointerDown;\r\n  docEvents.mousemove   = listeners.pointerMove;\r\n  docEvents.mouseup     = listeners.pointerUp;\r\n\r\n  docEvents.touchstart  = listeners.pointerDown;\r\n  docEvents.touchmove   = listeners.pointerMove;\r\n  docEvents.touchend    = listeners.pointerUp;\r\n  docEvents.touchcancel = listeners.pointerUp;\r\n}\r\n\r\ndocEvents.blur = endAll;\r\n\r\nfunction onDocSignal ({ doc }, signalName) {\r\n  const eventMethod = signalName.indexOf('add') === 0\r\n    ? events.add : events.remove;\r\n\r\n  // delegate event listener\r\n  for (const eventType in scope.delegatedEvents) {\r\n    eventMethod(doc, eventType, events.delegateListener);\r\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\r\n  }\r\n\r\n  for (const eventType in docEvents) {\r\n    eventMethod(doc, eventType, docEvents[eventType]);\r\n  }\r\n}\r\n\r\nsignals.on('update-pointer-down', ({ interaction, pointer, pointerId, pointerIndex, event, eventTarget, down }) => {\r\n  interaction.pointerIds[pointerIndex] = pointerId;\r\n  interaction.pointers[pointerIndex] = pointer;\r\n\r\n  if (down) {\r\n    interaction.pointerIsDown = true;\r\n  }\r\n\r\n  if (!interaction.interacting()) {\r\n    utils.setCoords(interaction.startCoords, interaction.pointers);\r\n\r\n    utils.copyCoords(interaction.curCoords , interaction.startCoords);\r\n    utils.copyCoords(interaction.prevCoords, interaction.startCoords);\r\n\r\n    interaction.downEvent                 = event;\r\n    interaction.downTimes[pointerIndex]   = interaction.curCoords.timeStamp;\r\n    interaction.downTargets[pointerIndex] = eventTarget || event && utils.getEventTargets(event)[0];\r\n    interaction.pointerWasMoved           = false;\r\n\r\n    utils.pointerExtend(interaction.downPointer, pointer);\r\n  }\r\n});\r\n\r\nscope.signals.on('add-document'   , onDocSignal);\r\nscope.signals.on('remove-document', onDocSignal);\r\n\r\nInteraction.pointerMoveTolerance = 1;\r\nInteraction.doOnInteractions = doOnInteractions;\r\nInteraction.endAll = endAll;\r\nInteraction.signals = signals;\r\nInteraction.docEvents = docEvents;\r\n\r\nscope.endAllInteractions = endAll;\r\n\r\nmodule.exports = Interaction;\r\n","const Interaction   = require('../Interaction');\r\nconst InteractEvent = require('../InteractEvent');\r\n\r\nconst actions = {\r\n  firePrepared,\r\n  names: [],\r\n  methodDict: {},\r\n};\r\n\r\nInteraction.signals.on('action-start', function ({ interaction, event }) {\r\n  interaction._interacting = true;\r\n  firePrepared(interaction, event, 'start');\r\n});\r\n\r\nInteraction.signals.on('action-move', function ({ interaction, event, preEnd }) {\r\n  firePrepared(interaction, event, 'move', preEnd);\r\n\r\n  // if the action was ended in a listener\r\n  if (!interaction.interacting()) { return false; }\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction, event }) {\r\n  firePrepared(interaction, event, 'end');\r\n});\r\n\r\nfunction firePrepared (interaction, event, phase, preEnd) {\r\n  const actionName = interaction.prepared.name;\r\n\r\n  const newEvent = new InteractEvent(interaction, event, actionName, phase, interaction.element, null, preEnd);\r\n\r\n  interaction.target.fire(newEvent);\r\n  interaction.prevEvent = newEvent;\r\n}\r\n\r\nmodule.exports = actions;\r\n","const actions        = require('./base');\r\nconst utils          = require('../utils');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst drag = {\r\n  defaults: {\r\n    enabled     : false,\r\n    mouseButtons: null,\r\n\r\n    origin    : null,\r\n    snap      : null,\r\n    restrict  : null,\r\n    inertia   : null,\r\n    autoScroll: null,\r\n\r\n    startAxis : 'xy',\r\n    lockAxis  : 'xy',\r\n  },\r\n\r\n  checker: function (pointer, event, interactable) {\r\n    const dragOptions = interactable.options.drag;\r\n\r\n    return dragOptions.enabled\r\n      ? { name: 'drag', axis: (dragOptions.lockAxis === 'start'\r\n                               ? dragOptions.startAxis\r\n                               : dragOptions.lockAxis)}\r\n      : null;\r\n  },\r\n\r\n  getCursor: function () {\r\n    return 'move';\r\n  },\r\n};\r\n\r\nInteraction.signals.on('before-action-move', function ({ interaction }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  const axis = interaction.prepared.axis;\r\n\r\n  if (axis === 'x') {\r\n    interaction.curCoords.page.y   = interaction.startCoords.page.y;\r\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\r\n\r\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vx);\r\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\r\n    interaction.pointerDelta.client.vy = 0;\r\n    interaction.pointerDelta.page.vy   = 0;\r\n  }\r\n  else if (axis === 'y') {\r\n    interaction.curCoords.page.x   = interaction.startCoords.page.x;\r\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\r\n\r\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vy);\r\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\r\n    interaction.pointerDelta.client.vx = 0;\r\n    interaction.pointerDelta.page.vx   = 0;\r\n  }\r\n});\r\n\r\n// dragmove\r\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\r\n  if (iEvent.type !== 'dragmove') { return; }\r\n\r\n  const axis = interaction.prepared.axis;\r\n\r\n  if (axis === 'x') {\r\n    iEvent.pageY   = interaction.startCoords.page.y;\r\n    iEvent.clientY = interaction.startCoords.client.y;\r\n    iEvent.dy = 0;\r\n  }\r\n  else if (axis === 'y') {\r\n    iEvent.pageX   = interaction.startCoords.page.x;\r\n    iEvent.clientX = interaction.startCoords.client.x;\r\n    iEvent.dx = 0;\r\n  }\r\n});\r\n\r\n/*\\\r\n * Interactable.draggable\r\n [ method ]\r\n *\r\n * Gets or sets whether drag actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of drag events\r\n | var isDraggable = interact('ul li').draggable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\r\n = (object) This Interactable\r\n | interact(element).draggable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // the axis in which the first movement must be\r\n |     // for the drag sequence to start\r\n |     // 'xy' by default - any direction\r\n |     startAxis: 'x' || 'y' || 'xy',\r\n |\r\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\r\n |     // 'x' or 'y' to restrict movement to either axis\r\n |     // 'start' to restrict movement to the axis the drag started in\r\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\r\n |\r\n |     // max number of drags that can happen concurrently\r\n |     // with elements of this Interactable. Infinity by default\r\n |     max: Infinity,\r\n |\r\n |     // max number of drags that can target the same element+Interactable\r\n |     // 1 by default\r\n |     maxPerElement: 2\r\n | });\r\n\\*/\r\nInteractable.prototype.draggable = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.drag.enabled = options.enabled === false? false: true;\r\n    this.setPerAction('drag', options);\r\n    this.setOnEvents('drag', options);\r\n\r\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\r\n      this.options.drag.lockAxis = options.lockAxis;\r\n    }\r\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\r\n      this.options.drag.startAxis = options.startAxis;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.is.bool(options)) {\r\n    this.options.drag.enabled = options;\r\n\r\n    if (!options) {\r\n      this.ondragstart = this.ondragstart = this.ondragend = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.drag;\r\n};\r\n\r\nactions.drag = drag;\r\nactions.names.push('drag');\r\nutils.merge(Interactable.eventTypes, [\r\n  'dragstart',\r\n  'dragmove',\r\n  'draginertiastart',\r\n  'draginertiaresume',\r\n  'dragend',\r\n]);\r\nactions.methodDict.drag = 'draggable';\r\n\r\ndefaultOptions.drag = drag.defaults;\r\n\r\nmodule.exports = drag;\r\n","const actions        = require('./base');\r\nconst utils          = require('../utils');\r\nconst scope          = require('../scope');\r\nconst interact       = require('../interact');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst drop = {\r\n  defaults: {\r\n    enabled: false,\r\n    accept : null,\r\n    overlap: 'pointer',\r\n  },\r\n};\r\n\r\nlet dynamicDrop = false;\r\n\r\nInteraction.signals.on('action-start', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  // reset active dropzones\r\n  interaction.activeDrops.dropzones = [];\r\n  interaction.activeDrops.elements  = [];\r\n  interaction.activeDrops.rects     = [];\r\n\r\n  interaction.dropEvents = null;\r\n\r\n  if (!interaction.dynamicDrop) {\r\n    setActiveDrops(interaction, interaction.element);\r\n  }\r\n\r\n  const dragEvent = interaction.prevEvent;\r\n  const dropEvents = getDropEvents(interaction, event, dragEvent);\r\n\r\n  if (dropEvents.activate) {\r\n    fireActiveDrops(interaction, dropEvents.activate);\r\n  }\r\n});\r\n\r\nInteractEvent.signals.on('new', function ({ interaction, iEvent, event }) {\r\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return; }\r\n\r\n  const draggableElement = interaction.element;\r\n  const dragEvent = iEvent;\r\n  const dropResult = getDrop(dragEvent, event, draggableElement);\r\n\r\n  interaction.dropTarget  = dropResult.dropzone;\r\n  interaction.dropElement = dropResult.element;\r\n\r\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\r\n});\r\n\r\nInteraction.signals.on('action-move', function ({ interaction }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  fireDropEvents(interaction, interaction.dropEvents);\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction }) {\r\n  if (interaction.prepared.name === 'drag') {\r\n    fireDropEvents(interaction, interaction.dropEvents);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('stop-drag', function ({ interaction }) {\r\n  interaction.activeDrops.dropzones =\r\n    interaction.activeDrops.elements =\r\n    interaction.activeDrops.rects =\r\n    interaction.dropEvents = null;\r\n});\r\n\r\nfunction collectDrops (interaction, element) {\r\n  const drops = [];\r\n  const elements = [];\r\n\r\n  element = element || interaction.element;\r\n\r\n  // collect all dropzones and their elements which qualify for a drop\r\n  for (const current of scope.interactables) {\r\n    if (!current.options.drop.enabled) { continue; }\r\n\r\n    const accept = current.options.drop.accept;\r\n\r\n    // test the draggable element against the dropzone's accept setting\r\n    if ((utils.is.element(accept) && accept !== element)\r\n        || (utils.is.string(accept)\r\n        && !utils.matchesSelector(element, accept))) {\r\n\r\n      continue;\r\n    }\r\n\r\n    // query for new elements if necessary\r\n    const dropElements = utils.is.string(current.target)\r\n      ? current._context.querySelectorAll(current.target)\r\n      : [current.target];\r\n\r\n    for (let i = 0; i < dropElements.length; i++) {\r\n      const currentElement = dropElements[i];\r\n\r\n      if (currentElement !== element) {\r\n        drops.push(current);\r\n        elements.push(currentElement);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    elements,\r\n    dropzones: drops,\r\n  };\r\n}\r\n\r\nfunction fireActiveDrops (interaction, event) {\r\n  let prevElement;\r\n\r\n  // loop through all active dropzones and trigger event\r\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\r\n    const current = interaction.activeDrops.dropzones[i];\r\n    const currentElement = interaction.activeDrops.elements [i];\r\n\r\n    // prevent trigger of duplicate events on same element\r\n    if (currentElement !== prevElement) {\r\n      // set current element as event target\r\n      event.target = currentElement;\r\n      current.fire(event);\r\n    }\r\n    prevElement = currentElement;\r\n  }\r\n}\r\n\r\n// Collect a new set of possible drops and save them in activeDrops.\r\n// setActiveDrops should always be called when a drag has just started or a\r\n// drag event happens while dynamicDrop is true\r\nfunction setActiveDrops (interaction, dragElement) {\r\n  // get dropzones and their elements that could receive the draggable\r\n  const possibleDrops = collectDrops(interaction, dragElement, true);\r\n\r\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\r\n  interaction.activeDrops.elements  = possibleDrops.elements;\r\n  interaction.activeDrops.rects     = [];\r\n\r\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\r\n    interaction.activeDrops.rects[i] =\r\n      interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\r\n  }\r\n}\r\n\r\nfunction getDrop (dragEvent, event, dragElement) {\r\n  const interaction = dragEvent.interaction;\r\n  const validDrops = [];\r\n\r\n  if (dynamicDrop) {\r\n    setActiveDrops(interaction, dragElement);\r\n  }\r\n\r\n  // collect all dropzones and their elements which qualify for a drop\r\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\r\n    const current        = interaction.activeDrops.dropzones[j];\r\n    const currentElement = interaction.activeDrops.elements [j];\r\n    const rect           = interaction.activeDrops.rects    [j];\r\n\r\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\r\n      ? currentElement\r\n      : null);\r\n  }\r\n\r\n  // get the most appropriate dropzone based on DOM depth and order\r\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\r\n\r\n  return {\r\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\r\n    element : interaction.activeDrops.elements [dropIndex] || null,\r\n  };\r\n}\r\n\r\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\r\n  const dropEvents = {\r\n    enter     : null,\r\n    leave     : null,\r\n    activate  : null,\r\n    deactivate: null,\r\n    move      : null,\r\n    drop      : null,\r\n  };\r\n\r\n  const tmpl = {\r\n    dragEvent,\r\n    interaction,\r\n    target       : interaction.dropElement,\r\n    dropzone     : interaction.dropTarget,\r\n    relatedTarget: dragEvent.target,\r\n    draggable    : dragEvent.interactable,\r\n    timeStamp    : dragEvent.timeStamp,\r\n  };\r\n\r\n  if (interaction.dropElement !== interaction.prevDropElement) {\r\n    // if there was a prevDropTarget, create a dragleave event\r\n    if (interaction.prevDropTarget) {\r\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\r\n\r\n      dragEvent.dragLeave    = dropEvents.leave.target   = interaction.prevDropElement;\r\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\r\n    }\r\n    // if the dropTarget is not null, create a dragenter event\r\n    if (interaction.dropTarget) {\r\n      dropEvents.enter = {\r\n        dragEvent,\r\n        interaction,\r\n        target       : interaction.dropElement,\r\n        dropzone     : interaction.dropTarget,\r\n        relatedTarget: dragEvent.target,\r\n        draggable    : dragEvent.interactable,\r\n        timeStamp    : dragEvent.timeStamp,\r\n        type         : 'dragenter',\r\n      };\r\n\r\n      dragEvent.dragEnter = interaction.dropElement;\r\n      dragEvent.dropzone = interaction.dropTarget;\r\n    }\r\n  }\r\n\r\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\r\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\r\n\r\n    dragEvent.dropzone = interaction.dropTarget;\r\n    dragEvent.relatedTarget = interaction.dropElement;\r\n  }\r\n  if (dragEvent.type === 'dragstart') {\r\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\r\n\r\n    dropEvents.activate.target   = null;\r\n    dropEvents.activate.dropzone = null;\r\n  }\r\n  if (dragEvent.type === 'dragend') {\r\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\r\n\r\n    dropEvents.deactivate.target   = null;\r\n    dropEvents.deactivate.dropzone = null;\r\n  }\r\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\r\n    dropEvents.move = utils.extend({\r\n      dragmove     : dragEvent,\r\n      type         : 'dropmove',\r\n    }, tmpl);\r\n\r\n    dragEvent.dropzone = interaction.dropTarget;\r\n  }\r\n\r\n  return dropEvents;\r\n}\r\n\r\nfunction fireDropEvents (interaction, dropEvents) {\r\n  if (dropEvents.leave) { interaction.prevDropTarget.fire(dropEvents.leave); }\r\n  if (dropEvents.move ) {     interaction.dropTarget.fire(dropEvents.move ); }\r\n  if (dropEvents.enter) {     interaction.dropTarget.fire(dropEvents.enter); }\r\n  if (dropEvents.drop ) {     interaction.dropTarget.fire(dropEvents.drop ); }\r\n  if (dropEvents.deactivate) {\r\n    fireActiveDrops(interaction, dropEvents.deactivate);\r\n  }\r\n\r\n  interaction.prevDropTarget  = interaction.dropTarget;\r\n  interaction.prevDropElement = interaction.dropElement;\r\n}\r\n\r\n/*\\\r\n * Interactable.dropzone\r\n [ method ]\r\n *\r\n * Returns or sets whether elements can be dropped onto this\r\n * Interactable to trigger drop events\r\n *\r\n * Dropzones can receive the following events:\r\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\r\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\r\n *  - `dragmove` when a draggable that has entered the dropzone is moved\r\n *  - `drop` when a draggable is dropped into this dropzone\r\n *\r\n * Use the `accept` option to allow only elements that match the given CSS\r\n * selector or element. The value can be:\r\n *\r\n *  - **an Element** - only that element can be dropped into this dropzone.\r\n *  - **a string**, - the element being dragged must match it as a CSS selector.\r\n *  - **`null`** - accept options is cleared - it accepts any element.\r\n *\r\n * Use the `overlap` option to set how drops are checked for. The allowed\r\n * values are:\r\n *\r\n *   - `'pointer'`, the pointer must be over the dropzone (default)\r\n *   - `'center'`, the draggable element's center must be over the dropzone\r\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\r\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\r\n *   over the dropzone\r\n *\r\n * Use the `checker` option to specify a function to check if a dragged\r\n * element is over this Interactable.\r\n *\r\n | interact(target)\r\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\r\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\r\n |                       dropped,           // bool result of the default checker\r\n |                       dropzone,          // dropzone Interactable\r\n |                       dropElement,       // dropzone elemnt\r\n |                       draggable,         // draggable Interactable\r\n |                       draggableElement) {// draggable element\r\n |\r\n |   return dropped && event.target.hasAttribute('allow-drop');\r\n | }\r\n *\r\n *\r\n - options (boolean | object | null) #optional The new value to be set.\r\n | interact('.drop').dropzone({\r\n |   accept: '.can-drop' || document.getElementById('single-drop'),\r\n |   overlap: 'pointer' || 'center' || zeroToOne\r\n | }\r\n = (boolean | object) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.dropzone = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.drop.enabled = options.enabled === false? false: true;\r\n\r\n    if (utils.is.function(options.ondrop)          ) { this.events.ondrop           = options.ondrop          ; }\r\n    if (utils.is.function(options.ondropactivate)  ) { this.events.ondropactivate   = options.ondropactivate  ; }\r\n    if (utils.is.function(options.ondropdeactivate)) { this.events.ondropdeactivate = options.ondropdeactivate; }\r\n    if (utils.is.function(options.ondragenter)     ) { this.events.ondragenter      = options.ondragenter     ; }\r\n    if (utils.is.function(options.ondragleave)     ) { this.events.ondragleave      = options.ondragleave     ; }\r\n    if (utils.is.function(options.ondropmove)      ) { this.events.ondropmove       = options.ondropmove      ; }\r\n\r\n    if (/^(pointer|center)$/.test(options.overlap)) {\r\n      this.options.drop.overlap = options.overlap;\r\n    }\r\n    else if (utils.is.number(options.overlap)) {\r\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\r\n    }\r\n    if ('accept' in options) {\r\n      this.options.drop.accept = options.accept;\r\n    }\r\n    if ('checker' in options) {\r\n      this.options.drop.checker = options.checker;\r\n    }\r\n\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.is.bool(options)) {\r\n    this.options.drop.enabled = options;\r\n\r\n    if (!options) {\r\n      this.ondragenter = this.ondragleave = this.ondrop\r\n        = this.ondropactivate = this.ondropdeactivate = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.drop;\r\n};\r\n\r\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\r\n  let dropped = false;\r\n\r\n  // if the dropzone has no rect (eg. display: none)\r\n  // call the custom dropChecker or just return false\r\n  if (!(rect = rect || this.getRect(dropElement))) {\r\n    return (this.options.drop.checker\r\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\r\n      : false);\r\n  }\r\n\r\n  const dropOverlap = this.options.drop.overlap;\r\n\r\n  if (dropOverlap === 'pointer') {\r\n    const origin = utils.getOriginXY(draggable, draggableElement, 'drag');\r\n    const page = utils.getPageXY(dragEvent);\r\n\r\n    page.x += origin.x;\r\n    page.y += origin.y;\r\n\r\n    const horizontal = (page.x > rect.left) && (page.x < rect.right);\r\n    const vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\r\n\r\n    dropped = horizontal && vertical;\r\n  }\r\n\r\n  const dragRect = draggable.getRect(draggableElement);\r\n\r\n  if (dragRect && dropOverlap === 'center') {\r\n    const cx = dragRect.left + dragRect.width  / 2;\r\n    const cy = dragRect.top  + dragRect.height / 2;\r\n\r\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\r\n  }\r\n\r\n  if (dragRect && utils.is.number(dropOverlap)) {\r\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\r\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\r\n\r\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\r\n\r\n    dropped = overlapRatio >= dropOverlap;\r\n  }\r\n\r\n  if (this.options.drop.checker) {\r\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\r\n  }\r\n\r\n  return dropped;\r\n};\r\n\r\nInteractable.signals.on('unset', function ({ interactable }) {\r\n  interactable.dropzone(false);\r\n});\r\n\r\nInteractable.settingsMethods.push('dropChecker');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\r\n  interaction.dropElement     = null; // the element at the time of checking\r\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\r\n  interaction.prevDropElement = null; // the element at the time of checking\r\n  interaction.dropEvents      = null; // the dropEvents related to the current drag event\r\n\r\n  interaction.activeDrops = {\r\n    dropzones: [],      // the dropzones that are mentioned below\r\n    elements : [],      // elements of dropzones that accept the target draggable\r\n    rects    : [],      // the rects of the elements mentioned above\r\n  };\r\n\r\n});\r\n\r\nInteraction.signals.on('stop', function ({ interaction }) {\r\n  interaction.dropTarget = interaction.dropElement =\r\n    interaction.prevDropTarget = interaction.prevDropElement = null;\r\n});\r\n\r\n/*\\\r\n * interact.dynamicDrop\r\n [ method ]\r\n *\r\n * Returns or sets whether the dimensions of dropzone elements are\r\n * calculated on every dragmove or only on dragstart for the default\r\n * dropChecker\r\n *\r\n - newValue (boolean) #optional True to check on each move. False to check only before start\r\n = (boolean | interact) The current setting or interact\r\n\\*/\r\ninteract.dynamicDrop = function (newValue) {\r\n  if (utils.is.bool(newValue)) {\r\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\r\n      //calcRects(dropzones);\r\n    //}\r\n\r\n    dynamicDrop = newValue;\r\n\r\n    return interact;\r\n  }\r\n  return dynamicDrop;\r\n};\r\n\r\nutils.merge(Interactable.eventTypes, [\r\n  'dragenter',\r\n  'dragleave',\r\n  'dropactivate',\r\n  'dropdeactivate',\r\n  'dropmove',\r\n  'drop',\r\n]);\r\nactions.methodDict.drop = 'dropzone';\r\n\r\ndefaultOptions.drop = drop.defaults;\r\n\r\nmodule.exports = drop;\r\n","const actions        = require('./base');\r\nconst utils          = require('../utils');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst gesture = {\r\n  defaults: {\r\n    enabled : false,\r\n    origin  : null,\r\n    restrict: null,\r\n  },\r\n\r\n  checker: function (pointer, event, interactable, element, interaction) {\r\n    if (interaction.pointerIds.length >= 2) {\r\n      return { name: 'gesture' };\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  getCursor: function () {\r\n    return '';\r\n  },\r\n};\r\n\r\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\r\n  if (iEvent.type !== 'gesturestart') { return; }\r\n  iEvent.ds = 0;\r\n\r\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = iEvent.distance;\r\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = iEvent.angle;\r\n  interaction.gesture.scale = 1;\r\n});\r\n\r\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\r\n  if (iEvent.type !== 'gesturemove') { return; }\r\n\r\n  iEvent.ds = iEvent.scale - interaction.gesture.scale;\r\n\r\n  interaction.target.fire(iEvent);\r\n\r\n  interaction.gesture.prevAngle = iEvent.angle;\r\n  interaction.gesture.prevDistance = iEvent.distance;\r\n\r\n  if (iEvent.scale !== Infinity\r\n      && iEvent.scale !== null\r\n      && iEvent.scale !== undefined\r\n      && !isNaN(iEvent.scale)) {\r\n\r\n    interaction.gesture.scale = iEvent.scale;\r\n  }\r\n});\r\n\r\n/*\\\r\n * Interactable.gesturable\r\n [ method ]\r\n *\r\n * Gets or sets whether multitouch gestures can be performed on the\r\n * Interactable's element\r\n *\r\n = (boolean) Indicates if this can be the target of gesture events\r\n   | var isGestureable = interact(element).gesturable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\r\n = (object) this Interactable\r\n | interact(element).gesturable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // limit multiple gestures.\r\n |     // See the explanation in @Interactable.draggable example\r\n |     max: Infinity,\r\n |     maxPerElement: 1,\r\n | });\r\n\\*/\r\nInteractable.prototype.gesturable = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.gesture.enabled = options.enabled === false? false: true;\r\n    this.setPerAction('gesture', options);\r\n    this.setOnEvents('gesture', options);\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.is.bool(options)) {\r\n    this.options.gesture.enabled = options;\r\n\r\n    if (!options) {\r\n      this.ongesturestart = this.ongesturestart = this.ongestureend = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.gesture;\r\n};\r\n\r\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action, event, starting, ending, deltaSource }) {\r\n  if (action !== 'gesture') { return; }\r\n\r\n  const pointers = interaction.pointers;\r\n\r\n  iEvent.touches = [pointers[0], pointers[1]];\r\n\r\n  if (starting) {\r\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\r\n    iEvent.box      = utils.touchBBox(pointers);\r\n    iEvent.scale    = 1;\r\n    iEvent.ds       = 0;\r\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\r\n    iEvent.da       = 0;\r\n  }\r\n  else if (ending || event instanceof InteractEvent) {\r\n    iEvent.distance = interaction.prevEvent.distance;\r\n    iEvent.box      = interaction.prevEvent.box;\r\n    iEvent.scale    = interaction.prevEvent.scale;\r\n    iEvent.ds       = iEvent.scale - 1;\r\n    iEvent.angle    = interaction.prevEvent.angle;\r\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\r\n  }\r\n  else {\r\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\r\n    iEvent.box      = utils.touchBBox(pointers);\r\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\r\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\r\n\r\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\r\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\r\n  }\r\n});\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.gesture = {\r\n    start: { x: 0, y: 0 },\r\n\r\n    startDistance: 0,   // distance between two touches of touchStart\r\n    prevDistance : 0,\r\n    distance     : 0,\r\n\r\n    scale: 1,           // gesture.distance / gesture.startDistance\r\n\r\n    startAngle: 0,      // angle of line joining two touches\r\n    prevAngle : 0,      // angle of the previous gesture event\r\n  };\r\n});\r\n\r\nactions.gesture = gesture;\r\nactions.names.push('gesture');\r\nutils.merge(Interactable.eventTypes, [\r\n  'gesturestart',\r\n  'gesturemove',\r\n  'gestureend',\r\n]);\r\nactions.methodDict.gesture = 'gesturable';\r\n\r\ndefaultOptions.gesture = gesture.defaults;\r\n\r\nmodule.exports = gesture;\r\n","const actions        = require('./base');\r\nconst utils          = require('../utils');\r\nconst browser        = require('../utils/browser');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\n// Less Precision with touch input\r\nconst defaultMargin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\r\n\r\nconst resize = {\r\n  defaults: {\r\n    enabled     : false,\r\n    mouseButtons: null,\r\n\r\n    origin    : null,\r\n    snap      : null,\r\n    restrict  : null,\r\n    inertia   : null,\r\n    autoScroll: null,\r\n\r\n    square: false,\r\n    preserveAspectRatio: false,\r\n    axis: 'xy',\r\n\r\n    // use default margin\r\n    margin: NaN,\r\n\r\n    // object with props left, right, top, bottom which are\r\n    // true/false values to resize when the pointer is over that edge,\r\n    // CSS selectors to match the handles for each direction\r\n    // or the Elements for each handle\r\n    edges: null,\r\n\r\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n    // 'negate' will alow the rect to have negative width/height\r\n    // 'reposition' will keep the width/height positive by swapping\r\n    // the top and bottom edges and/or swapping the left and right edges\r\n    invert: 'none',\r\n  },\r\n\r\n  checker: function (pointer, event, interactable, element, interaction, rect) {\r\n    if (!rect) { return null; }\r\n\r\n    const page = utils.extend({}, interaction.curCoords.page);\r\n    const options = interactable.options;\r\n\r\n    if (options.resize.enabled) {\r\n      const resizeOptions = options.resize;\r\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\r\n\r\n      // if using resize.edges\r\n      if (utils.is.object(resizeOptions.edges)) {\r\n        for (const edge in resizeEdges) {\r\n          resizeEdges[edge] = checkResizeEdge(edge,\r\n                                              resizeOptions.edges[edge],\r\n                                              page,\r\n                                              interaction._eventTarget,\r\n                                              element,\r\n                                              rect,\r\n                                              resizeOptions.margin || defaultMargin);\r\n        }\r\n\r\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\r\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\r\n\r\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\r\n          return {\r\n            name: 'resize',\r\n            edges: resizeEdges,\r\n          };\r\n        }\r\n      }\r\n      else {\r\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - defaultMargin);\r\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - defaultMargin);\r\n\r\n        if (right || bottom) {\r\n          return {\r\n            name: 'resize',\r\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  cursors: (browser.isIe9OrOlder ? {\r\n    x : 'e-resize',\r\n    y : 's-resize',\r\n    xy: 'se-resize',\r\n\r\n    top        : 'n-resize',\r\n    left       : 'w-resize',\r\n    bottom     : 's-resize',\r\n    right      : 'e-resize',\r\n    topleft    : 'se-resize',\r\n    bottomright: 'se-resize',\r\n    topright   : 'ne-resize',\r\n    bottomleft : 'ne-resize',\r\n  } : {\r\n    x : 'ew-resize',\r\n    y : 'ns-resize',\r\n    xy: 'nwse-resize',\r\n\r\n    top        : 'ns-resize',\r\n    left       : 'ew-resize',\r\n    bottom     : 'ns-resize',\r\n    right      : 'ew-resize',\r\n    topleft    : 'nwse-resize',\r\n    bottomright: 'nwse-resize',\r\n    topright   : 'nesw-resize',\r\n    bottomleft : 'nesw-resize',\r\n  }),\r\n\r\n  getCursor: function (action) {\r\n    if (action.axis) {\r\n      return resize.cursors[action.name + action.axis];\r\n    }\r\n    else if (action.edges) {\r\n      let cursorKey = '';\r\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\r\n\r\n      for (let i = 0; i < 4; i++) {\r\n        if (action.edges[edgeNames[i]]) {\r\n          cursorKey += edgeNames[i];\r\n        }\r\n      }\r\n\r\n      return resize.cursors[cursorKey];\r\n    }\r\n  },\r\n};\r\n\r\n// resizestart\r\nInteractEvent.signals.on('new', function ({ iEvent, interaction }) {\r\n  if (iEvent.type !== 'resizestart' || !interaction.prepared.edges) {\r\n    return;\r\n  }\r\n\r\n  const startRect = interaction.target.getRect(interaction.element);\r\n  const resizeOptions = interaction.target.options.resize;\r\n\r\n  /*\r\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\r\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\r\n   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\r\n   * on the active edges and the edge being interacted with.\r\n   */\r\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\r\n    const linkedEdges = utils.extend({}, interaction.prepared.edges);\r\n\r\n    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\r\n    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\r\n    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\r\n    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\r\n\r\n    interaction.prepared._linkedEdges = linkedEdges;\r\n  }\r\n  else {\r\n    interaction.prepared._linkedEdges = null;\r\n  }\r\n\r\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\r\n  if (resizeOptions.preserveAspectRatio) {\r\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height;\r\n  }\r\n\r\n  interaction.resizeRects = {\r\n    start     : startRect,\r\n    current   : utils.extend({}, startRect),\r\n    inverted  : utils.extend({}, startRect),\r\n    previous  : utils.extend({}, startRect),\r\n    delta     : {\r\n      left: 0, right : 0, width : 0,\r\n      top : 0, bottom: 0, height: 0,\r\n    },\r\n  };\r\n\r\n  iEvent.rect = interaction.resizeRects.inverted;\r\n  iEvent.deltaRect = interaction.resizeRects.delta;\r\n});\r\n\r\n// resizemove\r\nInteractEvent.signals.on('new', function ({ iEvent, phase, interaction }) {\r\n  if (phase !== 'move' || !interaction.prepared.edges) { return; }\r\n\r\n  const resizeOptions = interaction.target.options.resize;\r\n  const invert = resizeOptions.invert;\r\n  const invertible = invert === 'reposition' || invert === 'negate';\r\n\r\n  let edges = interaction.prepared.edges;\r\n\r\n  const start      = interaction.resizeRects.start;\r\n  const current    = interaction.resizeRects.current;\r\n  const inverted   = interaction.resizeRects.inverted;\r\n  const delta      = interaction.resizeRects.delta;\r\n  const previous   = utils.extend(interaction.resizeRects.previous, inverted);\r\n  const originalEdges = edges;\r\n\r\n  let dx = iEvent.dx;\r\n  let dy = iEvent.dy;\r\n\r\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\r\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\r\n    const startAspectRatio = resizeOptions.preserveAspectRatio\r\n      ? interaction.resizeStartAspectRatio\r\n      : 1;\r\n\r\n    edges = interaction.prepared._linkedEdges;\r\n\r\n    if ((originalEdges.left && originalEdges.bottom)\r\n        || (originalEdges.right && originalEdges.top)) {\r\n      dy = -dx / startAspectRatio;\r\n    }\r\n    else if (originalEdges.left || originalEdges.right ) { dy = dx / startAspectRatio; }\r\n    else if (originalEdges.top  || originalEdges.bottom) { dx = dy * startAspectRatio; }\r\n  }\r\n\r\n  // update the 'current' rect without modifications\r\n  if (edges.top   ) { current.top    += dy; }\r\n  if (edges.bottom) { current.bottom += dy; }\r\n  if (edges.left  ) { current.left   += dx; }\r\n  if (edges.right ) { current.right  += dx; }\r\n\r\n  if (invertible) {\r\n    // if invertible, copy the current rect\r\n    utils.extend(inverted, current);\r\n\r\n    if (invert === 'reposition') {\r\n      // swap edge values if necessary to keep width/height positive\r\n      let swap;\r\n\r\n      if (inverted.top > inverted.bottom) {\r\n        swap = inverted.top;\r\n\r\n        inverted.top = inverted.bottom;\r\n        inverted.bottom = swap;\r\n      }\r\n      if (inverted.left > inverted.right) {\r\n        swap = inverted.left;\r\n\r\n        inverted.left = inverted.right;\r\n        inverted.right = swap;\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    // if not invertible, restrict to minimum of 0x0 rect\r\n    inverted.top    = Math.min(current.top, start.bottom);\r\n    inverted.bottom = Math.max(current.bottom, start.top);\r\n    inverted.left   = Math.min(current.left, start.right);\r\n    inverted.right  = Math.max(current.right, start.left);\r\n  }\r\n\r\n  inverted.width  = inverted.right  - inverted.left;\r\n  inverted.height = inverted.bottom - inverted.top ;\r\n\r\n  for (const edge in inverted) {\r\n    delta[edge] = inverted[edge] - previous[edge];\r\n  }\r\n\r\n  iEvent.edges = interaction.prepared.edges;\r\n  iEvent.rect = inverted;\r\n  iEvent.deltaRect = delta;\r\n});\r\n\r\n/*\\\r\n * Interactable.resizable\r\n [ method ]\r\n *\r\n * Gets or sets whether resize actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of resize elements\r\n   | var isResizeable = interact('input[type=text]').resizable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\r\n = (object) This Interactable\r\n   | interact(element).resizable({\r\n   |   onstart: function (event) {},\r\n   |   onmove : function (event) {},\r\n   |   onend  : function (event) {},\r\n   |\r\n   |   edges: {\r\n   |     top   : true,       // Use pointer coords to check for resize.\r\n   |     left  : false,      // Disable resizing from left edge.\r\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\r\n   |     right : handleEl    // Resize if pointer target is the given Element\r\n   |   },\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height are adjusted at a 1:1 ratio.\r\n   |     square: false,\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height maintain the aspect ratio they had when resizing started.\r\n   |     preserveAspectRatio: false,\r\n   |\r\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n   |   // 'negate' will allow the rect to have negative width/height\r\n   |   // 'reposition' will keep the width/height positive by swapping\r\n   |   // the top and bottom edges and/or swapping the left and right edges\r\n   |   invert: 'none' || 'negate' || 'reposition'\r\n   |\r\n   |   // limit multiple resizes.\r\n   |   // See the explanation in the @Interactable.draggable example\r\n   |   max: Infinity,\r\n   |   maxPerElement: 1,\r\n   | });\r\n  \\*/\r\nInteractable.prototype.resizable = function (options) {\r\n  if (utils.is.object(options)) {\r\n    this.options.resize.enabled = options.enabled === false? false: true;\r\n    this.setPerAction('resize', options);\r\n    this.setOnEvents('resize', options);\r\n\r\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\r\n      this.options.resize.axis = options.axis;\r\n    }\r\n    else if (options.axis === null) {\r\n      this.options.resize.axis = defaultOptions.resize.axis;\r\n    }\r\n\r\n    if (utils.is.bool(options.preserveAspectRatio)) {\r\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\r\n    }\r\n    else if (utils.is.bool(options.square)) {\r\n      this.options.resize.square = options.square;\r\n    }\r\n\r\n    return this;\r\n  }\r\n  if (utils.is.bool(options)) {\r\n    this.options.resize.enabled = options;\r\n\r\n    if (!options) {\r\n      this.onresizestart = this.onresizestart = this.onresizeend = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n  return this.options.resize;\r\n};\r\n\r\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\r\n  // false, '', undefined, null\r\n  if (!value) { return false; }\r\n\r\n  // true value, use pointer coords and element rect\r\n  if (value === true) {\r\n    // if dimensions are negative, \"switch\" edges\r\n    const width  = utils.is.number(rect.width )? rect.width  : rect.right  - rect.left;\r\n    const height = utils.is.number(rect.height)? rect.height : rect.bottom - rect.top ;\r\n\r\n    if (width < 0) {\r\n      if      (name === 'left' ) { name = 'right'; }\r\n      else if (name === 'right') { name = 'left' ; }\r\n    }\r\n    if (height < 0) {\r\n      if      (name === 'top'   ) { name = 'bottom'; }\r\n      else if (name === 'bottom') { name = 'top'   ; }\r\n    }\r\n\r\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\r\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\r\n\r\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\r\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\r\n  }\r\n\r\n  // the remaining checks require an element\r\n  if (!utils.is.element(element)) { return false; }\r\n\r\n  return utils.is.element(value)\r\n  // the value is an element to use as a resize handle\r\n    ? value === element\r\n    // otherwise check if element matches value as selector\r\n    : utils.matchesUpTo(element, value, interactableElement);\r\n}\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.resizeAxes = 'xy';\r\n});\r\n\r\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action }) {\r\n  if (action !== 'resize' || !interaction.resizeAxes) { return; }\r\n\r\n  const options = interaction.target.options;\r\n\r\n  if (options.resize.square) {\r\n    if (interaction.resizeAxes === 'y') {\r\n      iEvent.dx = iEvent.dy;\r\n    }\r\n    else {\r\n      iEvent.dy = iEvent.dx;\r\n    }\r\n    iEvent.axes = 'xy';\r\n  }\r\n  else {\r\n    iEvent.axes = interaction.resizeAxes;\r\n\r\n    if (interaction.resizeAxes === 'x') {\r\n      iEvent.dy = 0;\r\n    }\r\n    else if (interaction.resizeAxes === 'y') {\r\n      iEvent.dx = 0;\r\n    }\r\n  }\r\n});\r\n\r\nactions.resize = resize;\r\nactions.names.push('resize');\r\nutils.merge(Interactable.eventTypes, [\r\n  'resizestart',\r\n  'resizemove',\r\n  'resizeinertiastart',\r\n  'resizeinertiaresume',\r\n  'resizeend',\r\n]);\r\nactions.methodDict.resize = 'resizable';\r\n\r\ndefaultOptions.resize = resize.defaults;\r\n\r\nmodule.exports = resize;\r\n","const raf            = require('./utils/raf');\r\nconst getWindow      = require('./utils/window').getWindow;\r\nconst is             = require('./utils/is');\r\nconst domUtils       = require('./utils/domUtils');\r\nconst Interaction    = require('./Interaction');\r\nconst defaultOptions = require('./defaultOptions');\r\n\r\nconst autoScroll = {\r\n  defaults: {\r\n    enabled  : false,\r\n    container: null,     // the item that is scrolled (Window or HTMLElement)\r\n    margin   : 60,\r\n    speed    : 300,      // the scroll speed in pixels per second\r\n  },\r\n\r\n  interaction: null,\r\n  i: null,    // the handle returned by window.setInterval\r\n  x: 0, y: 0, // Direction each pulse is to scroll in\r\n\r\n  isScrolling: false,\r\n  prevTime: 0,\r\n\r\n  parentIframePageInfo: null, //Property to handle page info of parent iframe (iFrameResizer)\r\n\r\n  start: function (interaction) {\r\n    autoScroll.isScrolling = true;\r\n    raf.cancel(autoScroll.i);\r\n\r\n    autoScroll.interaction = interaction;\r\n    autoScroll.prevTime = new Date().getTime();\r\n    autoScroll.i = raf.request(autoScroll.scroll);\r\n    if (typeof window !== undefined && window.parentIFrame) { //iFrameResizer\r\n        window.parentIFrame.getPageInfo(function(pageInfo) {\r\n            autoScroll.parentIframePageInfo = pageInfo;\r\n        });\r\n    }\r\n  },\r\n\r\n  stop: function () {\r\n    autoScroll.isScrolling = false;\r\n    raf.cancel(autoScroll.i);\r\n    autoScroll.parentIframePageInfo = null; //iFrameResizer\r\n  },\r\n\r\n  // scroll the window by the values in scroll.x/y\r\n  scroll: function () {\r\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\r\n    const container = options.container || getWindow(autoScroll.interaction.element);\r\n    const now = new Date().getTime();\r\n    // change in time in seconds\r\n    const dt = (now - autoScroll.prevTime) / 1000;\r\n    // displacement\r\n    const s = options.speed * dt;\r\n\r\n    if (s >= 1) {\r\n      if (autoScroll.parentIframePageInfo && autoScroll.parentIframePageInfo.innerHeight) { //iFrameResizer\r\n        autoScroll.parentIframePageInfo.scrollLeft += autoScroll.x * s;\r\n        autoScroll.parentIframePageInfo.scrollTop += autoScroll.y * s;\r\n          if (autoScroll.x != 0 || autoScroll.y != 0) {\r\n            window.parentIFrame.scrollTo(autoScroll.parentIframePageInfo.scrollLeft,\r\n             autoScroll.parentIframePageInfo.scrollTop);\r\n          }\r\n      }\r\n      if (is.window(container)) {\r\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\r\n      }\r\n      else if (container) {\r\n        container.scrollLeft += autoScroll.x * s;\r\n        container.scrollTop  += autoScroll.y * s;\r\n      }\r\n\r\n      autoScroll.prevTime = now;\r\n    }\r\n\r\n    if (autoScroll.isScrolling) {\r\n      raf.cancel(autoScroll.i);\r\n      autoScroll.i = raf.request(autoScroll.scroll);\r\n    }\r\n  },\r\n  check: function (interactable, actionName) {\r\n    const options = interactable.options;\r\n\r\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\r\n  },\r\n  onInteractionMove: function ({ interaction, pointer }) {\r\n    if (!(interaction.interacting()\r\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\r\n      return;\r\n    }\r\n\r\n    if (interaction.simulation) {\r\n      autoScroll.x = autoScroll.y = 0;\r\n      return;\r\n    }\r\n\r\n    let top;\r\n    let right;\r\n    let bottom;\r\n    let left;\r\n\r\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\r\n    const container = options.container || getWindow(interaction.element);\r\n\r\n    if (autoScroll.parentIframePageInfo && autoScroll.parentIframePageInfo.innerHeight) { //iFrameResizer\r\n        //calculate real pointer coordinates on the screen\r\n        let screenX = pointer.clientX -\r\n            autoScroll.parentIframePageInfo.scrollLeft +\r\n            autoScroll.parentIframePageInfo.offsetLeft;\r\n        let screenY = pointer.clientY -\r\n            autoScroll.parentIframePageInfo.scrollTop +\r\n            autoScroll.parentIframePageInfo.offsetTop;\r\n\r\n        left = screenX < autoScroll.margin;\r\n        top = screenY < autoScroll.margin;\r\n        right = screenX > autoScroll.parentIframePageInfo.innerWidth - autoScroll.margin;\r\n        bottom = screenY > autoScroll.parentIframePageInfo.innerHeight - autoScroll.margin;\r\n    }\r\n    else if (is.window(container)) {\r\n      left   = pointer.clientX < autoScroll.margin;\r\n      top    = pointer.clientY < autoScroll.margin;\r\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\r\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\r\n    }\r\n    else {\r\n      const rect = domUtils.getElementClientRect(container);\r\n\r\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\r\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\r\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\r\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\r\n    }\r\n\r\n    autoScroll.x = (right ? 1: left? -1: 0);\r\n    autoScroll.y = (bottom? 1:  top? -1: 0);\r\n\r\n    if (!autoScroll.isScrolling) {\r\n      // set the autoScroll properties to those of the target\r\n      autoScroll.margin = options.margin;\r\n      autoScroll.speed  = options.speed;\r\n\r\n      autoScroll.start(interaction);\r\n    }\r\n  },\r\n};\r\n\r\nInteraction.signals.on('stop-active', function () {\r\n  autoScroll.stop();\r\n});\r\n\r\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\r\n\r\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\r\n\r\nmodule.exports = autoScroll;\r\n","const Interactable = require('../Interactable');\r\nconst actions      = require('../actions/base');\r\nconst is           = require('../utils/is');\r\nconst domUtils     = require('../utils/domUtils');\r\n\r\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\r\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\r\n\r\n  if (this.options.actionChecker) {\r\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\r\n  }\r\n\r\n  return action;\r\n};\r\n\r\n/*\\\r\n * Interactable.ignoreFrom\r\n [ method ]\r\n *\r\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\r\n * event or any of it's parents match the given CSS selector or\r\n * Element, no drag/resize/gesture is started.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\r\n = (string | Element | object) The current ignoreFrom value or this Interactable\r\n **\r\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\r\n | // or\r\n | interact(element).ignoreFrom('input, textarea, a');\r\n\\*/\r\nInteractable.prototype.ignoreFrom = function (newValue) {\r\n  return this._backCompatOption('ignoreFrom', newValue);\r\n};\r\n\r\n/*\\\r\n * Interactable.allowFrom\r\n [ method ]\r\n *\r\n * A drag/resize/gesture is started only If the target of the\r\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\r\n * parents match the given CSS selector or Element.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\r\n = (string | Element | object) The current allowFrom value or this Interactable\r\n **\r\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\r\n | // or\r\n | interact(element).allowFrom('.handle');\r\n\\*/\r\nInteractable.prototype.allowFrom = function (newValue) {\r\n  return this._backCompatOption('allowFrom', newValue);\r\n};\r\n\r\nInteractable.prototype.testIgnore = function (ignoreFrom, interactableElement, element) {\r\n  if (!ignoreFrom || !is.element(element)) { return false; }\r\n\r\n  if (is.string(ignoreFrom)) {\r\n    return domUtils.matchesUpTo(element, ignoreFrom, interactableElement);\r\n  }\r\n  else if (is.element(ignoreFrom)) {\r\n    return domUtils.nodeContains(ignoreFrom, element);\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nInteractable.prototype.testAllow = function (allowFrom, interactableElement, element) {\r\n  if (!allowFrom) { return true; }\r\n\r\n  if (!is.element(element)) { return false; }\r\n\r\n  if (is.string(allowFrom)) {\r\n    return domUtils.matchesUpTo(element, allowFrom, interactableElement);\r\n  }\r\n  else if (is.element(allowFrom)) {\r\n    return domUtils.nodeContains(allowFrom, element);\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nInteractable.prototype.testIgnoreAllow = function (options, interactableElement, eventTarget) {\r\n  return (!this.testIgnore(options.ignoreFrom, interactableElement, eventTarget)\r\n    && this.testAllow(options.allowFrom, interactableElement, eventTarget));\r\n};\r\n\r\n/*\\\r\n * Interactable.actionChecker\r\n [ method ]\r\n *\r\n * Gets or sets the function used to check action to be performed on\r\n * pointerDown\r\n *\r\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\r\n = (Function | Interactable) The checker function or this Interactable\r\n *\r\n | interact('.resize-drag')\r\n |   .resizable(true)\r\n |   .draggable(true)\r\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\r\n |\r\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\r\n |     // force drag with handle target\r\n |     action.name = drag;\r\n |   }\r\n |   else {\r\n |     // resize from the top and right edges\r\n |     action.name  = 'resize';\r\n |     action.edges = { top: true, right: true };\r\n |   }\r\n |\r\n |   return action;\r\n | });\r\n\\*/\r\nInteractable.prototype.actionChecker = function (checker) {\r\n  if (is.function(checker)) {\r\n    this.options.actionChecker = checker;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (checker === null) {\r\n    delete this.options.actionChecker;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.actionChecker;\r\n};\r\n\r\n/*\\\r\n * Interactable.styleCursor\r\n [ method ]\r\n *\r\n * Returns or sets whether the the cursor should be changed depending on the\r\n * action that would be performed if the mouse were pressed and dragged.\r\n *\r\n - newValue (boolean) #optional\r\n = (boolean | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.styleCursor = function (newValue) {\r\n  if (is.bool(newValue)) {\r\n    this.options.styleCursor = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (newValue === null) {\r\n    delete this.options.styleCursor;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.styleCursor;\r\n};\r\n\r\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\r\n  const rect = this.getRect(element);\r\n  let action = null;\r\n\r\n  for (const actionName of actions.names) {\r\n    // check mouseButton setting if the pointer is down\r\n    if (interaction.pointerIsDown\r\n        && interaction.mouse\r\n        && (event.buttons & this.options[actionName].mouseButtons) === 0) {\r\n      continue;\r\n    }\r\n\r\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\r\n\r\n    if (action) {\r\n      return action;\r\n    }\r\n  }\r\n};\r\n\r\n","const interact       = require('../interact');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst actions        = require('../actions/base');\r\nconst defaultOptions = require('../defaultOptions');\r\nconst browser        = require('../utils/browser');\r\nconst scope          = require('../scope');\r\nconst utils          = require('../utils');\r\nconst signals        = require('../utils/Signals').new();\r\n\r\nrequire('./InteractableMethods');\r\n\r\nconst autoStart = {\r\n  signals,\r\n  withinInteractionLimit,\r\n  // Allow this many interactions to happen simultaneously\r\n  maxInteractions: Infinity,\r\n  defaults: {\r\n    perAction: {\r\n      manualStart: false,\r\n      max: Infinity,\r\n      maxPerElement: 1,\r\n      allowFrom:  null,\r\n      ignoreFrom: null,\r\n    },\r\n  },\r\n  setActionDefaults: function (action) {\r\n    utils.extend(action.defaults, autoStart.defaults.perAction);\r\n  },\r\n};\r\n\r\n// set cursor style on mousedown\r\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget }) {\r\n  if (interaction.interacting()) { return; }\r\n\r\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\r\n  prepare(interaction, actionInfo);\r\n});\r\n\r\n// set cursor style on mousemove\r\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget }) {\r\n  if (!interaction.mouse\r\n      || interaction.pointerIsDown\r\n      || interaction.interacting()) { return; }\r\n\r\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\r\n  prepare(interaction, actionInfo);\r\n});\r\n\r\nInteraction.signals.on('move', function (arg) {\r\n  const { interaction, event } = arg;\r\n\r\n  if (!interaction.pointerIsDown\r\n      || interaction.interacting()\r\n      || !interaction.pointerWasMoved\r\n      || !interaction.prepared.name) {\r\n    return;\r\n  }\r\n\r\n  signals.fire('before-start', arg);\r\n\r\n  const target = interaction.target;\r\n\r\n  if (interaction.prepared.name && target) {\r\n    // check manualStart and interaction limit\r\n    if (target.options[interaction.prepared.name].manualStart\r\n        || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\r\n      interaction.stop(event);\r\n    }\r\n    else {\r\n      interaction.start(interaction.prepared, target, interaction.element);\r\n    }\r\n  }\r\n});\r\n\r\n// Check if the current target supports the action.\r\n// If so, return the validated action. Otherwise, return null\r\nfunction validateAction (action, interactable, element, eventTarget) {\r\n  if (utils.is.object(action)\r\n      && interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget)\r\n      && interactable.options[action.name].enabled\r\n      && withinInteractionLimit(interactable, element, action)) {\r\n    return action;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction validateSelector (interaction, pointer, event, matches, matchElements, eventTarget) {\r\n  for (let i = 0, len = matches.length; i < len; i++) {\r\n    const match = matches[i];\r\n    const matchElement = matchElements[i];\r\n    const action = validateAction(match.getAction(pointer, event, interaction, matchElement),\r\n                                  match,\r\n                                  matchElement,\r\n                                  eventTarget);\r\n\r\n    if (action) {\r\n      return {\r\n        action,\r\n        target: match,\r\n        element: matchElement,\r\n      };\r\n    }\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction getActionInfo (interaction, pointer, event, eventTarget) {\r\n  let matches = [];\r\n  let matchElements = [];\r\n\r\n  let element = eventTarget;\r\n  let action = null;\r\n\r\n  function pushMatches (interactable, selector, context) {\r\n    const elements = (browser.useMatchesSelectorPolyfill\r\n      ? context.querySelectorAll(selector)\r\n      : undefined);\r\n\r\n    if (utils.matchesSelector(element, selector, elements)) {\r\n\r\n      matches.push(interactable);\r\n      matchElements.push(element);\r\n    }\r\n  }\r\n\r\n  while (utils.is.element(element)) {\r\n    matches = [];\r\n    matchElements = [];\r\n\r\n    const elementInteractable = scope.interactables.get(element);\r\n\r\n    if (elementInteractable\r\n        && (action = validateAction(elementInteractable.getAction(pointer, event, interaction, element, eventTarget),\r\n                                    elementInteractable,\r\n                                    element,\r\n                                    eventTarget))\r\n        && !elementInteractable.options[action.name].manualStart) {\r\n      return {\r\n        element,\r\n        action,\r\n        target: elementInteractable,\r\n      };\r\n    }\r\n    else {\r\n      scope.interactables.forEachSelector(pushMatches, element);\r\n\r\n      const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements, eventTarget);\r\n\r\n      if (actionInfo.action\r\n          && !actionInfo.target.options[actionInfo.action.name].manualStart) {\r\n        return actionInfo;\r\n      }\r\n    }\r\n\r\n    element = utils.parentNode(element);\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction prepare (interaction, { action, target, element }) {\r\n  action = action || {};\r\n\r\n  if (interaction.target && interaction.target.options.styleCursor) {\r\n    interaction.target._doc.documentElement.style.cursor = '';\r\n  }\r\n\r\n  interaction.target = target;\r\n  interaction.element = element;\r\n  utils.copyAction(interaction.prepared, action);\r\n\r\n  if (target && target.options.styleCursor) {\r\n    const cursor = action? actions[action.name].getCursor(action) : '';\r\n    interaction.target._doc.documentElement.style.cursor = cursor;\r\n  }\r\n\r\n  signals.fire('prepared', { interaction: interaction });\r\n}\r\n\r\nInteraction.signals.on('stop', function ({ interaction }) {\r\n  const target = interaction.target;\r\n\r\n  if (target && target.options.styleCursor) {\r\n    target._doc.documentElement.style.cursor = '';\r\n  }\r\n});\r\n\r\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\r\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\r\n\r\n  if (this.options.actionChecker) {\r\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\r\n  }\r\n\r\n  return action;\r\n};\r\n\r\n/*\\\r\n * Interactable.actionChecker\r\n [ method ]\r\n *\r\n * Gets or sets the function used to check action to be performed on\r\n * pointerDown\r\n *\r\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\r\n = (Function | Interactable) The checker function or this Interactable\r\n *\r\n | interact('.resize-drag')\r\n |   .resizable(true)\r\n |   .draggable(true)\r\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\r\n |\r\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\r\n |     // force drag with handle target\r\n |     action.name = drag;\r\n |   }\r\n |   else {\r\n |     // resize from the top and right edges\r\n |     action.name  = 'resize';\r\n |     action.edges = { top: true, right: true };\r\n |   }\r\n |\r\n |   return action;\r\n | });\r\n\\*/\r\nInteractable.prototype.actionChecker = function (checker) {\r\n  if (utils.is.function(checker)) {\r\n    this.options.actionChecker = checker;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (checker === null) {\r\n    delete this.options.actionChecker;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.actionChecker;\r\n};\r\n\r\n/*\\\r\n * Interactable.styleCursor\r\n [ method ]\r\n *\r\n * Returns or sets whether the the cursor should be changed depending on the\r\n * action that would be performed if the mouse were pressed and dragged.\r\n *\r\n - newValue (boolean) #optional\r\n = (boolean | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.styleCursor = function (newValue) {\r\n  if (utils.is.bool(newValue)) {\r\n    this.options.styleCursor = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (newValue === null) {\r\n    delete this.options.styleCursor;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.styleCursor;\r\n};\r\n\r\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\r\n  const rect = this.getRect(element);\r\n  const buttons = event.buttons || ({\r\n    0: 1,\r\n    1: 4,\r\n    3: 8,\r\n    4: 16,\r\n  })[event.button];\r\n  let action = null;\r\n\r\n  for (const actionName of actions.names) {\r\n    // check mouseButton setting if the pointer is down\r\n    if (interaction.pointerIsDown\r\n        && interaction.mouse\r\n        && (buttons & this.options[actionName].mouseButtons) === 0) {\r\n      continue;\r\n    }\r\n\r\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\r\n\r\n    if (action) {\r\n      return action;\r\n    }\r\n  }\r\n};\r\n\r\nfunction withinInteractionLimit (interactable, element, action) {\r\n  const options = interactable.options;\r\n  const maxActions = options[action.name].max;\r\n  const maxPerElement = options[action.name].maxPerElement;\r\n  let activeInteractions = 0;\r\n  let targetCount = 0;\r\n  let targetElementCount = 0;\r\n\r\n  // no actions if any of these values == 0\r\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) { return; }\r\n\r\n  for (let i = 0, len = scope.interactions.length; i < len; i++) {\r\n    const interaction = scope.interactions[i];\r\n    const otherAction = interaction.prepared.name;\r\n\r\n    if (!interaction.interacting()) { continue; }\r\n\r\n    activeInteractions++;\r\n\r\n    if (activeInteractions >= autoStart.maxInteractions) {\r\n      return false;\r\n    }\r\n\r\n    if (interaction.target !== interactable) { continue; }\r\n\r\n    targetCount += (otherAction === action.name)|0;\r\n\r\n    if (targetCount >= maxActions) {\r\n      return false;\r\n    }\r\n\r\n    if (interaction.element === element) {\r\n      targetElementCount++;\r\n\r\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return autoStart.maxInteractions > 0;\r\n}\r\n\r\n/*\\\r\n * interact.maxInteractions\r\n [ method ]\r\n **\r\n * Returns or sets the maximum number of concurrent interactions allowed.\r\n * By default only 1 interaction is allowed at a time (for backwards\r\n * compatibility). To allow multiple interactions on the same Interactables\r\n * and elements, you need to enable it in the draggable, resizable and\r\n * gesturable `'max'` and `'maxPerElement'` options.\r\n **\r\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\r\n\\*/\r\ninteract.maxInteractions = function (newValue) {\r\n  if (utils.is.number(newValue)) {\r\n    autoStart.maxInteractions = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  return autoStart.maxInteractions;\r\n};\r\n\r\nInteractable.settingsMethods.push('styleCursor');\r\nInteractable.settingsMethods.push('actionChecker');\r\nInteractable.settingsMethods.push('ignoreFrom');\r\nInteractable.settingsMethods.push('allowFrom');\r\n\r\ndefaultOptions.base.actionChecker = null;\r\ndefaultOptions.base.styleCursor = true;\r\n\r\nutils.extend(defaultOptions.perAction, autoStart.defaults.perAction);\r\n\r\nmodule.exports = autoStart;\r\n","const autoStart   = require('./base');\r\nconst Interaction = require('../Interaction');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.delayTimer = null;\r\n});\r\n\r\nautoStart.signals.on('prepared', function ({ interaction }) {\r\n  const actionName = interaction.prepared.name;\r\n\r\n  if (!actionName) { return; }\r\n\r\n  const delay = interaction.target.options[actionName].delay;\r\n\r\n  if (delay > 0) {\r\n    interaction.delayTimer = setTimeout(() => {\r\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\r\n    }, delay);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('move', function ({ interaction, duplicate }) {\r\n  if (interaction.pointerWasMoved && !duplicate) {\r\n    clearTimeout(interaction.delayTimer);\r\n  }\r\n});\r\n\r\n// prevent regular down->move autoStart\r\nautoStart.signals.on('before-start', function ({ interaction }) {\r\n  const actionName = interaction.prepared.name;\r\n\r\n  if (!actionName) { return; }\r\n\r\n  const delay = interaction.target.options[actionName].delay;\r\n\r\n  if (delay > 0) {\r\n    interaction.prepared.name = null;\r\n  }\r\n});\r\n","const autoStart = require('./base');\r\nconst scope     = require('../scope');\r\nconst browser   = require('../utils/browser');\r\nconst is        = require('../utils/is');\r\n\r\nconst { matchesSelector, parentNode } = require('../utils/domUtils');\r\n\r\nautoStart.setActionDefaults(require('../actions/drag'));\r\n\r\nautoStart.signals.on('before-start',  function ({ interaction, eventTarget, dx, dy }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  // check if a drag is in the correct axis\r\n  const absX = Math.abs(dx);\r\n  const absY = Math.abs(dy);\r\n  const options = interaction.target.options.drag;\r\n  const startAxis = options.startAxis;\r\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\r\n\r\n  interaction.prepared.axis = options.lockAxis === 'start'\r\n    ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\r\n    : options.lockAxis;\r\n\r\n  // if the movement isn't in the startAxis of the interactable\r\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\r\n    // cancel the prepared action\r\n    interaction.prepared.name = null;\r\n\r\n    // then try to get a drag from another ineractable\r\n\r\n    if (!interaction.prepared.name) {\r\n\r\n      let element = eventTarget;\r\n\r\n      const getDraggable = function (interactable, selector, context) {\r\n        const elements = browser.useMatchesSelectorPolyfill\r\n            ? context.querySelectorAll(selector)\r\n            : undefined;\r\n\r\n        if (interactable === interaction.target) { return; }\r\n\r\n        if (!options.manualStart\r\n            && !interactable.testIgnoreAllow(options, element, eventTarget)\r\n            && matchesSelector(element, selector, elements)) {\r\n\r\n          const action = interactable.getAction(interaction.downPointer,\r\n                                                interaction.downEvent,\r\n                                                interaction,\r\n                                                element);\r\n\r\n          if (action\r\n              && action.name === 'drag'\r\n              && checkStartAxis(currentAxis, interactable)\r\n              && autoStart.validateAction(action, interactable, element, eventTarget)) {\r\n\r\n            return interactable;\r\n          }\r\n        }\r\n      };\r\n\r\n      let action = null;\r\n\r\n      // check all interactables\r\n      while (is.element(element)) {\r\n        const elementInteractable = scope.interactables.get(element);\r\n\r\n        if (elementInteractable\r\n            && elementInteractable !== interaction.target\r\n            && !elementInteractable.options.drag.manualStart) {\r\n\r\n          action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\r\n        }\r\n        if (action\r\n            && action.name === 'drag'\r\n            && checkStartAxis(currentAxis, elementInteractable)) {\r\n\r\n          interaction.prepared.name = 'drag';\r\n          interaction.target = elementInteractable;\r\n          interaction.element = element;\r\n          break;\r\n        }\r\n\r\n        const selectorInteractable = scope.interactables.forEachSelector(getDraggable, element);\r\n\r\n        if (selectorInteractable) {\r\n          interaction.prepared.name = 'drag';\r\n          interaction.target = selectorInteractable;\r\n          interaction.element = element;\r\n          break;\r\n        }\r\n\r\n        element = parentNode(element);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nfunction checkStartAxis (startAxis, interactable) {\r\n  if (!interactable) { return false; }\r\n\r\n  const thisAxis = interactable.options.drag.startAxis;\r\n\r\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis);\r\n}\r\n","require('./base').setActionDefaults(require('../actions/gesture'));\r\n","require('./base').setActionDefaults(require('../actions/resize'));\r\n","module.exports = {\r\n  base: {\r\n    accept        : null,\r\n    preventDefault: 'auto',\r\n    deltaSource   : 'page',\r\n  },\r\n\r\n  perAction: {\r\n    origin: { x: 0, y: 0 },\r\n\r\n    // only allow left button by default\r\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\r\n    mouseButtons: 1,\r\n\r\n    inertia: {\r\n      enabled          : false,\r\n      resistance       : 10,    // the lambda in exponential decay\r\n      minSpeed         : 100,   // target speed must be above this for inertia to start\r\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\r\n      allowResume      : true,  // allow resuming an action in inertia phase\r\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\r\n    },\r\n  },\r\n};\r\n","/* browser entry point */\r\n\r\n// Legacy browser support\r\nrequire('./legacyBrowsers');\r\n\r\n// inertia\r\nrequire('./inertia');\r\n\r\n// modifiers\r\nrequire('./modifiers/snap');\r\nrequire('./modifiers/restrict');\r\n\r\n// pointerEvents\r\nrequire('./pointerEvents/base');\r\nrequire('./pointerEvents/holdRepeat');\r\nrequire('./pointerEvents/interactableTargets');\r\n\r\n// delay\r\nrequire('./autoStart/delay');\r\n\r\n// actions\r\nrequire('./actions/gesture');\r\nrequire('./actions/resize');\r\nrequire('./actions/drag');\r\nrequire('./actions/drop');\r\n\r\n// load these modifiers after resize is loaded\r\nrequire('./modifiers/snapSize');\r\nrequire('./modifiers/restrictEdges');\r\nrequire('./modifiers/restrictSize');\r\n\r\n// autoStart actions\r\nrequire('./autoStart/gesture');\r\nrequire('./autoStart/resize');\r\nrequire('./autoStart/drag');\r\n\r\n// Interactable preventDefault setting\r\nrequire('./interactablePreventDefault.js');\r\n\r\n// autoScroll\r\nrequire('./autoScroll');\r\n\r\n// export interact\r\nmodule.exports = require('./interact');\r\n","const InteractEvent  = require('./InteractEvent');\r\nconst Interaction    = require('./Interaction');\r\nconst modifiers      = require('./modifiers');\r\nconst utils          = require('./utils');\r\nconst animationFrame = require('./utils/raf');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.inertiaStatus = {\r\n    active     : false,\r\n    smoothEnd  : false,\r\n    allowResume: false,\r\n\r\n    startEvent: null,\r\n    upCoords  : {},\r\n\r\n    xe: 0, ye: 0,\r\n    sx: 0, sy: 0,\r\n\r\n    t0: 0,\r\n    vx0: 0, vys: 0,\r\n    duration: 0,\r\n\r\n    lambda_v0: 0,\r\n    one_ve_v0: 0,\r\n    i  : null,\r\n  };\r\n\r\n  interaction.boundInertiaFrame   = () => inertiaFrame  .apply(interaction);\r\n  interaction.boundSmoothEndFrame = () => smoothEndFrame.apply(interaction);\r\n});\r\n\r\nInteraction.signals.on('down', function ({ interaction, event, pointer, eventTarget }) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  // Check if the down event hits the current inertia target\r\n  if (status.active) {\r\n    let element = eventTarget;\r\n\r\n    // climb up the DOM tree from the event target\r\n    while (utils.is.element(element)) {\r\n\r\n      // if interaction element is the current inertia target element\r\n      if (element === interaction.element) {\r\n        // stop inertia\r\n        animationFrame.cancel(status.i);\r\n        status.active = false;\r\n        interaction.simulation = null;\r\n\r\n        // update pointers to the down event's coordinates\r\n        interaction.updatePointer(pointer);\r\n        utils.setCoords(interaction.curCoords, interaction.pointers);\r\n\r\n        // fire appropriate signals\r\n        const signalArg = { interaction };\r\n        Interaction.signals.fire('before-action-move', signalArg);\r\n        Interaction.signals.fire('action-resume'     , signalArg);\r\n\r\n        // fire a reume event\r\n        const resumeEvent = new InteractEvent(interaction,\r\n                                              event,\r\n                                              interaction.prepared.name,\r\n                                              'inertiaresume',\r\n                                              interaction.element);\r\n\r\n        interaction.target.fire(resumeEvent);\r\n        interaction.prevEvent = resumeEvent;\r\n        modifiers.resetStatuses(interaction.modifierStatuses);\r\n\r\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\r\n        break;\r\n      }\r\n\r\n      element = utils.parentNode(element);\r\n    }\r\n  }\r\n});\r\n\r\nInteraction.signals.on('up', function ({ interaction, event }) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  if (!interaction.interacting() || status.active) { return; }\r\n\r\n  const target = interaction.target;\r\n  const options = target && target.options;\r\n  const inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\r\n\r\n  const now = new Date().getTime();\r\n  const statuses = {};\r\n  const page = utils.extend({}, interaction.curCoords.page);\r\n  const pointerSpeed = interaction.pointerDelta.client.speed;\r\n  let inertiaPossible = false;\r\n  let inertia = false;\r\n  let smoothEnd = false;\r\n  let modifierResult;\r\n\r\n  // check if inertia should be started\r\n  inertiaPossible = (inertiaOptions && inertiaOptions.enabled\r\n                     && interaction.prepared.name !== 'gesture'\r\n                     && event !== status.startEvent);\r\n\r\n  inertia = (inertiaPossible\r\n            && (now - interaction.curCoords.timeStamp) < 50\r\n            && pointerSpeed > inertiaOptions.minSpeed\r\n            && pointerSpeed > inertiaOptions.endSpeed);\r\n\r\n  const modifierArg = {\r\n    interaction,\r\n    page,\r\n    statuses,\r\n    preEnd: true,\r\n    requireEndOnly: true,\r\n  };\r\n\r\n  // smoothEnd\r\n  if (inertiaPossible && !inertia) {\r\n    modifiers.resetStatuses(statuses);\r\n\r\n    modifierResult = modifiers.setAll(modifierArg);\r\n\r\n    if (modifierResult.shouldMove && modifierResult.locked) {\r\n      smoothEnd = true;\r\n    }\r\n  }\r\n\r\n  if (!(inertia || smoothEnd)) { return; }\r\n\r\n  utils.copyCoords(status.upCoords, interaction.curCoords);\r\n\r\n  interaction.pointers[0] = status.startEvent =\r\n    new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\r\n\r\n  status.t0 = now;\r\n\r\n  status.active = true;\r\n  status.allowResume = inertiaOptions.allowResume;\r\n  interaction.simulation = status;\r\n\r\n  target.fire(status.startEvent);\r\n\r\n  if (inertia) {\r\n    status.vx0 = interaction.pointerDelta.client.vx;\r\n    status.vy0 = interaction.pointerDelta.client.vy;\r\n    status.v0 = pointerSpeed;\r\n\r\n    calcInertia(interaction, status);\r\n\r\n    utils.extend(page, interaction.curCoords.page);\r\n\r\n    page.x += status.xe;\r\n    page.y += status.ye;\r\n\r\n    modifiers.resetStatuses(statuses);\r\n\r\n    modifierResult = modifiers.setAll(modifierArg);\r\n\r\n    status.modifiedXe += modifierResult.dx;\r\n    status.modifiedYe += modifierResult.dy;\r\n\r\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\r\n  }\r\n  else {\r\n    status.smoothEnd = true;\r\n    status.xe = modifierResult.dx;\r\n    status.ye = modifierResult.dy;\r\n\r\n    status.sx = status.sy = 0;\r\n\r\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('stop-active', function ({ interaction }) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  if (status.active) {\r\n    animationFrame.cancel(status.i);\r\n    status.active = false;\r\n    interaction.simulation = null;\r\n  }\r\n});\r\n\r\nfunction calcInertia (interaction, status) {\r\n  const inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\r\n  const lambda = inertiaOptions.resistance;\r\n  const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\r\n\r\n  status.x0 = interaction.prevEvent.pageX;\r\n  status.y0 = interaction.prevEvent.pageY;\r\n  status.t0 = status.startEvent.timeStamp / 1000;\r\n  status.sx = status.sy = 0;\r\n\r\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\r\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\r\n  status.te = inertiaDur;\r\n\r\n  status.lambda_v0 = lambda / status.v0;\r\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\r\n}\r\n\r\nfunction inertiaFrame () {\r\n  updateInertiaCoords(this);\r\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\r\n\r\n  const status = this.inertiaStatus;\r\n  const options = this.target.options[this.prepared.name].inertia;\r\n  const lambda = options.resistance;\r\n  const t = new Date().getTime() / 1000 - status.t0;\r\n\r\n  if (t < status.te) {\r\n\r\n    const progress =  1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\r\n\r\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\r\n      status.sx = status.xe * progress;\r\n      status.sy = status.ye * progress;\r\n    }\r\n    else {\r\n      const quadPoint = utils.getQuadraticCurvePoint(0, 0,\r\n                                                     status.xe,\r\n                                                     status.ye,\r\n                                                     status.modifiedXe,\r\n                                                     status.modifiedYe,\r\n                                                     progress);\r\n\r\n      status.sx = quadPoint.x;\r\n      status.sy = quadPoint.y;\r\n    }\r\n\r\n    this.doMove();\r\n\r\n    status.i = animationFrame.request(this.boundInertiaFrame);\r\n  }\r\n  else {\r\n    status.sx = status.modifiedXe;\r\n    status.sy = status.modifiedYe;\r\n\r\n    this.doMove();\r\n    this.end(status.startEvent);\r\n    status.active = false;\r\n    this.simulation = null;\r\n  }\r\n\r\n  utils.copyCoords(this.prevCoords, this.curCoords);\r\n}\r\n\r\nfunction smoothEndFrame () {\r\n  updateInertiaCoords(this);\r\n\r\n  const status = this.inertiaStatus;\r\n  const t = new Date().getTime() - status.t0;\r\n  const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\r\n\r\n  if (t < duration) {\r\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\r\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\r\n\r\n    this.pointerMove(status.startEvent, status.startEvent);\r\n\r\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\r\n  }\r\n  else {\r\n    status.sx = status.xe;\r\n    status.sy = status.ye;\r\n\r\n    this.pointerMove(status.startEvent, status.startEvent);\r\n    this.end(status.startEvent);\r\n\r\n    status.smoothEnd =\r\n      status.active = false;\r\n    this.simulation = null;\r\n  }\r\n}\r\n\r\nfunction updateInertiaCoords (interaction) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  // return if inertia isn't running\r\n  if (!status.active) { return; }\r\n\r\n  const pageUp   = status.upCoords.page;\r\n  const clientUp = status.upCoords.client;\r\n\r\n  utils.setCoords(interaction.curCoords, [ {\r\n    pageX  : pageUp.x   + status.sx,\r\n    pageY  : pageUp.y   + status.sy,\r\n    clientX: clientUp.x + status.sx,\r\n    clientY: clientUp.y + status.sy,\r\n  } ]);\r\n}\r\n","const browser      = require('./utils/browser');\r\nconst events       = require('./utils/events');\r\nconst utils        = require('./utils');\r\nconst scope        = require('./scope');\r\nconst Interactable = require('./Interactable');\r\nconst Interaction  = require('./Interaction');\r\n\r\nconst globalEvents = {};\r\n\r\n/*\\\r\n * interact\r\n [ method ]\r\n *\r\n * The methods of this variable can be used to set elements as\r\n * interactables and also to change various default settings.\r\n *\r\n * Calling it as a function and passing an element or a valid CSS selector\r\n * string returns an Interactable object which has various methods to\r\n * configure it.\r\n *\r\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\r\n = (object) An @Interactable\r\n *\r\n > Usage\r\n | interact('#draggable').draggable(true);\r\n |\r\n | var rectables = interact('rect');\r\n | rectables\r\n |     .gesturable(true)\r\n |     .on('gesturemove', function (event) {\r\n |         // ...\r\n |     });\r\n\\*/\r\nfunction interact (element, options) {\r\n  let interactable = scope.interactables.get(element, options);\r\n\r\n  if (!interactable) {\r\n    interactable = new Interactable(element, options);\r\n    interactable.events.global = globalEvents;\r\n  }\r\n\r\n  return interactable;\r\n}\r\n\r\n/*\\\r\n * interact.isSet\r\n [ method ]\r\n *\r\n * Check if an element has been set\r\n - element (Element) The Element being searched for\r\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\r\n\\*/\r\ninteract.isSet = function (element, options) {\r\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\r\n};\r\n\r\n/*\\\r\n * interact.on\r\n [ method ]\r\n *\r\n * Adds a global listener for an InteractEvent or adds a DOM event to\r\n * `document`\r\n *\r\n - type       (string | array | object) The types of events to listen for\r\n - listener   (function) The function event (s)\r\n - useCapture (boolean) #optional useCapture flag for addEventListener\r\n = (object) interact\r\n\\*/\r\ninteract.on = function (type, listener, useCapture) {\r\n  if (utils.is.string(type) && type.search(' ') !== -1) {\r\n    type = type.trim().split(/ +/);\r\n  }\r\n\r\n  if (utils.is.array(type)) {\r\n    for (const eventType of type) {\r\n      interact.on(eventType, listener, useCapture);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (utils.is.object(type)) {\r\n    for (const prop in type) {\r\n      interact.on(prop, type[prop], listener);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  // if it is an InteractEvent type, add listener to globalEvents\r\n  if (utils.contains(Interactable.eventTypes, type)) {\r\n    // if this type of event was never bound\r\n    if (!globalEvents[type]) {\r\n      globalEvents[type] = [listener];\r\n    }\r\n    else {\r\n      globalEvents[type].push(listener);\r\n    }\r\n  }\r\n  // If non InteractEvent type, addEventListener to document\r\n  else {\r\n    events.add(scope.document, type, listener, useCapture);\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.off\r\n [ method ]\r\n *\r\n * Removes a global InteractEvent listener or DOM event from `document`\r\n *\r\n - type       (string | array | object) The types of events that were listened for\r\n - listener   (function) The listener function to be removed\r\n - useCapture (boolean) #optional useCapture flag for removeEventListener\r\n = (object) interact\r\n \\*/\r\ninteract.off = function (type, listener, useCapture) {\r\n  if (utils.is.string(type) && type.search(' ') !== -1) {\r\n    type = type.trim().split(/ +/);\r\n  }\r\n\r\n  if (utils.is.array(type)) {\r\n    for (const eventType of type) {\r\n      interact.off(eventType, listener, useCapture);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (utils.is.object(type)) {\r\n    for (const prop in type) {\r\n      interact.off(prop, type[prop], listener);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (!utils.contains(Interactable.eventTypes, type)) {\r\n    events.remove(scope.document, type, listener, useCapture);\r\n  }\r\n  else {\r\n    let index;\r\n\r\n    if (type in globalEvents\r\n        && (index = utils.indexOf(globalEvents[type], listener)) !== -1) {\r\n      globalEvents[type].splice(index, 1);\r\n    }\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.debug\r\n [ method ]\r\n *\r\n * Returns an object which exposes internal data\r\n = (object) An object with properties that outline the current state and expose internal functions and variables\r\n\\*/\r\ninteract.debug = function () {\r\n  return scope;\r\n};\r\n\r\n// expose the functions used to calculate multi-touch properties\r\ninteract.getPointerAverage  = utils.pointerAverage;\r\ninteract.getTouchBBox       = utils.touchBBox;\r\ninteract.getTouchDistance   = utils.touchDistance;\r\ninteract.getTouchAngle      = utils.touchAngle;\r\n\r\ninteract.getElementRect       = utils.getElementRect;\r\ninteract.getElementClientRect = utils.getElementClientRect;\r\ninteract.matchesSelector      = utils.matchesSelector;\r\ninteract.closest              = utils.closest;\r\n\r\n/*\\\r\n * interact.supportsTouch\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports touch input\r\n\\*/\r\ninteract.supportsTouch = function () {\r\n  return browser.supportsTouch;\r\n};\r\n\r\n/*\\\r\n * interact.supportsPointerEvent\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports PointerEvents\r\n\\*/\r\ninteract.supportsPointerEvent = function () {\r\n  return browser.supportsPointerEvent;\r\n};\r\n\r\n/*\\\r\n * interact.stop\r\n [ method ]\r\n *\r\n * Cancels all interactions (end events are not fired)\r\n *\r\n - event (Event) An event on which to call preventDefault()\r\n = (object) interact\r\n\\*/\r\ninteract.stop = function (event) {\r\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\r\n    scope.interactions[i].stop(event);\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.pointerMoveTolerance\r\n [ method ]\r\n * Returns or sets the distance the pointer must be moved before an action\r\n * sequence occurs. This also affects tolerance for tap events.\r\n *\r\n - newValue (number) #optional The movement from the start position must be greater than this value\r\n = (number | Interactable) The current setting or interact\r\n\\*/\r\ninteract.pointerMoveTolerance = function (newValue) {\r\n  if (utils.is.number(newValue)) {\r\n    Interaction.pointerMoveTolerance = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  return Interaction.pointerMoveTolerance;\r\n};\r\n\r\ninteract.addDocument    = scope.addDocument;\r\ninteract.removeDocument = scope.removeDocument;\r\n\r\nscope.interact = interact;\r\n\r\nmodule.exports = interact;\r\n","const Interactable = require('./Interactable');\r\nconst Interaction  = require('./Interaction');\r\nconst scope        = require('./scope');\r\nconst is           = require('./utils/is');\r\n\r\nconst { nodeContains, matchesSelector } = require('./utils/domUtils');\r\n\r\n/*\\\r\n * Interactable.preventDefault\r\n [ method ]\r\n *\r\n * Returns or sets whether to prevent the browser's default behaviour\r\n * in response to pointer events. Can be set to:\r\n *  - `'always'` to always prevent\r\n *  - `'never'` to never prevent\r\n *  - `'auto'` to let interact.js try to determine what would be best\r\n *\r\n - newValue (string) #optional `true`, `false` or `'auto'`\r\n = (string | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.preventDefault = function (newValue) {\r\n  if (/^(always|never|auto)$/.test(newValue)) {\r\n    this.options.preventDefault = newValue;\r\n    return this;\r\n  }\r\n\r\n  if (is.bool(newValue)) {\r\n    this.options.preventDefault = newValue? 'always' : 'never';\r\n    return this;\r\n  }\r\n\r\n  return this.options.preventDefault;\r\n};\r\n\r\nInteractable.prototype.checkAndPreventDefault = function (event) {\r\n  const setting = this.options.preventDefault;\r\n\r\n  if (setting === 'never') { return; }\r\n\r\n  if (setting === 'always') {\r\n    event.preventDefault();\r\n    return;\r\n  }\r\n\r\n  // setting === 'auto'\r\n\r\n  // don't preventDefault of pointerdown events\r\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\r\n    return;\r\n  }\r\n\r\n  // don't preventDefault on editable elements\r\n  if (matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\r\n    return;\r\n  }\r\n\r\n  event.preventDefault();\r\n};\r\n\r\nfunction onInteractionEvent ({ interaction, event }) {\r\n  if (interaction.target) {\r\n    interaction.target.checkAndPreventDefault(event);\r\n  }\r\n}\r\n\r\nfor (const eventSignal of ['down', 'move', 'up', 'cancel']) {\r\n  Interaction.signals.on(eventSignal, onInteractionEvent);\r\n}\r\n\r\n// prevent native HTML5 drag on interact.js target elements\r\nInteraction.docEvents.dragstart = function preventNativeDrag (event) {\r\n  for (const interaction of scope.interactions) {\r\n\r\n    if (interaction.element\r\n        && (interaction.element === event.target\r\n            || nodeContains(interaction.element, event.target))) {\r\n\r\n      interaction.target.checkAndPreventDefault(event);\r\n      return;\r\n    }\r\n  }\r\n};\r\n","const scope         = require('./scope');\r\nconst events        = require('./utils/events');\r\nconst browser       = require('./utils/browser');\r\nconst iFinder       = require('./utils/interactionFinder');\r\nconst pointerEvents = require('./pointerEvents/base');\r\n\r\nconst { window } = require('./utils/window');\r\n\r\nconst toString = Object.prototype.toString;\r\n\r\nif (!window.Array.isArray) {\r\n  window.Array.isArray = function (obj) {\r\n    return toString.call(obj) === '[object Array]';\r\n  };\r\n}\r\n\r\nif (!String.prototype.trim) {\r\n  String.prototype.trim = function () {\r\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\r\n  };\r\n}\r\n\r\n// http://www.quirksmode.org/dom/events/click.html\r\n// >Events leading to dblclick\r\n//\r\n// IE8 doesn't fire down event before dblclick.\r\n// This workaround tries to fire a tap and doubletap after dblclick\r\nfunction onIE8Dblclick (event) {\r\n  const eventTarget = event.target;\r\n  const interaction = iFinder.search(event, event.type, eventTarget);\r\n\r\n  if (!interaction) { return; }\r\n\r\n  if (interaction.prevTap\r\n      && event.clientX === interaction.prevTap.clientX\r\n      && event.clientY === interaction.prevTap.clientY\r\n      && eventTarget   === interaction.prevTap.target) {\r\n\r\n    interaction.downTargets[0] = eventTarget;\r\n    interaction.downTimes  [0] = new Date().getTime();\r\n\r\n    pointerEvents.fire({\r\n      interaction,\r\n      event,\r\n      eventTarget,\r\n      pointer: event,\r\n      type: 'tap',\r\n    });\r\n  }\r\n}\r\n\r\nif (browser.isIE8) {\r\n  const selectFix = function (event) {\r\n    for (const interaction of scope.interactions) {\r\n      if (interaction.interacting()) {\r\n        interaction.target.checkAndPreventDefault(event);\r\n      }\r\n    }\r\n  };\r\n\r\n  const onDocIE8 = function onDocIE8 ({ doc, win }, signalName) {\r\n    const eventMethod = signalName.indexOf('listen') === 0\r\n      ? events.add : events.remove;\r\n\r\n    // For IE's lack of Event#preventDefault\r\n    eventMethod(doc, 'selectstart', selectFix);\r\n\r\n    if (pointerEvents) {\r\n      eventMethod(doc, 'dblclick', onIE8Dblclick);\r\n    }\r\n  };\r\n\r\n  scope.signals.on('add-document'   , onDocIE8);\r\n  scope.signals.on('remove-document', onDocIE8);\r\n}\r\n\r\nmodule.exports = null;\r\n","const InteractEvent = require('../InteractEvent');\r\nconst Interaction   = require('../Interaction');\r\nconst extend        = require('../utils/extend');\r\n\r\nconst modifiers = {\r\n  names: [],\r\n\r\n  setOffsets: function (arg) {\r\n    const { interaction, pageCoords: page } = arg;\r\n    const { target, element, startOffset } = interaction;\r\n    const rect = target.getRect(element);\r\n\r\n    if (rect) {\r\n      startOffset.left = page.x - rect.left;\r\n      startOffset.top  = page.y - rect.top;\r\n\r\n      startOffset.right  = rect.right  - page.x;\r\n      startOffset.bottom = rect.bottom - page.y;\r\n\r\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\r\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\r\n    }\r\n    else {\r\n      startOffset.left = startOffset.top = startOffset.right = startOffset.bottom = 0;\r\n    }\r\n\r\n    arg.rect = rect;\r\n    arg.interactable = target;\r\n    arg.element = element;\r\n\r\n    for (let i = 0; i < modifiers.names.length; i++) {\r\n      const modifierName = modifiers.names[i];\r\n\r\n      arg.options = target.options[interaction.prepared.name][modifierName];\r\n\r\n      if (!arg.options) {\r\n        continue;\r\n      }\r\n\r\n      interaction.modifierOffsets[modifierName] = modifiers[modifierName].setOffset(arg);\r\n    }\r\n  },\r\n\r\n  setAll: function (arg) {\r\n    const { interaction, statuses, preEnd, requireEndOnly } = arg;\r\n    const coords = extend({}, arg.pageCoords);\r\n    const result = {\r\n      dx: 0,\r\n      dy: 0,\r\n      changed: false,\r\n      locked: false,\r\n      shouldMove: true,\r\n    };\r\n\r\n    for (const modifierName of modifiers.names) {\r\n      const modifier = modifiers[modifierName];\r\n      const options = interaction.target.options[interaction.prepared.name][modifierName];\r\n\r\n      if (!shouldDo(options, preEnd, requireEndOnly)) { continue; }\r\n\r\n      arg.status = arg.status = statuses[modifierName];\r\n      arg.options = options;\r\n      arg.offset = arg.interaction.modifierOffsets[modifierName];\r\n\r\n      modifier.set(arg);\r\n\r\n      if (arg.status.locked) {\r\n        coords.x += arg.status.dx;\r\n        coords.y += arg.status.dy;\r\n\r\n        result.dx += arg.status.dx;\r\n        result.dy += arg.status.dy;\r\n\r\n        result.locked = true;\r\n      }\r\n    }\r\n\r\n    // a move should be fired if:\r\n    //  - there are no modifiers enabled,\r\n    //  - no modifiers are \"locked\" i.e. have changed the pointer's coordinates, or\r\n    //  - the locked coords have changed since the last pointer move\r\n    result.shouldMove = !arg.status || !result.locked || arg.status.changed;\r\n\r\n    return result;\r\n  },\r\n\r\n  resetStatuses: function (statuses) {\r\n    for (const modifierName of modifiers.names) {\r\n      const status = statuses[modifierName] || {};\r\n\r\n      status.dx = status.dy = 0;\r\n      status.modifiedX = status.modifiedY = NaN;\r\n      status.locked = false;\r\n      status.changed = true;\r\n\r\n      statuses[modifierName] = status;\r\n    }\r\n\r\n    return statuses;\r\n  },\r\n\r\n  start: function ({ interaction }, signalName) {\r\n    const arg = {\r\n      interaction,\r\n      pageCoords: (signalName === 'action-resume' ?\r\n                   interaction.curCoords : interaction.startCoords).page,\r\n      startOffset: interaction.startOffset,\r\n      statuses: interaction.modifierStatuses,\r\n      preEnd: false,\r\n      requireEndOnly: false,\r\n    };\r\n\r\n    modifiers.setOffsets(arg);\r\n    modifiers.resetStatuses(arg.statuses);\r\n\r\n    arg.pageCoords = extend({}, interaction.startCoords.page);\r\n    interaction.modifierResult = modifiers.setAll(arg);\r\n  },\r\n};\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\r\n  interaction.modifierOffsets  = {};\r\n  interaction.modifierStatuses = modifiers.resetStatuses({});\r\n  interaction.modifierResult   = null;\r\n});\r\n\r\nInteraction.signals.on('action-start' , modifiers.start);\r\nInteraction.signals.on('action-resume', modifiers.start);\r\n\r\nInteraction.signals.on('before-action-move', function ({ interaction, preEnd, interactingBeforeMove }) {\r\n  const modifierResult = modifiers.setAll({\r\n    interaction,\r\n    preEnd,\r\n    pageCoords: interaction.curCoords.page,\r\n    statuses: interaction.modifierStatuses,\r\n    requireEndOnly: false,\r\n  });\r\n\r\n  // don't fire an action move if a modifier would keep the event in the same\r\n  // cordinates as before\r\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\r\n    interaction._dontFireMove = true;\r\n  }\r\n\r\n  interaction.modifierResult = modifierResult;\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction, event }) {\r\n  for (let i = 0; i < modifiers.names.length; i++) {\r\n    const options = interaction.target.options[interaction.prepared.name][modifiers.names[i]];\r\n\r\n    // if the endOnly option is true for any modifier\r\n    if (shouldDo(options, true, true)) {\r\n      // fire a move event at the modified coordinates\r\n      interaction.doMove({ event, preEnd: true });\r\n      break;\r\n    }\r\n  }\r\n});\r\n\r\nInteractEvent.signals.on('set-xy', function (arg) {\r\n  const { iEvent, interaction } = arg;\r\n  const modifierArg = extend({}, arg);\r\n\r\n  for (let i = 0; i < modifiers.names.length; i++) {\r\n    const modifierName = modifiers.names[i];\r\n    modifierArg.options = interaction.target.options[interaction.prepared.name][modifierName];\r\n\r\n    if (!modifierArg.options) {\r\n      continue;\r\n    }\r\n\r\n    const modifier = modifiers[modifierName];\r\n\r\n    modifierArg.status = interaction.modifierStatuses[modifierName];\r\n\r\n    iEvent[modifierName] = modifier.modifyCoords(modifierArg);\r\n  }\r\n});\r\n\r\nfunction shouldDo (options, preEnd, requireEndOnly) {\r\n  return (options && options.enabled\r\n          && (preEnd || !options.endOnly)\r\n          && (!requireEndOnly || options.endOnly));\r\n}\r\n\r\nmodule.exports = modifiers;\r\n","const modifiers      = require('./index');\r\nconst utils          = require('../utils');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst restrict = {\r\n  defaults: {\r\n    enabled    : false,\r\n    endOnly    : false,\r\n    restriction: null,\r\n    elementRect: null,\r\n  },\r\n\r\n  setOffset: function ({ rect, startOffset, options }) {\r\n    const elementRect = options && options.elementRect;\r\n    const offset = {};\r\n\r\n    if (rect && elementRect) {\r\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\r\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\r\n\r\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\r\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\r\n    }\r\n    else {\r\n      offset.left = offset.top = offset.right = offset.bottom = 0;\r\n    }\r\n\r\n    return offset;\r\n  },\r\n\r\n  set: function ({ pageCoords, interaction, status, options }) {\r\n    if (!options) { return status; }\r\n\r\n    const page = status.useStatusXY\r\n      ? { x: status.x, y: status.y }\r\n      : utils.extend({}, pageCoords);\r\n\r\n    const restriction = getRestrictionRect(options.restriction, interaction, page);\r\n\r\n    if (!restriction) { return status; }\r\n\r\n    status.dx = 0;\r\n    status.dy = 0;\r\n    status.locked = false;\r\n\r\n    const rect = restriction;\r\n    let modifiedX = page.x;\r\n    let modifiedY = page.y;\r\n\r\n    const offset = interaction.modifierOffsets.restrict;\r\n\r\n    // object is assumed to have\r\n    // x, y, width, height or\r\n    // left, top, right, bottom\r\n    if ('x' in restriction && 'y' in restriction) {\r\n      modifiedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\r\n      modifiedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\r\n    }\r\n    else {\r\n      modifiedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\r\n      modifiedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\r\n    }\r\n\r\n    status.dx = modifiedX - page.x;\r\n    status.dy = modifiedY - page.y;\r\n\r\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\r\n    status.locked = !!(status.dx || status.dy);\r\n\r\n    status.modifiedX = modifiedX;\r\n    status.modifiedY = modifiedY;\r\n  },\r\n\r\n  modifyCoords: function ({ page, client, status, phase, options }) {\r\n    const elementRect = options && options.elementRect;\r\n\r\n    if (options && options.enabled\r\n        && !(phase === 'start' && elementRect && status.locked)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n\r\n        return {\r\n          dx: status.dx,\r\n          dy: status.dy,\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  getRestrictionRect,\r\n};\r\n\r\nfunction getRestrictionRect (value, interaction, page) {\r\n  if (utils.is.function(value)) {\r\n    return utils.resolveRectLike(value, interaction.target, interaction.element, [page.x, page.y, interaction]);\r\n  } else {\r\n    return utils.resolveRectLike(value, interaction.target, interaction.element);\r\n  }\r\n}\r\n\r\nmodifiers.restrict = restrict;\r\nmodifiers.names.push('restrict');\r\n\r\ndefaultOptions.perAction.restrict = restrict.defaults;\r\n\r\nmodule.exports = restrict;\r\n","// This module adds the options.resize.restrictEdges setting which sets min and\r\n// max for the top, left, bottom and right edges of the target being resized.\r\n//\r\n// interact(target).resize({\r\n//   edges: { top: true, left: true },\r\n//   restrictEdges: {\r\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\r\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\r\n//   },\r\n// });\r\n\r\nconst modifiers      = require('./index');\r\nconst utils          = require('../utils');\r\nconst rectUtils      = require('../utils/rect');\r\nconst defaultOptions = require('../defaultOptions');\r\nconst resize         = require('../actions/resize');\r\n\r\nconst { getRestrictionRect } = require('./restrict');\r\n\r\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity };\r\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity };\r\n\r\nconst restrictEdges = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    min: null,\r\n    max: null,\r\n    offset: null,\r\n  },\r\n\r\n  setOffset: function ({ interaction, startOffset, options }) {\r\n    if (!options) {\r\n      return utils.extend({}, startOffset);\r\n    }\r\n\r\n    const offset = getRestrictionRect(options.offset, interaction, interaction.startCoords.page);\r\n\r\n    if (offset) {\r\n      return {\r\n        top:    startOffset.top    + offset.y,\r\n        left:   startOffset.left   + offset.x,\r\n        bottom: startOffset.bottom + offset.y,\r\n        right:  startOffset.right  + offset.x,\r\n      };\r\n    }\r\n\r\n    return startOffset;\r\n  },\r\n\r\n  set: function ({ pageCoords, interaction, status, offset, options }) {\r\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\r\n\r\n    if (!interaction.interacting() || !edges) {\r\n      return;\r\n    }\r\n\r\n    const page = status.useStatusXY\r\n      ? { x: status.x, y: status.y }\r\n      : utils.extend({}, pageCoords);\r\n    const inner = rectUtils.xywhToTlbr(getRestrictionRect(options.inner, interaction, page)) || noInner;\r\n    const outer = rectUtils.xywhToTlbr(getRestrictionRect(options.outer, interaction, page)) || noOuter;\r\n\r\n    let modifiedX = page.x;\r\n    let modifiedY = page.y;\r\n\r\n    status.dx = 0;\r\n    status.dy = 0;\r\n    status.locked = false;\r\n\r\n    if (edges.top) {\r\n      modifiedY = Math.min(Math.max(outer.top    + offset.top,    page.y), inner.top    + offset.top);\r\n    }\r\n    else if (edges.bottom) {\r\n      modifiedY = Math.max(Math.min(outer.bottom - offset.bottom, page.y), inner.bottom - offset.bottom);\r\n    }\r\n    if (edges.left) {\r\n      modifiedX = Math.min(Math.max(outer.left   + offset.left,   page.x), inner.left   + offset.left);\r\n    }\r\n    else if (edges.right) {\r\n      modifiedX = Math.max(Math.min(outer.right  - offset.right,  page.x), inner.right  - offset.right);\r\n    }\r\n\r\n    status.dx = modifiedX - page.x;\r\n    status.dy = modifiedY - page.y;\r\n\r\n    status.changed = status.modifiedX !== modifiedX || status.modifiedY !== modifiedY;\r\n    status.locked = !!(status.dx || status.dy);\r\n\r\n    status.modifiedX = modifiedX;\r\n    status.modifiedY = modifiedY;\r\n  },\r\n\r\n  modifyCoords: function ({ page, client, status, phase, options }) {\r\n    if (options && options.enabled\r\n        && !(phase === 'start' && status.locked)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n\r\n        return {\r\n          dx: status.dx,\r\n          dy: status.dy,\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  noInner,\r\n  noOuter,\r\n  getRestrictionRect,\r\n};\r\n\r\nmodifiers.restrictEdges = restrictEdges;\r\nmodifiers.names.push('restrictEdges');\r\n\r\ndefaultOptions.perAction.restrictEdges = restrictEdges.defaults;\r\nresize.defaults.restrictEdges          = restrictEdges.defaults;\r\n\r\nmodule.exports = restrictEdges;\r\n","// This module adds the options.resize.restrictSize setting which sets min and\r\n// max width and height for the target being resized.\r\n//\r\n// interact(target).resize({\r\n//   edges: { top: true, left: true },\r\n//   restrictSize: {\r\n//     min: { width: -600, height: -600 },\r\n//     max: { width:  600, height:  600 },\r\n//   },\r\n// });\r\n\r\nconst modifiers      = require('./index');\r\nconst restrictEdges  = require('./restrictEdges');\r\nconst utils          = require('../utils');\r\nconst rectUtils      = require('../utils/rect');\r\nconst defaultOptions = require('../defaultOptions');\r\nconst resize         = require('../actions/resize');\r\n\r\nconst noMin = { width: -Infinity, height: -Infinity };\r\nconst noMax = { width: +Infinity, height: +Infinity };\r\n\r\nconst restrictSize = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    min: null,\r\n    max: null,\r\n  },\r\n\r\n  setOffset: function ({ interaction }) {\r\n    return interaction.startOffset;\r\n  },\r\n\r\n  set: function (arg) {\r\n    const { interaction, options } = arg;\r\n    const edges = interaction.prepared.linkedEdges || interaction.prepared.edges;\r\n\r\n    if (!interaction.interacting() || !edges) {\r\n      return;\r\n    }\r\n\r\n    const rect = rectUtils.xywhToTlbr(interaction.resizeRects.inverted);\r\n\r\n    const minSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.min, interaction)) || noMin;\r\n    const maxSize = rectUtils.tlbrToXywh(restrictEdges.getRestrictionRect(options.max, interaction)) || noMax;\r\n\r\n    arg.options = {\r\n      enabled: options.enabled,\r\n      endOnly: options.endOnly,\r\n      inner: utils.extend({}, restrictEdges.noInner),\r\n      outer: utils.extend({}, restrictEdges.noOuter),\r\n    };\r\n\r\n    if (edges.top) {\r\n      arg.options.inner.top = rect.bottom - minSize.height;\r\n      arg.options.outer.top = rect.bottom - maxSize.height;\r\n    }\r\n    else if (edges.bottom) {\r\n      arg.options.inner.bottom = rect.top + minSize.height;\r\n      arg.options.outer.bottom = rect.top + maxSize.height;\r\n    }\r\n    if (edges.left) {\r\n      arg.options.inner.left = rect.right - minSize.width;\r\n      arg.options.outer.left = rect.right - maxSize.width;\r\n    }\r\n    else if (edges.right) {\r\n      arg.options.inner.right = rect.left + minSize.width;\r\n      arg.options.outer.right = rect.left + maxSize.width;\r\n    }\r\n\r\n    restrictEdges.set(arg);\r\n  },\r\n\r\n  modifyCoords: restrictEdges.modifyCoords,\r\n};\r\n\r\nmodifiers.restrictSize = restrictSize;\r\nmodifiers.names.push('restrictSize');\r\n\r\ndefaultOptions.perAction.restrictSize = restrictSize.defaults;\r\nresize.defaults.restrictSize          = restrictSize.defaults;\r\n\r\nmodule.exports = restrictSize;\r\n","const modifiers      = require('./index');\r\nconst interact       = require('../interact');\r\nconst utils          = require('../utils');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst snap = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    range  : Infinity,\r\n    targets: null,\r\n    offsets: null,\r\n\r\n    relativePoints: null,\r\n  },\r\n\r\n  setOffset: function ({ interaction, interactable, element, rect, startOffset, options }) {\r\n    const offsets = [];\r\n    const optionsOrigin = utils.rectToXY(utils.resolveRectLike(options.origin));\r\n    const origin = optionsOrigin || utils.getOriginXY(interactable, element, interaction.prepared.name);\r\n    options = options || interactable.options[interaction.prepared.name].snap || {};\r\n\r\n    let snapOffset;\r\n\r\n    if (options.offset === 'startCoords') {\r\n      snapOffset = {\r\n        x: interaction.startCoords.page.x - origin.x,\r\n        y: interaction.startCoords.page.y - origin.y,\r\n      };\r\n    }\r\n    else  {\r\n      const offsetRect = utils.resolveRectLike(options.offset, interactable, element, [interaction]);\r\n\r\n      snapOffset = utils.rectToXY(offsetRect) || { x: 0, y: 0 };\r\n    }\r\n\r\n    if (rect && options.relativePoints && options.relativePoints.length) {\r\n      for (const { x: relativeX, y: relativeY } of options.relativePoints) {\r\n        offsets.push({\r\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\r\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\r\n        });\r\n      }\r\n    }\r\n    else {\r\n      offsets.push(snapOffset);\r\n    }\r\n\r\n    return offsets;\r\n  },\r\n\r\n  set: function ({ interaction, pageCoords, status, options, offset: offsets }) {\r\n    const targets = [];\r\n    let target;\r\n    let page;\r\n    let i;\r\n\r\n    if (status.useStatusXY) {\r\n      page = { x: status.x, y: status.y };\r\n    }\r\n    else {\r\n      const origin = utils.getOriginXY(interaction.target, interaction.element, interaction.prepared.name);\r\n\r\n      page = utils.extend({}, pageCoords);\r\n\r\n      page.x -= origin.x;\r\n      page.y -= origin.y;\r\n    }\r\n\r\n    status.realX = page.x;\r\n    status.realY = page.y;\r\n\r\n    let len = options.targets? options.targets.length : 0;\r\n\r\n    for (const { x: offsetX, y: offsetY } of offsets) {\r\n      const relativeX = page.x - offsetX;\r\n      const relativeY = page.y - offsetY;\r\n\r\n      for (const snapTarget of options.targets) {\r\n        if (utils.is.function(snapTarget)) {\r\n          target = snapTarget(relativeX, relativeY, interaction);\r\n        }\r\n        else {\r\n          target = snapTarget;\r\n        }\r\n\r\n        if (!target) { continue; }\r\n\r\n        targets.push({\r\n          x: utils.is.number(target.x) ? (target.x + offsetX) : relativeX,\r\n          y: utils.is.number(target.y) ? (target.y + offsetY) : relativeY,\r\n\r\n          range: utils.is.number(target.range)? target.range: options.range,\r\n        });\r\n      }\r\n    }\r\n\r\n    const closest = {\r\n      target: null,\r\n      inRange: false,\r\n      distance: 0,\r\n      range: 0,\r\n      dx: 0,\r\n      dy: 0,\r\n    };\r\n\r\n    for (i = 0, len = targets.length; i < len; i++) {\r\n      target = targets[i];\r\n\r\n      const range = target.range;\r\n      const dx = target.x - page.x;\r\n      const dy = target.y - page.y;\r\n      const distance = utils.hypot(dx, dy);\r\n      let inRange = distance <= range;\r\n\r\n      // Infinite targets count as being out of range\r\n      // compared to non infinite ones that are in range\r\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\r\n        inRange = false;\r\n      }\r\n\r\n      if (!closest.target || (inRange\r\n          // is the closest target in range?\r\n          ? (closest.inRange && range !== Infinity\r\n          // the pointer is relatively deeper in this target\r\n          ? distance / range < closest.distance / closest.range\r\n          // this target has Infinite range and the closest doesn't\r\n          : (range === Infinity && closest.range !== Infinity)\r\n          // OR this target is closer that the previous closest\r\n        || distance < closest.distance)\r\n          // The other is not in range and the pointer is closer to this target\r\n          : (!closest.inRange && distance < closest.distance))) {\r\n\r\n        closest.target = target;\r\n        closest.distance = distance;\r\n        closest.range = range;\r\n        closest.inRange = inRange;\r\n        closest.dx = dx;\r\n        closest.dy = dy;\r\n\r\n        status.range = range;\r\n      }\r\n    }\r\n\r\n    let snapChanged;\r\n\r\n    if (closest.target) {\r\n      snapChanged = (status.modifiedX !== closest.target.x || status.modifiedY !== closest.target.y);\r\n\r\n      status.modifiedX = closest.target.x;\r\n      status.modifiedY = closest.target.y;\r\n    }\r\n    else {\r\n      snapChanged = true;\r\n\r\n      status.modifiedX = NaN;\r\n      status.modifiedY = NaN;\r\n    }\r\n\r\n    status.dx = closest.dx;\r\n    status.dy = closest.dy;\r\n\r\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\r\n    status.locked = closest.inRange;\r\n  },\r\n\r\n  modifyCoords: function ({ page, client, status, phase, options }) {\r\n    const relativePoints = options && options.relativePoints;\r\n\r\n    if (options && options.enabled\r\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n      }\r\n\r\n      return {\r\n        range  : status.range,\r\n        locked : status.locked,\r\n        x      : status.modifiedX,\r\n        y      : status.modifiedY,\r\n        realX  : status.realX,\r\n        realY  : status.realY,\r\n        dx     : status.dx,\r\n        dy     : status.dy,\r\n      };\r\n    }\r\n  },\r\n};\r\n\r\ninteract.createSnapGrid = function (grid) {\r\n  return function (x, y) {\r\n    const limits = grid.limits || {\r\n      left  : -Infinity,\r\n      right :  Infinity,\r\n      top   : -Infinity,\r\n      bottom:  Infinity,\r\n    };\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (utils.is.object(grid.offset)) {\r\n      offsetX = grid.offset.x;\r\n      offsetY = grid.offset.y;\r\n    }\r\n\r\n    const gridx = Math.round((x - offsetX) / grid.x);\r\n    const gridy = Math.round((y - offsetY) / grid.y);\r\n\r\n    const newX = Math.max(limits.left, Math.min(limits.right , gridx * grid.x + offsetX));\r\n    const newY = Math.max(limits.top , Math.min(limits.bottom, gridy * grid.y + offsetY));\r\n\r\n    return {\r\n      x: newX,\r\n      y: newY,\r\n      range: grid.range,\r\n    };\r\n  };\r\n};\r\n\r\nmodifiers.snap = snap;\r\nmodifiers.names.push('snap');\r\n\r\ndefaultOptions.perAction.snap = snap.defaults;\r\n\r\nmodule.exports = snap;\r\n","// This module allows snapping of the size of targets during resize\r\n// interactions.\r\n\r\nconst modifiers      = require('./index');\r\nconst snap           = require('./snap');\r\nconst defaultOptions = require('../defaultOptions');\r\nconst resize         = require('../actions/resize');\r\nconst utils          = require('../utils/');\r\n\r\nconst snapSize = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    range  : Infinity,\r\n    targets: null,\r\n    offsets: null,\r\n  },\r\n\r\n  setOffset: function (arg) {\r\n    const { interaction, options } = arg;\r\n    const edges = interaction.prepared.edges;\r\n\r\n    if (!edges) { return; }\r\n\r\n    arg.options = {\r\n      relativePoints: [{\r\n        x: edges.left? 0 : 1,\r\n        y: edges.top ? 0 : 1,\r\n      }],\r\n      origin: { x: 0, y: 0 },\r\n      offset: 'self',\r\n      range: options.range,\r\n    };\r\n\r\n    const offsets = snap.setOffset(arg);\r\n    arg.options = options;\r\n\r\n    return offsets;\r\n  },\r\n\r\n  set: function (arg) {\r\n    const { interaction, options, offset, pageCoords } = arg;\r\n    const page = utils.extend({}, pageCoords);\r\n    const relativeX = page.x - offset[0].x;\r\n    const relativeY = page.y - offset[0].y;\r\n\r\n    arg.options = utils.extend({}, options);\r\n    arg.options.targets = [];\r\n\r\n    for (const snapTarget of options.targets) {\r\n      let target;\r\n\r\n      if (utils.is.function(snapTarget)) {\r\n        target = snapTarget(relativeX, relativeY, interaction);\r\n      }\r\n      else {\r\n        target = snapTarget;\r\n      }\r\n\r\n      if (!target) { continue; }\r\n\r\n      if ('width' in target && 'height' in target) {\r\n        target.x = target.width;\r\n        target.y = target.height;\r\n      }\r\n\r\n      arg.options.targets.push(target);\r\n    }\r\n\r\n    snap.set(arg);\r\n  },\r\n\r\n  modifyCoords: function (arg) {\r\n    const { options } = arg;\r\n\r\n    arg.options = utils.extend({}, options);\r\n    arg.options.enabled = options.enabled;\r\n    arg.options.relativePoints = [null];\r\n\r\n    snap.modifyCoords(arg);\r\n  },\r\n};\r\n\r\nmodifiers.snapSize = snapSize;\r\nmodifiers.names.push('snapSize');\r\n\r\ndefaultOptions.perAction.snapSize = snapSize.defaults;\r\nresize.defaults.snapSize          = snapSize.defaults;\r\n\r\nmodule.exports = snapSize;\r\n","const pointerUtils = require('../utils/pointerUtils');\r\n\r\nmodule.exports = class PointerEvent {\r\n  constructor (type, pointer, event, eventTarget, interaction) {\r\n    pointerUtils.pointerExtend(this, event);\r\n\r\n    if (event !== pointer) {\r\n      pointerUtils.pointerExtend(this, pointer);\r\n    }\r\n\r\n    this.interaction = interaction;\r\n\r\n    this.timeStamp     = new Date().getTime();\r\n    this.originalEvent = event;\r\n    this.type          = type;\r\n    this.pointerId     = pointerUtils.getPointerId(pointer);\r\n    this.pointerType   = pointerUtils.getPointerType(pointer, interaction);\r\n    this.target        = eventTarget;\r\n    this.currentTarget = null;\r\n\r\n    if (type === 'tap') {\r\n      const pointerIndex = interaction.getPointerIndex(pointer);\r\n      this.dt = this.timeStamp - interaction.downTimes[pointerIndex];\r\n\r\n      const interval = this.timeStamp - interaction.tapTime;\r\n\r\n      this.double = !!(interaction.prevTap\r\n        && interaction.prevTap.type !== 'doubletap'\r\n        && interaction.prevTap.target === this.target\r\n        && interval < 500);\r\n    }\r\n    else if (type === 'doubletap') {\r\n      this.dt = pointer.timeStamp - interaction.tapTime;\r\n    }\r\n  }\r\n\r\n  subtractOrigin ({ x: originX, y: originY }) {\r\n    this.pageX   -= originX;\r\n    this.pageY   -= originY;\r\n    this.clientX -= originX;\r\n    this.clientY -= originY;\r\n\r\n    return this;\r\n  }\r\n\r\n  addOrigin ({ x: originX, y: originY }) {\r\n    this.pageX   += originX;\r\n    this.pageY   += originY;\r\n    this.clientX += originX;\r\n    this.clientY += originY;\r\n\r\n    return this;\r\n  }\r\n\r\n  preventDefault () {\r\n    this.originalEvent.preventDefault();\r\n  }\r\n\r\n  stopPropagation () {\r\n    this.propagationStopped = true;\r\n  }\r\n\r\n  stopImmediatePropagation () {\r\n    this.immediatePropagationStopped = this.propagationStopped = true;\r\n  }\r\n};\r\n","const PointerEvent = require('./PointerEvent');\r\nconst Interaction  = require('../Interaction');\r\nconst utils        = require('../utils');\r\nconst browser      = require('../utils/browser');\r\nconst defaults     = require('../defaultOptions');\r\nconst signals      = require('../utils/Signals').new();\r\nconst { filter }   = require('../utils/arr');\r\n\r\nconst simpleSignals = [ 'down', 'up', 'cancel' ];\r\nconst simpleEvents  = [ 'down', 'up', 'cancel' ];\r\n\r\nconst pointerEvents = {\r\n  PointerEvent,\r\n  fire,\r\n  collectEventTargets,\r\n  signals,\r\n  defaults: {\r\n    holdDuration: 600,\r\n    ignoreFrom  : null,\r\n    allowFrom   : null,\r\n    origin      : { x: 0, y: 0 },\r\n  },\r\n  types: [\r\n    'down',\r\n    'move',\r\n    'up',\r\n    'cancel',\r\n    'tap',\r\n    'doubletap',\r\n    'hold',\r\n  ],\r\n};\r\n\r\nfunction fire (arg) {\r\n  const {\r\n    interaction, pointer, event, eventTarget,\r\n    type = arg.pointerEvent.type,\r\n    targets = collectEventTargets(arg),\r\n    pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction),\r\n  } = arg;\r\n\r\n  const signalArg = {\r\n    interaction,\r\n    pointer,\r\n    event,\r\n    eventTarget,\r\n    targets,\r\n    type,\r\n    pointerEvent,\r\n  };\r\n\r\n  for (let i = 0; i < targets.length; i++) {\r\n    const target = targets[i];\r\n\r\n    for (const prop in target.props || {}) {\r\n      pointerEvent[prop] = target.props[prop];\r\n    }\r\n\r\n    const origin = utils.getOriginXY(target.eventable, target.element);\r\n\r\n    pointerEvent.subtractOrigin(origin);\r\n    pointerEvent.eventable = target.eventable;\r\n    pointerEvent.currentTarget = target.element;\r\n\r\n    target.eventable.fire(pointerEvent);\r\n\r\n    pointerEvent.addOrigin(origin);\r\n\r\n    if (pointerEvent.immediatePropagationStopped\r\n        || (pointerEvent.propagationStopped\r\n            && (i + 1) < targets.length && targets[i + 1].element !== pointerEvent.currentTarget)) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  signals.fire('fired', signalArg);\r\n\r\n  if (type === 'tap') {\r\n    // if pointerEvent should make a double tap, create and fire a doubletap\r\n    // PointerEvent and use that as the prevTap\r\n    const prevTap = pointerEvent.double\r\n      ? fire({\r\n        interaction, pointer, event, eventTarget,\r\n        type: 'doubletap',\r\n      })\r\n      : pointerEvent;\r\n\r\n    interaction.prevTap = prevTap;\r\n    interaction.tapTime = prevTap.timeStamp;\r\n  }\r\n\r\n  return pointerEvent;\r\n}\r\n\r\nfunction collectEventTargets ({ interaction, pointer, event, eventTarget, type }) {\r\n  const pointerIndex = interaction.getPointerIndex(pointer);\r\n\r\n  // do not fire a tap event if the pointer was moved before being lifted\r\n  if (type === 'tap' && (interaction.pointerWasMoved\r\n      // or if the pointerup target is different to the pointerdown target\r\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\r\n    return [];\r\n  }\r\n\r\n  const path = utils.getPath(eventTarget);\r\n  const signalArg = {\r\n    interaction,\r\n    pointer,\r\n    event,\r\n    eventTarget,\r\n    type,\r\n    path,\r\n    targets: [],\r\n    element: null,\r\n  };\r\n\r\n  for (const element of path) {\r\n    signalArg.element = element;\r\n\r\n    signals.fire('collect-targets', signalArg);\r\n  }\r\n\r\n  if (type === 'hold') {\r\n    signalArg.targets = filter(signalArg.targets, target =>\r\n      target.eventable.options.holdDuration === interaction.holdTimers[pointerIndex].duration);\r\n  }\r\n\r\n  return signalArg.targets;\r\n}\r\n\r\nInteraction.signals.on('update-pointer-down', function ({ interaction, pointerIndex }) {\r\n  interaction.holdTimers[pointerIndex] = { duration: Infinity, timeout: null };\r\n});\r\n\r\nInteraction.signals.on('remove-pointer', function ({ interaction, pointerIndex }) {\r\n  interaction.holdTimers.splice(pointerIndex, 1);\r\n});\r\n\r\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\r\n  const pointerIndex = interaction.getPointerIndex(pointer);\r\n\r\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\r\n    if (interaction.pointerIsDown) {\r\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\r\n    }\r\n\r\n    fire({\r\n      interaction, pointer, event, eventTarget,\r\n      type: 'move',\r\n    });\r\n  }\r\n});\r\n\r\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\r\n  // copy event to be used in timeout for IE8\r\n  const eventCopy = browser.isIE8? utils.extend({}, event) : event;\r\n\r\n  const timer = interaction.holdTimers[pointerIndex];\r\n  const path = utils.getPath(eventTarget);\r\n  const signalArg = {\r\n    interaction,\r\n    pointer,\r\n    event,\r\n    eventTarget,\r\n    type: 'hold',\r\n    targets: [],\r\n    path,\r\n    element: null,\r\n  };\r\n\r\n  for (const element of path) {\r\n    signalArg.element = element;\r\n\r\n    signals.fire('collect-targets', signalArg);\r\n  }\r\n\r\n  if (!signalArg.targets.length) { return; }\r\n\r\n  let minDuration = Infinity;\r\n\r\n  for (let i = 0; i < signalArg.targets.length; i++) {\r\n    const target = signalArg.targets[i];\r\n    const holdDuration = target.eventable.options.holdDuration;\r\n\r\n    if (holdDuration < minDuration) {\r\n      minDuration = holdDuration;\r\n    }\r\n  }\r\n\r\n  timer.duration = minDuration;\r\n  timer.timeout = setTimeout(function () {\r\n    fire({\r\n      interaction, eventCopy, eventTarget,\r\n      pointer: browser.isIE8? eventCopy : pointer,\r\n      type: 'hold',\r\n    });\r\n  }, minDuration);\r\n});\r\n\r\nInteraction.signals.on('up', ({ interaction, pointer, event, eventTarget }) => {\r\n  if (!interaction.pointerWasMoved) {\r\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' });\r\n  }\r\n});\r\n\r\n['up', 'cancel'].forEach(function (signalName) {\r\n  Interaction.signals.on(signalName, function ({ interaction, pointerIndex }) {\r\n    if (interaction.holdTimers[pointerIndex]) {\r\n      clearTimeout(interaction.holdTimers[pointerIndex].timeout);\r\n    }\r\n  });\r\n});\r\n\r\nfunction createSignalListener (type) {\r\n  return function ({ interaction, pointer, event, eventTarget }) {\r\n    fire({ interaction, eventTarget, pointer, event, type });\r\n  };\r\n}\r\n\r\nfor (let i = 0; i < simpleSignals.length; i++) {\r\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\r\n}\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.prevTap    = null;  // the most recent tap event on this interaction\r\n  interaction.tapTime    = 0;     // time of the most recent tap event\r\n  interaction.holdTimers = [];    // [{ duration, timeout }]\r\n});\r\n\r\ndefaults.pointerEvents = pointerEvents.defaults;\r\nmodule.exports = pointerEvents;\r\n","const pointerEvents = require('./base');\r\nconst Interaction   = require('../Interaction');\r\n\r\npointerEvents.signals.on('new', onNew);\r\npointerEvents.signals.on('fired', onFired);\r\n\r\nfor (const signal of ['move', 'up', 'cancel', 'endall']) {\r\n  Interaction.signals.on(signal, endHoldRepeat);\r\n}\r\n\r\nfunction onNew ({ pointerEvent }) {\r\n  if (pointerEvent.type !== 'hold') { return; }\r\n\r\n  pointerEvent.count = (pointerEvent.count || 0) + 1;\r\n}\r\n\r\nfunction onFired ({ interaction, pointerEvent, eventTarget, targets }) {\r\n  if (pointerEvent.type !== 'hold' || !targets.length) { return; }\r\n\r\n  // get the repeat interval from the first eventable\r\n  const interval = targets[0].eventable.options.holdRepeatInterval;\r\n\r\n  // don't repeat if the interval is 0 or less\r\n  if (interval <= 0) { return; }\r\n\r\n  // set a timeout to fire the holdrepeat event\r\n  interaction.holdIntervalHandle = setTimeout(function () {\r\n    pointerEvents.fire({\r\n      interaction,\r\n      eventTarget,\r\n      type: 'hold',\r\n      pointer: pointerEvent,\r\n      event: pointerEvent,\r\n    });\r\n  }, interval);\r\n}\r\n\r\nfunction endHoldRepeat ({ interaction }) {\r\n  // set the interaction's holdStopTime property\r\n  // to stop further holdRepeat events\r\n  if (interaction.holdIntervalHandle) {\r\n    clearInterval(interaction.holdIntervalHandle);\r\n    interaction.holdIntervalHandle = null;\r\n  }\r\n}\r\n\r\n// don't repeat by default\r\npointerEvents.defaults.holdRepeatInterval = 0;\r\npointerEvents.types.push('holdrepeat');\r\n\r\nmodule.exports = {\r\n  onNew,\r\n  onFired,\r\n  endHoldRepeat,\r\n};\r\n","const pointerEvents = require('./base');\r\nconst Interactable  = require('../Interactable');\r\nconst browser       = require('../utils/browser');\r\nconst is            = require('../utils/is');\r\nconst domUtils      = require('../utils/domUtils');\r\nconst scope         = require('../scope');\r\nconst extend        = require('../utils/extend');\r\nconst { merge }     = require('../utils/arr');\r\n\r\npointerEvents.signals.on('collect-targets', function ({ targets, element, type, eventTarget }) {\r\n  function collectSelectors (interactable, selector, context) {\r\n    const els = browser.useMatchesSelectorPolyfill\r\n        ? context.querySelectorAll(selector)\r\n        : undefined;\r\n\r\n    const eventable = interactable.events;\r\n    const options = eventable.options;\r\n\r\n    if (eventable[type]\r\n        && is.element(element)\r\n        && domUtils.matchesSelector(element, selector, els)\r\n        && interactable.testIgnoreAllow(options, element, eventTarget)) {\r\n\r\n      targets.push({\r\n        element,\r\n        eventable,\r\n        props: { interactable },\r\n      });\r\n    }\r\n  }\r\n\r\n  const interactable = scope.interactables.get(element);\r\n\r\n  if (interactable) {\r\n    const eventable = interactable.events;\r\n    const options = eventable.options;\r\n\r\n    if (eventable[type]\r\n        && interactable.testIgnoreAllow(options, element, eventTarget)) {\r\n      targets.push({\r\n        element,\r\n        eventable,\r\n        props: { interactable },\r\n      });\r\n    }\r\n  }\r\n\r\n  scope.interactables.forEachSelector(collectSelectors, element);\r\n});\r\n\r\nInteractable.signals.on('new', function ({ interactable }) {\r\n  interactable.events.getRect = function (element) {\r\n    return interactable.getRect(element);\r\n  };\r\n});\r\n\r\nInteractable.signals.on('set', function ({ interactable, options }) {\r\n  extend(interactable.events.options, pointerEvents.defaults);\r\n  extend(interactable.events.options, options);\r\n});\r\n\r\nmerge(Interactable.eventTypes, pointerEvents.types);\r\n\r\nInteractable.prototype.pointerEvents = function (options) {\r\n  extend(this.events.options, options);\r\n\r\n  return this;\r\n};\r\n\r\nconst __backCompatOption = Interactable.prototype._backCompatOption;\r\n\r\nInteractable.prototype._backCompatOption = function (optionName, newValue) {\r\n  const ret = __backCompatOption.call(this, optionName, newValue);\r\n\r\n  if (ret === this) {\r\n    this.events.options[optionName] = newValue;\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\nInteractable.settingsMethods.push('pointerEvents');\r\n","const utils   = require('./utils');\r\nconst events  = require('./utils/events');\r\nconst signals = require('./utils/Signals').new();\r\n\r\nconst scope = {\r\n  signals,\r\n  events,\r\n  utils,\r\n\r\n  // main document\r\n  document: require('./utils/domObjects').document,\r\n  // all documents being listened to\r\n  documents: [],\r\n\r\n  addDocument: function (doc, win) {\r\n    // do nothing if document is already known\r\n    if (utils.contains(scope.documents, doc)) { return false; }\r\n\r\n    win = win || scope.getWindow(doc);\r\n\r\n    scope.documents.push(doc);\r\n    events.documents.push(doc);\r\n\r\n    // don't add an unload event for the main document\r\n    // so that the page may be cached in browser history\r\n    if (doc !== scope.document) {\r\n      events.add(win, 'unload', scope.onWindowUnload);\r\n    }\r\n\r\n    signals.fire('add-document', { doc, win });\r\n  },\r\n\r\n  removeDocument: function (doc, win) {\r\n    const index = utils.indexOf(scope.documents, doc);\r\n\r\n    win = win || scope.getWindow(doc);\r\n\r\n    events.remove(win, 'unload', scope.onWindowUnload);\r\n\r\n    scope.documents.splice(index, 1);\r\n    events.documents.splice(index, 1);\r\n\r\n    signals.fire('remove-document', { win, doc });\r\n  },\r\n\r\n  onWindowUnload: function () {\r\n    scope.removeDocument(this.document, this);\r\n  },\r\n};\r\n\r\nmodule.exports = scope;\r\n","const { indexOf } = require('./arr');\r\n\r\nclass Signals {\r\n  constructor () {\r\n    this.listeners = {\r\n      // signalName: [listeners],\r\n    };\r\n  }\r\n\r\n  on (name, listener) {\r\n    if (!this.listeners[name]) {\r\n      this.listeners[name] = [listener];\r\n      return;\r\n    }\r\n\r\n    this.listeners[name].push(listener);\r\n  }\r\n\r\n  off (name, listener) {\r\n    if (!this.listeners[name]) { return; }\r\n\r\n    const index = indexOf(this.listeners[name], listener);\r\n\r\n    if (index !== -1) {\r\n      this.listeners[name].splice(index, 1);\r\n    }\r\n  }\r\n\r\n  fire (name, arg) {\r\n    const targetListeners = this.listeners[name];\r\n\r\n    if (!targetListeners) { return; }\r\n\r\n    for (let i = 0; i < targetListeners.length; i++) {\r\n      if (targetListeners[i](arg, name) === false) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nSignals.new = function () {\r\n  return new Signals();\r\n};\r\n\r\nmodule.exports = Signals;\r\n","function indexOf (array, target) {\r\n  for (let i = 0, len = array.length; i < len; i++) {\r\n    if (array[i] === target) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction contains (array, target) {\r\n  return indexOf(array, target) !== -1;\r\n}\r\n\r\nfunction merge (target, source) {\r\n  for (let i = 0; i < source.length; i++) {\r\n    target.push(source[i]);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction filter (array, test) {\r\n  const result = [];\r\n\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (test(array[i])) {\r\n      result.push(array[i]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = {\r\n  indexOf,\r\n  contains,\r\n  merge,\r\n  filter,\r\n};\r\n","const { window } = require('./window');\r\nconst is     = require('./is');\r\nconst domObjects = require('./domObjects');\r\n\r\nconst Element = domObjects.Element;\r\nconst navigator  = window.navigator;\r\n\r\nconst browser = {\r\n  // Does the browser support touch input?\r\n  supportsTouch: !!(('ontouchstart' in window) || is.function(window.DocumentTouch)\r\n                     && domObjects.document instanceof window.DocumentTouch),\r\n\r\n  // Does the browser support PointerEvents\r\n  supportsPointerEvent: !!domObjects.PointerEvent,\r\n\r\n  isIE8: ('attachEvent' in window) && !('addEventListener' in window),\r\n\r\n  // Opera Mobile must be handled differently\r\n  isOperaMobile: (navigator.appName === 'Opera'\r\n      && browser.supportsTouch\r\n      && navigator.userAgent.match('Presto')),\r\n\r\n  // scrolling doesn't change the result of getClientRects on iOS 7\r\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\r\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\r\n\r\n  isIe9OrOlder: /MSIE (8|9)/.test(navigator.userAgent),\r\n\r\n  // prefix matchesSelector\r\n  prefixedMatchesSelector: 'matches' in Element.prototype\r\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\r\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\r\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\r\n    ? 'oMatchesSelector': 'msMatchesSelector',\r\n\r\n  useMatchesSelectorPolyfill: false,\r\n\r\n  pEventTypes: (domObjects.PointerEvent\r\n    ? (domObjects.PointerEvent === window.MSPointerEvent\r\n      ? {\r\n        up:     'MSPointerUp',\r\n        down:   'MSPointerDown',\r\n        over:   'mouseover',\r\n        out:    'mouseout',\r\n        move:   'MSPointerMove',\r\n        cancel: 'MSPointerCancel',\r\n      }\r\n      : {\r\n        up:     'pointerup',\r\n        down:   'pointerdown',\r\n        over:   'pointerover',\r\n        out:    'pointerout',\r\n        move:   'pointermove',\r\n        cancel: 'pointercancel',\r\n      })\r\n    : null),\r\n\r\n  // because Webkit and Opera still use 'mousewheel' event type\r\n  wheelEvent: 'onmousewheel' in domObjects.document? 'mousewheel': 'wheel',\r\n\r\n};\r\n\r\nbrowser.useMatchesSelectorPolyfill = !is.function(Element.prototype[browser.prefixedMatchesSelector]);\r\n\r\nmodule.exports = browser;\r\n","const domObjects = {};\r\nconst win = require('./window').window;\r\n\r\nfunction blank () {}\r\n\r\ndomObjects.document           = win.document;\r\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\r\ndomObjects.SVGElement         = win.SVGElement         || blank;\r\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\r\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\r\ndomObjects.Element            = win.Element            || blank;\r\ndomObjects.HTMLElement        = win.HTMLElement        || domObjects.Element;\r\n\r\ndomObjects.Event        = win.Event;\r\ndomObjects.Touch        = win.Touch || blank;\r\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\r\n\r\nmodule.exports = domObjects;\r\n","const win        = require('./window');\r\nconst browser    = require('./browser');\r\nconst is         = require('./is');\r\nconst domObjects = require('./domObjects');\r\n\r\nconst domUtils = {\r\n  nodeContains: function (parent, child) {\r\n    while (child) {\r\n      if (child === parent) {\r\n        return true;\r\n      }\r\n\r\n      child = child.parentNode;\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  closest: function (element, selector) {\r\n    while (is.element(element)) {\r\n      if (domUtils.matchesSelector(element, selector)) { return element; }\r\n\r\n      element = domUtils.parentNode(element);\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  parentNode: function (node) {\r\n    let parent = node.parentNode;\r\n\r\n    if (is.docFrag(parent)) {\r\n      // skip past #shado-root fragments\r\n      while ((parent = parent.host) && is.docFrag(parent)) {\r\n        continue;\r\n      }\r\n\r\n      return parent;\r\n    }\r\n\r\n    return parent;\r\n  },\r\n\r\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\r\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill\r\n    ? function (element, selector, elems) {\r\n      elems = elems || element.parentNode.querySelectorAll(selector);\r\n\r\n      for (let i = 0, len = elems.length; i < len; i++) {\r\n        if (elems[i] === element) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n    : null,\r\n\r\n  matchesSelector: function (element, selector, nodeList) {\r\n    if (browser.useMatchesSelectorPolyfill) {\r\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\r\n    }\r\n\r\n    // remove /deep/ from selectors if shadowDOM polyfill is used\r\n    if (win.window !== win.realWindow) {\r\n      selector = selector.replace(/\\/deep\\//g, ' ');\r\n    }\r\n\r\n    return element[browser.prefixedMatchesSelector](selector);\r\n  },\r\n\r\n  // Test for the element that's \"above\" all other qualifiers\r\n  indexOfDeepestElement: function (elements) {\r\n    let deepestZoneParents = [];\r\n    let dropzoneParents = [];\r\n    let dropzone;\r\n    let deepestZone = elements[0];\r\n    let index = deepestZone? 0: -1;\r\n    let parent;\r\n    let child;\r\n    let i;\r\n    let n;\r\n\r\n    for (i = 1; i < elements.length; i++) {\r\n      dropzone = elements[i];\r\n\r\n      // an element might belong to multiple selector dropzones\r\n      if (!dropzone || dropzone === deepestZone) {\r\n        continue;\r\n      }\r\n\r\n      if (!deepestZone) {\r\n        deepestZone = dropzone;\r\n        index = i;\r\n        continue;\r\n      }\r\n\r\n      // check if the deepest or current are document.documentElement or document.rootElement\r\n      // - if the current dropzone is, do nothing and continue\r\n      if (dropzone.parentNode === dropzone.ownerDocument) {\r\n        continue;\r\n      }\r\n      // - if deepest is, update with the current dropzone and continue to next\r\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\r\n        deepestZone = dropzone;\r\n        index = i;\r\n        continue;\r\n      }\r\n\r\n      if (!deepestZoneParents.length) {\r\n        parent = deepestZone;\r\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\r\n          deepestZoneParents.unshift(parent);\r\n          parent = parent.parentNode;\r\n        }\r\n      }\r\n\r\n      // if this element is an svg element and the current deepest is\r\n      // an HTMLElement\r\n      if (deepestZone instanceof domObjects.HTMLElement\r\n          && dropzone instanceof domObjects.SVGElement\r\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\r\n\r\n        if (dropzone === deepestZone.parentNode) {\r\n          continue;\r\n        }\r\n\r\n        parent = dropzone.ownerSVGElement;\r\n      }\r\n      else {\r\n        parent = dropzone;\r\n      }\r\n\r\n      dropzoneParents = [];\r\n\r\n      while (parent.parentNode !== parent.ownerDocument) {\r\n        dropzoneParents.unshift(parent);\r\n        parent = parent.parentNode;\r\n      }\r\n\r\n      n = 0;\r\n\r\n      // get (position of last common ancestor) + 1\r\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\r\n        n++;\r\n      }\r\n\r\n      const parents = [\r\n        dropzoneParents[n - 1],\r\n        dropzoneParents[n],\r\n        deepestZoneParents[n],\r\n      ];\r\n\r\n      child = parents[0].lastChild;\r\n\r\n      while (child) {\r\n        if (child === parents[1]) {\r\n          deepestZone = dropzone;\r\n          index = i;\r\n          deepestZoneParents = [];\r\n\r\n          break;\r\n        }\r\n        else if (child === parents[2]) {\r\n          break;\r\n        }\r\n\r\n        child = child.previousSibling;\r\n      }\r\n    }\r\n\r\n    return index;\r\n  },\r\n\r\n  matchesUpTo: function (element, selector, limit) {\r\n    while (is.element(element)) {\r\n      if (domUtils.matchesSelector(element, selector)) {\r\n        return true;\r\n      }\r\n\r\n      element = domUtils.parentNode(element);\r\n\r\n      if (element === limit) {\r\n        return domUtils.matchesSelector(element, selector);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  getActualElement: function (element) {\r\n    return (element instanceof domObjects.SVGElementInstance\r\n      ? element.correspondingUseElement\r\n      : element);\r\n  },\r\n\r\n  getScrollXY: function (relevantWindow) {\r\n    relevantWindow = relevantWindow || win.window;\r\n    return {\r\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\r\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\r\n    };\r\n  },\r\n\r\n  getElementClientRect: function (element) {\r\n    const clientRect = (element instanceof domObjects.SVGElement\r\n      ? element.getBoundingClientRect()\r\n      : element.getClientRects()[0]);\r\n\r\n    return clientRect && {\r\n      left  : clientRect.left,\r\n      right : clientRect.right,\r\n      top   : clientRect.top,\r\n      bottom: clientRect.bottom,\r\n      width : clientRect.width  || clientRect.right  - clientRect.left,\r\n      height: clientRect.height || clientRect.bottom - clientRect.top,\r\n    };\r\n  },\r\n\r\n  getElementRect: function (element) {\r\n    const clientRect = domUtils.getElementClientRect(element);\r\n\r\n    if (!browser.isIOS7 && clientRect) {\r\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\r\n\r\n      clientRect.left   += scroll.x;\r\n      clientRect.right  += scroll.x;\r\n      clientRect.top    += scroll.y;\r\n      clientRect.bottom += scroll.y;\r\n    }\r\n\r\n    return clientRect;\r\n  },\r\n\r\n  getPath: function (element) {\r\n    const path = [];\r\n\r\n    while (element) {\r\n      path.push(element);\r\n      element = domUtils.parentNode(element);\r\n    }\r\n\r\n    return path;\r\n  },\r\n\r\n  trySelector: value => {\r\n    if (!is.string(value)) { return false; }\r\n\r\n    // an exception will be raised if it is invalid\r\n    domObjects.document.querySelector(value);\r\n    return true;\r\n  },\r\n};\r\n\r\nmodule.exports = domUtils;\r\n","const is   = require('./is');\r\nconst domUtils = require('./domUtils');\r\nconst pExtend  = require('./pointerExtend');\r\n\r\nconst { window, getWindow }  = require('./window');\r\nconst { indexOf, contains } = require('./arr');\r\n\r\nconst useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window);\r\nconst addEvent       = useAttachEvent?  'attachEvent': 'addEventListener';\r\nconst removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener';\r\nconst on             = useAttachEvent? 'on': '';\r\n\r\nconst elements          = [];\r\nconst targets           = [];\r\nconst attachedListeners = [];\r\n\r\n// {\r\n//   type: {\r\n//     selectors: ['selector', ...],\r\n//     contexts : [document, ...],\r\n//     listeners: [[listener, capture, passive], ...]\r\n//   }\r\n//  }\r\nconst delegatedEvents = {};\r\n\r\nconst documents = [];\r\n\r\nconst supportsOptions = !useAttachEvent && (() => {\r\n  let supported = false;\r\n\r\n  window.document.createElement('div').addEventListener('test', null, {\r\n    get capture () { supported = true; },\r\n  });\r\n\r\n  return supported;\r\n})();\r\n\r\nfunction add (element, type, listener, optionalArg) {\r\n  const options = getOptions(optionalArg);\r\n  let elementIndex = indexOf(elements, element);\r\n  let target = targets[elementIndex];\r\n\r\n  if (!target) {\r\n    target = {\r\n      events: {},\r\n      typeCount: 0,\r\n    };\r\n\r\n    elementIndex = elements.push(element) - 1;\r\n    targets.push(target);\r\n\r\n    attachedListeners.push(useAttachEvent\r\n      ? {\r\n        supplied: [],\r\n        wrapped : [],\r\n        useCount: [],\r\n      }\r\n      : null);\r\n  }\r\n\r\n  if (!target.events[type]) {\r\n    target.events[type] = [];\r\n    target.typeCount++;\r\n  }\r\n\r\n  if (!contains(target.events[type], listener)) {\r\n    let ret;\r\n\r\n    if (useAttachEvent) {\r\n      const { supplied, wrapped, useCount } = attachedListeners[elementIndex];\r\n      const listenerIndex = indexOf(supplied, listener);\r\n\r\n      const wrappedListener = wrapped[listenerIndex] || function (event) {\r\n        if (!event.immediatePropagationStopped) {\r\n          event.target = event.srcElement;\r\n          event.currentTarget = element;\r\n\r\n          event.preventDefault           = event.preventDefault           || preventDef;\r\n          event.stopPropagation          = event.stopPropagation          || stopProp;\r\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\r\n\r\n          if (/mouse|click/.test(event.type)) {\r\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\r\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\r\n          }\r\n\r\n          listener(event);\r\n        }\r\n      };\r\n\r\n      ret = element[addEvent](on + type, wrappedListener, !!options.capture);\r\n\r\n      if (listenerIndex === -1) {\r\n        supplied.push(listener);\r\n        wrapped.push(wrappedListener);\r\n        useCount.push(1);\r\n      }\r\n      else {\r\n        useCount[listenerIndex]++;\r\n      }\r\n    }\r\n    else {\r\n      ret = element[addEvent](type, listener, supportsOptions? options : !!options.capture);\r\n    }\r\n    target.events[type].push(listener);\r\n\r\n    return ret;\r\n  }\r\n}\r\n\r\nfunction remove (element, type, listener, optionalArg) {\r\n  const options = getOptions(optionalArg);\r\n  const elementIndex = indexOf(elements, element);\r\n  const target = targets[elementIndex];\r\n\r\n  if (!target || !target.events) {\r\n    return;\r\n  }\r\n\r\n  let wrappedListener = listener;\r\n  let listeners;\r\n  let listenerIndex;\r\n\r\n  if (useAttachEvent) {\r\n    listeners = attachedListeners[elementIndex];\r\n    listenerIndex = indexOf(listeners.supplied, listener);\r\n    wrappedListener = listeners.wrapped[listenerIndex];\r\n  }\r\n\r\n  if (type === 'all') {\r\n    for (type in target.events) {\r\n      if (target.events.hasOwnProperty(type)) {\r\n        remove(element, type, 'all');\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (target.events[type]) {\r\n    const len = target.events[type].length;\r\n\r\n    if (listener === 'all') {\r\n      for (let i = 0; i < len; i++) {\r\n        remove(element, type, target.events[type][i], options);\r\n      }\r\n      return;\r\n    }\r\n    else {\r\n      for (let i = 0; i < len; i++) {\r\n        if (target.events[type][i] === listener) {\r\n          element[removeEvent](on + type, wrappedListener, supportsOptions? options : !!options.capture);\r\n          target.events[type].splice(i, 1);\r\n\r\n          if (useAttachEvent && listeners) {\r\n            listeners.useCount[listenerIndex]--;\r\n            if (listeners.useCount[listenerIndex] === 0) {\r\n              listeners.supplied.splice(listenerIndex, 1);\r\n              listeners.wrapped.splice(listenerIndex, 1);\r\n              listeners.useCount.splice(listenerIndex, 1);\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (target.events[type] && target.events[type].length === 0) {\r\n      target.events[type] = null;\r\n      target.typeCount--;\r\n    }\r\n  }\r\n\r\n  if (!target.typeCount) {\r\n    targets.splice(elementIndex, 1);\r\n    elements.splice(elementIndex, 1);\r\n    attachedListeners.splice(elementIndex, 1);\r\n  }\r\n}\r\n\r\nfunction addDelegate (selector, context, type, listener, optionalArg) {\r\n  const options = getOptions(optionalArg);\r\n  if (!delegatedEvents[type]) {\r\n    delegatedEvents[type] = {\r\n      selectors: [],\r\n      contexts : [],\r\n      listeners: [],\r\n    };\r\n\r\n    // add delegate listener functions\r\n    for (let i = 0; i < documents.length; i++) {\r\n      add(documents[i], type, delegateListener);\r\n      add(documents[i], type, delegateUseCapture, true);\r\n    }\r\n  }\r\n\r\n  const delegated = delegatedEvents[type];\r\n  let index;\r\n\r\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\r\n    if (delegated.selectors[index] === selector\r\n        && delegated.contexts[index] === context) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (index === -1) {\r\n    index = delegated.selectors.length;\r\n\r\n    delegated.selectors.push(selector);\r\n    delegated.contexts .push(context);\r\n    delegated.listeners.push([]);\r\n  }\r\n\r\n  // keep listener and capture and passive flags\r\n  delegated.listeners[index].push([listener, !!options.capture, options.passive]);\r\n}\r\n\r\nfunction removeDelegate (selector, context, type, listener, optionalArg) {\r\n  const options = getOptions(optionalArg);\r\n  const delegated = delegatedEvents[type];\r\n  let matchFound = false;\r\n  let index;\r\n\r\n  if (!delegated) { return; }\r\n\r\n  // count from last index of delegated to 0\r\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\r\n    // look for matching selector and context Node\r\n    if (delegated.selectors[index] === selector\r\n        && delegated.contexts[index] === context) {\r\n\r\n      const listeners = delegated.listeners[index];\r\n\r\n      // each item of the listeners array is an array: [function, capture, passive]\r\n      for (let i = listeners.length - 1; i >= 0; i--) {\r\n        const [fn, capture, passive] = listeners[i];\r\n\r\n        // check if the listener functions and capture and passive flags match\r\n        if (fn === listener && capture === !!options.capture && passive === options.passive) {\r\n          // remove the listener from the array of listeners\r\n          listeners.splice(i, 1);\r\n\r\n          // if all listeners for this interactable have been removed\r\n          // remove the interactable from the delegated arrays\r\n          if (!listeners.length) {\r\n            delegated.selectors.splice(index, 1);\r\n            delegated.contexts .splice(index, 1);\r\n            delegated.listeners.splice(index, 1);\r\n\r\n            // remove delegate function from context\r\n            remove(context, type, delegateListener);\r\n            remove(context, type, delegateUseCapture, true);\r\n\r\n            // remove the arrays if they are empty\r\n            if (!delegated.selectors.length) {\r\n              delegatedEvents[type] = null;\r\n            }\r\n          }\r\n\r\n          // only remove one listener\r\n          matchFound = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (matchFound) { break; }\r\n    }\r\n  }\r\n}\r\n\r\n// bound to the interactable context when a DOM event\r\n// listener is added to a selector interactable\r\nfunction delegateListener (event, optionalArg) {\r\n  const options = getOptions(optionalArg);\r\n  const fakeEvent = {};\r\n  const delegated = delegatedEvents[event.type];\r\n  const eventTarget = (domUtils.getActualElement(event.path\r\n    ? event.path[0]\r\n    : event.target));\r\n  let element = eventTarget;\r\n\r\n  // duplicate the event so that currentTarget can be changed\r\n  pExtend(fakeEvent, event);\r\n\r\n  fakeEvent.originalEvent = event;\r\n  fakeEvent.preventDefault = preventOriginalDefault;\r\n\r\n  // climb up document tree looking for selector matches\r\n  while (is.element(element)) {\r\n    for (let i = 0; i < delegated.selectors.length; i++) {\r\n      const selector = delegated.selectors[i];\r\n      const context = delegated.contexts[i];\r\n\r\n      if (domUtils.matchesSelector(element, selector)\r\n          && domUtils.nodeContains(context, eventTarget)\r\n          && domUtils.nodeContains(context, element)) {\r\n\r\n        const listeners = delegated.listeners[i];\r\n\r\n        fakeEvent.currentTarget = element;\r\n\r\n        for (let j = 0; j < listeners.length; j++) {\r\n          const [fn, capture, passive] = listeners[j];\r\n\r\n          if (capture === !!options.capture && passive === options.passive) {\r\n            fn(fakeEvent);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    element = domUtils.parentNode(element);\r\n  }\r\n}\r\n\r\nfunction delegateUseCapture (event) {\r\n  return delegateListener.call(this, event, true);\r\n}\r\n\r\nfunction preventDef () {\r\n  this.returnValue = false;\r\n}\r\n\r\nfunction preventOriginalDefault () {\r\n  this.originalEvent.preventDefault();\r\n}\r\n\r\nfunction stopProp () {\r\n  this.cancelBubble = true;\r\n}\r\n\r\nfunction stopImmProp () {\r\n  this.cancelBubble = true;\r\n  this.immediatePropagationStopped = true;\r\n}\r\n\r\nfunction getOptions (param) {\r\n  return is.object(param)? param : { capture: param };\r\n}\r\n\r\nmodule.exports = {\r\n  add,\r\n  remove,\r\n\r\n  addDelegate,\r\n  removeDelegate,\r\n\r\n  delegateListener,\r\n  delegateUseCapture,\r\n  delegatedEvents,\r\n  documents,\r\n\r\n  useAttachEvent,\r\n  supportsOptions,\r\n\r\n  _elements: elements,\r\n  _targets: targets,\r\n  _attachedListeners: attachedListeners,\r\n};\r\n","module.exports = function extend (dest, source) {\r\n  for (const prop in source) {\r\n    dest[prop] = source[prop];\r\n  }\r\n  return dest;\r\n};\r\n","const {\r\n  resolveRectLike,\r\n  rectToXY,\r\n} = require('./rect');\r\n\r\nmodule.exports = function (target, element, action) {\r\n  const actionOptions = target.options[action];\r\n  const actionOrigin = actionOptions && actionOptions.origin;\r\n  const origin = actionOrigin || target.options.origin;\r\n\r\n  const originRect = resolveRectLike(origin, target, element, [target && element]);\r\n\r\n  return rectToXY(originRect) || { x: 0, y: 0 };\r\n};\r\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\r\n","const extend = require('./extend');\r\nconst win    = require('./window');\r\n\r\nconst utils = {\r\n  warnOnce: function (method, message) {\r\n    let warned = false;\r\n\r\n    return function () {\r\n      if (!warned) {\r\n        win.window.console.warn(message);\r\n        warned = true;\r\n      }\r\n\r\n      return method.apply(this, arguments);\r\n    };\r\n  },\r\n\r\n  // http://stackoverflow.com/a/5634528/2280888\r\n  _getQBezierValue: function (t, p1, p2, p3) {\r\n    const iT = 1 - t;\r\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\r\n  },\r\n\r\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\r\n    return {\r\n      x:  utils._getQBezierValue(position, startX, cpX, endX),\r\n      y:  utils._getQBezierValue(position, startY, cpY, endY),\r\n    };\r\n  },\r\n\r\n  // http://gizma.com/easing/\r\n  easeOutQuad: function (t, b, c, d) {\r\n    t /= d;\r\n    return -c * t*(t-2) + b;\r\n  },\r\n\r\n  copyAction: function (dest, src) {\r\n    dest.name  = src.name;\r\n    dest.axis  = src.axis;\r\n    dest.edges = src.edges;\r\n\r\n    return dest;\r\n  },\r\n\r\n  is         : require('./is'),\r\n  extend     : extend,\r\n  hypot      : require('./hypot'),\r\n  getOriginXY: require('./getOriginXY'),\r\n};\r\n\r\nextend(utils, require('./arr'));\r\nextend(utils, require('./domUtils'));\r\nextend(utils, require('./pointerUtils'));\r\nextend(utils, require('./rect'));\r\n\r\nmodule.exports = utils;\r\n","const scope   = require('../scope');\r\nconst utils   = require('./index');\r\nconst browser = require('./browser');\r\n\r\nconst finder = {\r\n  methodOrder: [ 'simulationResume', 'mouse', 'hasPointer', 'idle' ],\r\n\r\n  search: function (pointer, eventType, eventTarget) {\r\n    const mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\r\n                        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\r\n                        || pointer.pointerType === 4);\r\n    const pointerId = utils.getPointerId(pointer);\r\n    const details = { pointer, pointerId, mouseEvent, eventType, eventTarget };\r\n\r\n    for (const method of finder.methodOrder) {\r\n      const interaction = finder[method](details);\r\n\r\n      if (interaction) {\r\n        return interaction;\r\n      }\r\n    }\r\n  },\r\n\r\n  // try to resume simulation with a new pointer\r\n  simulationResume: function ({ mouseEvent, eventType, eventTarget }) {\r\n    if (!/down|start/i.test(eventType)) {\r\n      return null;\r\n    }\r\n\r\n    for (const interaction of scope.interactions) {\r\n      let element = eventTarget;\r\n\r\n      if (interaction.simulation && interaction.simulation.allowResume\r\n          && (interaction.mouse === mouseEvent)) {\r\n        while (element) {\r\n          // if the element is the interaction element\r\n          if (element === interaction.element) {\r\n            return interaction;\r\n          }\r\n          element = utils.parentNode(element);\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  // if it's a mouse interaction\r\n  mouse: function ({ pointerId, mouseEvent, eventType }) {\r\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\r\n      return null;\r\n    }\r\n\r\n    let firstNonActive;\r\n\r\n    for (const interaction of scope.interactions) {\r\n      if (interaction.mouse) {\r\n        // if it's a down event, skip interactions with running simulations\r\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) { continue; }\r\n\r\n        // if the interaction is active, return it immediately\r\n        if (interaction.interacting()) {\r\n          return interaction;\r\n        }\r\n        // otherwise save it and look for another active interaction\r\n        else if (!firstNonActive) {\r\n          firstNonActive = interaction;\r\n        }\r\n      }\r\n    }\r\n\r\n    // if no active mouse interaction was found use the first inactive mouse\r\n    // interaction\r\n    if (firstNonActive) {\r\n      return firstNonActive;\r\n    }\r\n\r\n    // Find any interaction specifically for mouse.\r\n    // ignore the interaction if the eventType is a mousedown, and a simulation\r\n    // is active\r\n    for (const interaction of scope.interactions) {\r\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\r\n        return interaction;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  // get interaction that has this pointer\r\n  hasPointer: function ({ pointerId }) {\r\n    for (const interaction of scope.interactions) {\r\n      if (utils.contains(interaction.pointerIds, pointerId)) {\r\n        return interaction;\r\n      }\r\n    }\r\n  },\r\n\r\n  // get first idle interaction\r\n  idle: function ({ mouseEvent }) {\r\n    for (const interaction of scope.interactions) {\r\n      // if there's already a pointer held down\r\n      if (interaction.pointerIds.length === 1) {\r\n        const target = interaction.target;\r\n        // don't add this pointer if there is a target interactable and it\r\n        // isn't gesturable\r\n        if (target && !target.options.gesture.enabled) {\r\n          continue;\r\n        }\r\n      }\r\n      // maximum of 2 pointers per interaction\r\n      else if (interaction.pointerIds.length >= 2) {\r\n        continue;\r\n      }\r\n\r\n      if (!interaction.interacting() && (mouseEvent === interaction.mouse)) {\r\n        return interaction;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n};\r\n\r\nmodule.exports = finder;\r\n","const win        = require('./window');\r\nconst isWindow   = require('./isWindow');\r\n\r\nconst is = {\r\n  array   : () => {},\r\n\r\n  window  : thing => thing === win.window || isWindow(thing),\r\n\r\n  docFrag : thing => is.object(thing) && thing.nodeType === 11,\r\n\r\n  object  : thing => !!thing && (typeof thing === 'object'),\r\n\r\n  function: thing => typeof thing === 'function',\r\n\r\n  number  : thing => typeof thing === 'number'  ,\r\n\r\n  bool    : thing => typeof thing === 'boolean' ,\r\n\r\n  string  : thing => typeof thing === 'string'  ,\r\n\r\n  element: thing => {\r\n    if (!thing || (typeof thing !== 'object')) { return false; }\r\n\r\n    const _window = win.getWindow(thing) || win.window;\r\n\r\n    return (/object|function/.test(typeof _window.Element)\r\n      ? thing instanceof _window.Element //DOM2\r\n      : thing.nodeType === 1 && typeof thing.nodeName === 'string');\r\n  },\r\n};\r\n\r\nis.array = thing => (is.object(thing)\r\n  && (typeof thing.length !== 'undefined')\r\n  && is.function(thing.splice));\r\n\r\nmodule.exports = is;\r\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\r\n","function pointerExtend (dest, source) {\r\n  for (const prop in source) {\r\n    const prefixedPropREs = module.exports.prefixedPropREs;\r\n    let deprecated = false;\r\n\r\n    // skip deprecated prefixed properties\r\n    for (const vendor in prefixedPropREs) {\r\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\r\n        deprecated = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!deprecated && typeof source[prop] !== 'function') {\r\n      dest[prop] = source[prop];\r\n    }\r\n  }\r\n  return dest;\r\n}\r\n\r\npointerExtend.prefixedPropREs = {\r\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\r\n};\r\n\r\nmodule.exports = pointerExtend;\r\n","const hypot         = require('./hypot');\r\nconst browser       = require('./browser');\r\nconst dom           = require('./domObjects');\r\nconst domUtils      = require('./domUtils');\r\nconst is            = require('./is');\r\nconst pointerExtend = require('./pointerExtend');\r\n\r\nconst pointerUtils = {\r\n  copyCoords: function (dest, src) {\r\n    dest.page = dest.page || {};\r\n    dest.page.x = src.page.x;\r\n    dest.page.y = src.page.y;\r\n\r\n    dest.client = dest.client || {};\r\n    dest.client.x = src.client.x;\r\n    dest.client.y = src.client.y;\r\n\r\n    dest.timeStamp = src.timeStamp;\r\n  },\r\n\r\n  setCoordDeltas: function (targetObj, prev, cur) {\r\n    targetObj.page.x    = cur.page.x    - prev.page.x;\r\n    targetObj.page.y    = cur.page.y    - prev.page.y;\r\n    targetObj.client.x  = cur.client.x  - prev.client.x;\r\n    targetObj.client.y  = cur.client.y  - prev.client.y;\r\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\r\n\r\n    // set pointer velocity\r\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\r\n\r\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\r\n    targetObj.page.vx      = targetObj.page.x / dt;\r\n    targetObj.page.vy      = targetObj.page.y / dt;\r\n\r\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\r\n    targetObj.client.vx    = targetObj.client.x / dt;\r\n    targetObj.client.vy    = targetObj.client.y / dt;\r\n  },\r\n\r\n  isNativePointer: function  (pointer) {\r\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\r\n  },\r\n\r\n  // Get specified X/Y coords for mouse or event.touches[0]\r\n  getXY: function (type, pointer, xy) {\r\n    xy = xy || {};\r\n    type = type || 'page';\r\n\r\n    xy.x = pointer[type + 'X'];\r\n    xy.y = pointer[type + 'Y'];\r\n\r\n    return xy;\r\n  },\r\n\r\n  getPageXY: function (pointer, page) {\r\n    page = page || {};\r\n\r\n    // Opera Mobile handles the viewport and scrolling oddly\r\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\r\n      pointerUtils.getXY('screen', pointer, page);\r\n\r\n      page.x += window.scrollX;\r\n      page.y += window.scrollY;\r\n    }\r\n    else {\r\n      pointerUtils.getXY('page', pointer, page);\r\n    }\r\n\r\n    return page;\r\n  },\r\n\r\n  getClientXY: function (pointer, client) {\r\n    client = client || {};\r\n\r\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\r\n      // Opera Mobile handles the viewport and scrolling oddly\r\n      pointerUtils.getXY('screen', pointer, client);\r\n    }\r\n    else {\r\n      pointerUtils.getXY('client', pointer, client);\r\n    }\r\n\r\n    return client;\r\n  },\r\n\r\n  getPointerId: function (pointer) {\r\n    return is.number(pointer.pointerId)? pointer.pointerId : pointer.identifier;\r\n  },\r\n\r\n  setCoords: function (targetObj, pointers, timeStamp) {\r\n    const pointer = (pointers.length > 1\r\n                     ? pointerUtils.pointerAverage(pointers)\r\n                     : pointers[0]);\r\n\r\n    const tmpXY = {};\r\n\r\n    pointerUtils.getPageXY(pointer, tmpXY);\r\n    targetObj.page.x = tmpXY.x;\r\n    targetObj.page.y = tmpXY.y;\r\n\r\n    pointerUtils.getClientXY(pointer, tmpXY);\r\n    targetObj.client.x = tmpXY.x;\r\n    targetObj.client.y = tmpXY.y;\r\n\r\n    targetObj.timeStamp = is.number(timeStamp) ? timeStamp :new Date().getTime();\r\n  },\r\n\r\n  pointerExtend: pointerExtend,\r\n\r\n  getTouchPair: function (event) {\r\n    const touches = [];\r\n\r\n    // array of touches is supplied\r\n    if (is.array(event)) {\r\n      touches[0] = event[0];\r\n      touches[1] = event[1];\r\n    }\r\n    // an event\r\n    else {\r\n      if (event.type === 'touchend') {\r\n        if (event.touches.length === 1) {\r\n          touches[0] = event.touches[0];\r\n          touches[1] = event.changedTouches[0];\r\n        }\r\n        else if (event.touches.length === 0) {\r\n          touches[0] = event.changedTouches[0];\r\n          touches[1] = event.changedTouches[1];\r\n        }\r\n      }\r\n      else {\r\n        touches[0] = event.touches[0];\r\n        touches[1] = event.touches[1];\r\n      }\r\n    }\r\n\r\n    return touches;\r\n  },\r\n\r\n  pointerAverage: function (pointers) {\r\n    const average = {\r\n      pageX  : 0,\r\n      pageY  : 0,\r\n      clientX: 0,\r\n      clientY: 0,\r\n      screenX: 0,\r\n      screenY: 0,\r\n    };\r\n\r\n    for (const pointer of pointers) {\r\n      for (const prop in average) {\r\n        average[prop] += pointer[prop];\r\n      }\r\n    }\r\n    for (const prop in average) {\r\n      average[prop] /= pointers.length;\r\n    }\r\n\r\n    return average;\r\n  },\r\n\r\n  touchBBox: function (event) {\r\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\r\n      return;\r\n    }\r\n\r\n    const touches = pointerUtils.getTouchPair(event);\r\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\r\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\r\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\r\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\r\n\r\n    return {\r\n      x: minX,\r\n      y: minY,\r\n      left: minX,\r\n      top: minY,\r\n      width: maxX - minX,\r\n      height: maxY - minY,\r\n    };\r\n  },\r\n\r\n  touchDistance: function (event, deltaSource) {\r\n    const sourceX = deltaSource + 'X';\r\n    const sourceY = deltaSource + 'Y';\r\n    const touches = pointerUtils.getTouchPair(event);\r\n\r\n\r\n    const dx = touches[0][sourceX] - touches[1][sourceX];\r\n    const dy = touches[0][sourceY] - touches[1][sourceY];\r\n\r\n    return hypot(dx, dy);\r\n  },\r\n\r\n  touchAngle: function (event, prevAngle, deltaSource) {\r\n    const sourceX = deltaSource + 'X';\r\n    const sourceY = deltaSource + 'Y';\r\n    const touches = pointerUtils.getTouchPair(event);\r\n    const dx = touches[1][sourceX] - touches[0][sourceX];\r\n    const dy = touches[1][sourceY] - touches[0][sourceY];\r\n    const angle = 180 * Math.atan2(dy , dx) / Math.PI;\r\n\r\n    return  angle;\r\n  },\r\n\r\n  getPointerType: function (pointer, interaction) {\r\n    // if the PointerEvent API isn't available, then the pointer must be ither\r\n    // a MouseEvent or TouchEvent\r\n    if (interaction.mouse)             { return 'mouse'; }\r\n    if (!browser.supportsPointerEvent) { return 'touch'; }\r\n\r\n    return is.string(pointer.pointerType)\r\n      ? pointer.pointerType\r\n      : [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType];\r\n  },\r\n\r\n  // [ event.target, event.currentTarget ]\r\n  getEventTargets: function (event) {\r\n    return [\r\n      domUtils.getActualElement(event.path ? event.path[0] : event.target),\r\n      domUtils.getActualElement(event.currentTarget),\r\n    ];\r\n  },\r\n};\r\n\r\nmodule.exports = pointerUtils;\r\n","const { window } = require('./window');\r\n\r\nconst vendors = ['ms', 'moz', 'webkit', 'o'];\r\nlet lastTime = 0;\r\nlet request;\r\nlet cancel;\r\n\r\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\r\n  request = window[vendors[x] + 'RequestAnimationFrame'];\r\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n}\r\n\r\nif (!request) {\r\n  request = function (callback) {\r\n    const currTime = new Date().getTime();\r\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\r\n                          timeToCall);\r\n\r\n    lastTime = currTime + timeToCall;\r\n    return id;\r\n  };\r\n}\r\n\r\nif (!cancel) {\r\n  cancel = function (id) {\r\n    clearTimeout(id);\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  request,\r\n  cancel,\r\n};\r\n","const extend = require('./extend');\r\nconst is = require('./is');\r\nconst {\r\n  closest,\r\n  parentNode,\r\n  getElementRect,\r\n} = require('./domUtils');\r\n\r\nconst rectUtils = {\r\n  getStringOptionResult: function (value, interactable, element) {\r\n    if (!is.string(value)) {\r\n      return null;\r\n    }\r\n\r\n    if (value === 'parent') {\r\n      value = parentNode(element);\r\n    }\r\n    else if (value === 'self') {\r\n      value = interactable.getRect(element);\r\n    }\r\n    else {\r\n      value = closest(element, value);\r\n    }\r\n\r\n    return value;\r\n  },\r\n\r\n  resolveRectLike: function (value, interactable, element, functionArgs) {\r\n    value = rectUtils.getStringOptionResult(value, interactable, element) || value;\r\n\r\n    if (is.function(value)) {\r\n      value = value.apply(null, functionArgs);\r\n    }\r\n\r\n    if (is.element(value)) {\r\n      value = getElementRect(value);\r\n    }\r\n\r\n    return value;\r\n  },\r\n\r\n  rectToXY: function (rect) {\r\n    return  rect && {\r\n      x: 'x' in rect ? rect.x : rect.left,\r\n      y: 'y' in rect ? rect.y : rect.top,\r\n    };\r\n  },\r\n\r\n  xywhToTlbr: function (rect) {\r\n    if (rect && !('left' in rect && 'top' in rect)) {\r\n      rect = extend({}, rect);\r\n\r\n      rect.left   = rect.x || 0;\r\n      rect.top    = rect.y || 0;\r\n      rect.right  = rect.right   || (rect.left + rect.width);\r\n      rect.bottom = rect.bottom  || (rect.top + rect.height);\r\n    }\r\n\r\n    return rect;\r\n  },\r\n\r\n  tlbrToXywh: function (rect) {\r\n    if (rect && !('x' in rect && 'y' in rect)) {\r\n      rect = extend({}, rect);\r\n\r\n      rect.x      = rect.left || 0;\r\n      rect.top    = rect.top  || 0;\r\n      rect.width  = rect.width  || (rect.right  - rect.x);\r\n      rect.height = rect.height || (rect.bottom - rect.y);\r\n    }\r\n\r\n    return rect;\r\n  },\r\n};\r\n\r\nmodule.exports = rectUtils;\r\n","const win = module.exports;\r\nconst isWindow = require('./isWindow');\r\n\r\nfunction init (window) {\r\n  // get wrapped window if using Shadow DOM polyfill\r\n\r\n  win.realWindow = window;\r\n\r\n  // create a TextNode\r\n  const el = window.document.createTextNode('');\r\n\r\n  // check if it's wrapped by a polyfill\r\n  if (el.ownerDocument !== window.document\r\n      && typeof window.wrap === 'function'\r\n    && window.wrap(el) === el) {\r\n    // use wrapped window\r\n    window = window.wrap(window);\r\n  }\r\n\r\n  win.window = window;\r\n}\r\n\r\nif (typeof window === 'undefined') {\r\n  win.window     = undefined;\r\n  win.realWindow = undefined;\r\n}\r\nelse {\r\n  init(window);\r\n}\r\n\r\nwin.getWindow = function getWindow (node) {\r\n  if (isWindow(node)) {\r\n    return node;\r\n  }\r\n\r\n  const rootNode = (node.ownerDocument || node);\r\n\r\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\r\n};\r\n\r\nwin.init = init;\r\n"]}